<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020年终总结</title>
      <link href="2021/02/18/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>2021/02/18/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[        <h2 id="计划中的事"   >          <a href="#计划中的事" class="heading-link"><i class="fas fa-link"></i></a><a href="#计划中的事" class="headerlink" title="计划中的事"></a>计划中的事</h2>      <p>又到了一年一度的总结时刻，按照惯例，还是先做年初立的Flag写一个总结。今年整体计划完成情况在75%，有很多计划没有完成。其中【出国旅游】因为疫情被迫终止，【账单小程序】则是因为没有用户便主动停止更新了。其余未完成的事则是因为懒惰没有完成，来年务必补上。</p><p><img src="https://file.2fun.xyz/2021/01/20210110090917455.png"></p><p>下面从兴趣爱好、专业技能、个人成长以及娱乐活动四个方面详细聊聊。</p><p><strong>兴趣爱好</strong></p><span id="more"></span><p>五一的时候和柯阳、宇哥一起去西溪逛了一圈，顺便用ACTION拍了些视频，回家剪了一个Vlog，完成了今年的Vlog计划。下面的视频播放不了的话可以点击<span class="exturl"><a class="exturl__link"   href="https://www.bilibili.com/video/BV1Xf4y1m766/" >Bilibili的链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>观看。</p><p><strong>专业技能</strong></p><p>在专业技能上，主要的能力提升在Java基础上，通过Java基础视频和Java相关书籍的学习，对Java基础有了更加深入的理解。除了Java能力，C/C++和Python的编程能力也有所提升，这主要得益于工作过程中对此的使用，具体可以看我的[半年总结](<a href="https://www.bearever.cn/index.php/story/alibaba-">https://www.bearever.cn/index.php/story/alibaba-</a><br>review/)。</p><p><strong>个人成长</strong></p><p>今年一共看了11本书，完成了年初的看10本书的计划。印象比较深刻的是《网络是怎样连接的》，这本书用生动的语言把网络连接的细节娓娓道来，就像是和一个朋友聊天一样，轻松自在。另外看了很多大刘的作品，自从看了《三体》之后，便喜欢上了这位科幻作家。</p><p><img src="https://file.2fun.xyz/2021/02/20210212045550679.png"></p><p><strong>娱乐活动</strong></p><p>去年就一直想要学游泳，可惜当时方法不对，始终没有学会，每次去游泳馆都是在泡澡。今年在阿廖的帮助下，终于把游泳学会了，现在可以游5米的距离，明年争取游10米。</p>        <h2 id="额外完成的事"   >          <a href="#额外完成的事" class="heading-link"><i class="fas fa-link"></i></a><a href="#额外完成的事" class="headerlink" title="额外完成的事"></a>额外完成的事</h2>      <p>除了计划中的事情，今年还做了一些别的有趣的事情，比如参加声网编程大赛、入职网易和购房。</p>        <h3 id="参加声网RTC编程大赛"   >          <a href="#参加声网RTC编程大赛" class="heading-link"><i class="fas fa-link"></i></a><a href="#参加声网RTC编程大赛" class="headerlink" title="参加声网RTC编程大赛"></a>参加声网RTC编程大赛</h3>      <p>3月份与朝怡、周神一起参加了<a href="https://www.bearever.cn/index.php/android/rtc-2020/">声网2020春季RTC编程大赛</a>，并开发了一款实时匿脸视频聊天软件，最终取得第三名的成绩。从创意到最终的作品只有一个月的时间，大家平时又得上班，所以只能下班回来和周末才能画画图和开发，非常感谢朝怡和周神的付出。大家一开始只是为了好玩才参加的，最后能获得奖项非常开心。（PS：@朝怡，你的奖状还在我这里，赶紧来拿啊）</p><p><img src="https://file.2fun.xyz/2021/01/20210131114948664.jpg"></p>        <h3 id="入职网易云音乐"   >          <a href="#入职网易云音乐" class="heading-link"><i class="fas fa-link"></i></a><a href="#入职网易云音乐" class="headerlink" title="入职网易云音乐"></a>入职网易云音乐</h3>      <p>今年8月份从阿里外包离职入职了网易云音乐，也算是实现了年初时立下的目标——进个大厂。读大学的时候第一次接触云音乐时就被这个款文艺范的播放器吸引了，当时就想：以后能进网易云音乐工作就好了，没想到这个愿望竟然在现在实现了，这或许也是缘分吧。</p><p><img src="https://file.2fun.xyz/2021/02/20210212031434721.jpg"></p>        <h3 id="购房"   >          <a href="#购房" class="heading-link"><i class="fas fa-link"></i></a><a href="#购房" class="headerlink" title="购房"></a>购房</h3>      <p>买房子这个事确实不在我的计划中，在我眼中现在居高不下的房价就是国家用来强制老百姓奋斗、控制民心的工具，当你疲于挣钱还房贷，就没有精力去想国家政策的事了。但是在另外一个角度，房子确实是一个必备品，它可以给你的爱人安全感。我和梁爽从高中到现在已有七八年，需要一套房子给对方一个安全感。再加上梁爽每次逛街的时候总喜欢去看那些漂亮的碗，说要是我有房子了就可以把这个买回去了。不管怎么说，以后就是房奴了<br>T T。</p><p><img src="https://file.2fun.xyz/2021/01/20210131144322221.jpg"></p>        <h2 id="爷爷走了"   >          <a href="#爷爷走了" class="heading-link"><i class="fas fa-link"></i></a><a href="#爷爷走了" class="headerlink" title="爷爷走了"></a>爷爷走了</h2>      <p>另外还有一件大事，但并不是什么开心的事情，那就是爷爷永远的离开了我。在外公去世的前几天，我的眼睛患了一个毛病，医生说是眼疲劳导致的眼压不平衡，会痛的睁不开眼。在眼病还没有完全好的时候，就收到了外公检查出了癌症的消息，在之后又没多久，外公去世了。去年12月的时候我的眼睛又开始疼了，当时没有太在意，过了两星期，眼睛终于不疼了。1月10日爸爸打电话过来哭着说：“爷爷走了”，那是我第一次听见爸爸哭。其实爷爷生病的事情我一直知道，但我总觉得今年的春节肯定能看到他的。第二天我买了机票回家，等处理完爷爷的后事，没多久就到到春节了，肺炎开始在地球上旋转，大批大批的人离开。或许是老天爷不想让爷爷看到世间的这幅惨状，而选择在春节的前几天带走爷爷。</p><p><img src="https://file.2fun.xyz/2021/02/20210212063055891.jpg"></p><p>(左起第二位是爷爷)</p>        <h2 id="月事记"   >          <a href="#月事记" class="heading-link"><i class="fas fa-link"></i></a><a href="#月事记" class="headerlink" title="月事记"></a>月事记</h2>      <p>按照惯例，本应该记录一下每一个月发生的大事，但总觉得这样过于流水账，所以移除了几个平淡的月份。</p><p><strong>一月</strong></p><p>一月发生了很多事，爷爷去世、疫情肆掠，整个世界都灰蒙蒙的。配图是我姐姐的儿子和我弟弟在玩烟火，在灰色背景下的光。老人离去，新人到来，生活继续。</p><p><img src="https://file.2fun.xyz/2021/01/20210131130114147.jpg"></p><p><strong>二月</strong></p><p>在梁爽家待了半个月后，我回到了杭州，开启在家办公模式，走的最远的路是去小区门口取外卖，逛的最多的地方是阳台和楼顶天台。</p><p><img src="https://file.2fun.xyz/2021/01/20210131154826829.jpg"></p><p><strong>三月</strong></p><p>三月是我的生日，一直以来我对生日都没啥兴趣，但是这个生日必须记一下，这是我过的最有趣的生日。梁爽提前几天就在给我准备生日礼物，生日的当天还定了一个蛋糕给我惊喜，我们一起做了饭，看看电视，很开心。</p><p><img src="https://file.2fun.xyz/2021/01/20210131132414353.jpg"></p><p>最后看看梁爽搞了几天的生日礼物。</p><p><strong>六月</strong></p><p>六月底的时候因为声网线上分享活动的事，去了一次周神家，感受了一下周神家的大豪宅。PS4+高配主机+电竞椅简直不要更爽了！另外某人一来就躺沙发上，也太舒服了吧。</p><p><img src="https://file.2fun.xyz/2021/01/20210131153429200.jpg"></p><p><strong>七月</strong></p><p>梁爽妈妈七月来杭州玩了两个星期，每天都做很多好吃的等我们回去吃，那段时间我最期待的就是回去吃饭。今天炒个肉丝，明天熬个骨头汤，后天卤个鸡爪……就是待得时间太短了，每天都有这么多好吃就好了，嘿嘿嘿。</p><p><img src="https://file.2fun.xyz/2021/01/20210131154058436.jpg"></p><p><strong>八月</strong></p><p>八月入职了网易云音乐，但是我在这里更聊下另外一件事，那就是去北京旅游。八月中旬的时候和梁爽去北京玩了四天，体验了一波极限旅行，逛了天坛、天安门、故宫、王府井、八达岭长城、圆明园，还去清华/北京大学门口看了看（因为疫情进不去）。更重要的事情是我和王老师见了一面，不得不说王老师这么多年了，还是这么帅啊。那天我们一起骑着单车经过天安门，实在是太开心了！</p><p><img src="https://file.2fun.xyz/2021/01/20210131142634105.jpg"></p><p><strong>九月</strong></p><p>九月的时候约褚老师去西湖边上逛了逛，问问近况，一起聊了聊游戏，吃了份面条。突然觉得很想回到学校，在实验楼和演播楼之间穿梭，就停在大二不要前进就好了。</p><p><img src="https://file.2fun.xyz/2021/01/20210131143556716.jpg"></p><p><strong>十月</strong></p><p>十月国庆节的时候回重庆把房子买了，这个前面也有提到就不细说了。月底的时候我回重庆签购房贷款合同，这天下午，妈妈打电话来说老爸肺不太舒服，正在医院。以前去医院的话我妈妈一般不会特意打电话过来，这让我觉得不太对劲，所以我买了高铁回了趟家，我看到老爸正躺在医院的病床上，鼻子上插着氧气管，模样十分憔悴。老爸平时一直吸烟，以前也经常咳嗽，这一次不知道怎么的突然就特别痛，在家休息了两天还是不见好转才来县医院的，要在医院住两个星期。我看了一圈，这里的病人都是年龄很大的老人，爸爸在这里竟然算年轻的，他之所以在这里看病，并不是因为这里医术高超，仅仅是因为这里便宜。可能是出门的比较着急，我发现爸爸穿了一件单薄的外套，于是我去超市买了一件加厚的睡衣，这样他在医院穿衣服就更加方便了，不会因为换衣服，把手臂上的针头碰到。<br>所幸没有大问题，住了两周之后老爸就出院了。</p><p><strong>十一月</strong></p><p>不知道是因为在网上刷了太多五菱宏光MINI的视频，还是怎么的，突然很想买一辆，就和于冲他们一起约去车店看了看。整车到手价4.3W，但是这个车续航只有170KM，我们租的房子那里连两轮电动车都不好充电，就更别提四轮的了，所以没有买。对于没有充电桩的用户，电动车还是太不方便了，继续摇号吧。</p><p><img src="https://file.2fun.xyz/2021/01/20210131151457980.jpg"></p><p><strong>十二月</strong></p><p>十二月梁爽生日，我们去逛了一个科技展（为啥是科技展？），然后吃了泰国菜，这个虾米卷很好吃。</p><p><img src="https://file.2fun.xyz/2021/01/20210131145736652.jpg"></p>        <h2 id="2021年计划"   >          <a href="#2021年计划" class="heading-link"><i class="fas fa-link"></i></a><a href="#2021年计划" class="headerlink" title="2021年计划"></a>2021年计划</h2>      <p>2021年的计划主要是对上一年遗漏的补充，另外在个人兴趣方面顺势而为，创建一个视频号，发布3+条视频。最后希望自己在2021年工作顺利，生活舒心，立的Flag都能完成。</p><p><img src="https://file.2fun.xyz/2021/02/20210218023841970.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CoordinatorLayout.Behavior使用指南</title>
      <link href="2020/12/27/CoordinatorLayout.Behavior%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>2020/12/27/CoordinatorLayout.Behavior%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[        <h2 id="1-Behavior-介绍"   >          <a href="#1-Behavior-介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Behavior-介绍" class="headerlink" title="1. Behavior 介绍"></a>1. Behavior 介绍</h2>      <p>Behavior是CoordinatorLayout的子类，用于处理各个子view之间的行为（<br><strong>这就意味着需要联动的View得用CoordinatorLayout包起来</strong> ），例如：手指向下滑动的时候是View A下移，还是View<br>B下移，亦或者给View C来一个旋转？一个例子就是Bilibili客户端视频播放页的滑动效果，如图1所示：</p><p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5446761662/b7c9/fef8/b880/c9677c9541aad643b1e28ee64b699651.gif" alt="图1.Bilinili客户端的滑动效果"></p><p><em>图1. Bilibili客户端视频页滑动效果</em></p><span id="more"></span>        <h2 id="2-如何设置Behavior"   >          <a href="#2-如何设置Behavior" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-如何设置Behavior" class="headerlink" title="2. 如何设置Behavior"></a>2. 如何设置Behavior</h2>      <p>设置Behavior有两种方式：XMl布局设置和Java（Kotlin）代码设置</p>        <h3 id="2-1-XML布局设置"   >          <a href="#2-1-XML布局设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-XML布局设置" class="headerlink" title="2.1 XML布局设置"></a>2.1 XML布局设置</h3>      <p>首先将CoordinatorLayout设置为父布局，对需要加Behavior控件设置<code>app:layout_behavior&quot;</code>属性。</p><pre><code>&lt;androidx.core.widget.NestedScrollView    ...    app:layout_behavior= &quot;com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior&quot;&gt;</code></pre>        <h3 id="2-2-Java-Kotlin代码设置"   >          <a href="#2-2-Java-Kotlin代码设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-Java-Kotlin代码设置" class="headerlink" title="2.2 Java/Kotlin代码设置"></a>2.2 Java/Kotlin代码设置</h3>      <pre><code>CoordinatorLayout.LayoutParams params = (CoordinatorLayout.LayoutParams)scrollView.getLayoutParams();params.setBehavior(new MyBehavoir());scrollView.setLayoutParams(params);</code></pre>        <h2 id="3"   >          <a href="#3" class="heading-link"><i class="fas fa-link"></i></a><a href="#3" class="headerlink" title="3."></a>3.</h2>      <p><span class="exturl"><a class="exturl__link"   href="https://developer.android.google.cn/reference/com/google/android/material/appbar/AppBarLayout?hl=en" >AppBarLayout</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p>AppBarLayout内部有一个默认实现的Behavior，经常和Toolbar、Recycler等结合使用，布局如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:fitsSystemWindows=&quot;true&quot;&gt;    &lt;com.google.android.material.appbar.AppBarLayout        android:id=&quot;@+id/appbar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;100dp&quot;        android:fitsSystemWindows=&quot;true&quot;&gt;        &lt;androidx.appcompat.widget.Toolbar            android:id=&quot;@+id/toolbar&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;?attr/actionBarSize&quot;            app:layout_scrollFlags=&quot;scroll&quot;            app:layout_scrollInterpolator=&quot;@android:anim/decelerate_interpolator&quot;            app:title=&quot;标题栏&quot; /&gt;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;    &lt;androidx.core.widget.NestedScrollView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;                                           app:layout_behavior= &quot;com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior&quot;&gt;    &lt;/androidx.core.widget.NestedScrollView&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;</code></pre><p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5451019026/58c8/1e75/2d17/fd54626fbf5b81a14902d710bc09f591.gif"></p><p><em>图2. AppBarLayout效果</em></p><p>AppBarLayout默认的Behavior是<code>AppBarLayout$ScrollingViewBehavior</code>，可以设置layout_scrollFlags和layout_scrollInterpolator等参数，分别表示动画风格和动画差值器。正如上面的实例代码，我们对Toolbar设置了如下的属性，使toolbar可以跟随列表滚到而显示和隐藏。</p><pre><code> &lt;androidx.appcompat.widget.Toolbar           ...            app:layout_scrollFlags=&quot;scroll&quot;            app:layout_scrollInterpolator=&quot;@android:anim/decelerate_interpolator&quot;           ... /&gt;</code></pre>        <h4 id="3-1-layout-scrollFlags"   >          <a href="#3-1-layout-scrollFlags" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-layout-scrollFlags" class="headerlink" title="3.1 layout_scrollFlags"></a>3.1 layout_scrollFlags</h4>      <p>layout_scrollFlags是ScrollingViewBehavior支持的一个属性，用来设置滚动的风格，包括移入、移出效果，一共有七个，分别是noScroll、scroll、exitUntilCollapsed、enterAlways、enterAlwaysCollapsed、snap和snapMargins，其效果如表1、表2所示。</p><div class="table-container"><table><thead><tr><th>noScroll</th><th>scroll</th><th>exitUntilCollapsed</th><th>enterAlways</th></tr></thead><tbody><tr><td><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5451460834/cd7f/57e4/a50e/bc05347f3caa63583efba1dbba3b8d9c.gif"></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5451019026/58c8/1e75/2d17/fd54626fbf5b81a14902d710bc09f591.gif"></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5451899328/bd10/28a6/30c5/9fc1cfb382671221a6c3359808808352.gif"></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5452109480/3e41/d134/4142/263f816ae8eddbd07ef6c95e0631d3f0.gif"></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><em>表1. layout_scrollFlags的演示效果1</em></td><td></td><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>enterAlwaysCollapsed</th><th>snap</th><th>snapMargins</th></tr></thead><tbody><tr><td><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5452999490/ad9f/00a7/7bfd/c5dde21104220d37bf7bd0057be0b6bd.gif"></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5453229865/26cf/c6bb/d2c3/e8ac55ea17a14ce0a1a53a0d4ebc4990.gif"></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5453546092/a584/b537/e2cb/43adde0084ac9307355e8e5721ea40ed.gif"></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><em>表2. layout_scrollFlags的演示效果2</em></td><td></td><td></td></tr></tbody></table></div><p>关于这个七个标记的具体说明如表3所示。</p><div class="table-container"><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>noScroll</td><td>禁用视图上的滚动。此标志不应与其他任何标志相结合。</td></tr><tr><td>scroll</td><td>这个标志会让view直接跟随滚动事件。如果其他标记需要在滚动的情况下使用，则必须结合<code>scroll</code>一起使用，否则设置无效。</td></tr><tr><td>exitUntilCollapsed</td><td>手指上滑会将view折叠，折叠的高度为minHeight的值，下拉再慢慢展开，高度为height的值。</td></tr><tr><td>enterAlways</td><td></td></tr><tr><td>这个标志和单纯的<code>scroll</code>很相似，区别在与<code>enterAlways</code>会在你下拉的时候就显示view，上滑的时候就隐藏view，而<code>scroll</code>则必须要把列表滚到顶部之后才会显示、隐藏view。</td><td></td></tr><tr><td>enterAlwaysCollapsed</td><td></td></tr><tr><td>需要与<code>enterAlways</code>搭配使用，效果是下拉时先显示折叠时的高度，继续下拉，列表到顶则会讲view展开。</td><td></td></tr><tr><td>snap</td><td></td></tr><tr><td>与单纯的<code>scroll</code>效果很相似，区别在于<code>snap</code>有吸附效果，当view的位置很靠近显示或者隐藏时，会使用动画自动显示或者隐藏，就像是有磁铁吸附的感觉。</td><td></td></tr><tr><td>snapMargins</td><td>需要与<code>snap</code>搭配使用，吸附位置为view的top和bottom margin值。</td></tr><tr><td></td><td></td></tr><tr><td><em>表3. layout_scrollFlags的参数说明</em></td><td></td></tr></tbody></table></div>        <h2 id="4-自定义Behavior"   >          <a href="#4-自定义Behavior" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-自定义Behavior" class="headerlink" title="4 自定义Behavior"></a>4 自定义Behavior</h2>              <h3 id="4-1-核心方法介绍"   >          <a href="#4-1-核心方法介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-核心方法介绍" class="headerlink" title="4.1 核心方法介绍"></a>4.1 核心方法介绍</h3>      <p>在正式自定义一个Behavior之前，先介绍一下Behavior的几个比较重要的方法：</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean layoutDependsOn(@NonNull CoordinatorLayout parent, @NonNull V child,</td><td></td></tr><tr><td>@NonNull View dependency)</td><td>判断<code>child</code>是否依赖<code>dependency</code></td></tr><tr><td>boolean onDependentViewChanged(@NonNull CoordinatorLayout parent, @NonNull V</td><td></td></tr><tr><td>child, @NonNull View dependency)</td><td>当<code>dependency</code>发生了变化的时候（位置、旋转角度等）会被调用</td></tr><tr><td>void onDependentViewRemoved(@NonNull CoordinatorLayout parent, @NonNull V</td><td></td></tr><tr><td>child, @NonNull View dependency)</td><td>当<code>dependency</code>被移除之后会调用此方法。</td></tr><tr><td>boolean onLayoutChild(@NonNull CoordinatorLayout parent, @NonNull View child,</td><td></td></tr><tr><td>int layoutDirection)</td><td>在这里可以给<code>child</code>进行初始位置的布局。返回ture，表示我们自定义的布局，否则使用系统默认的布局。</td></tr><tr><td>boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</td><td></td></tr><tr><td>@NonNull V child, @NonNull View directTargetChild, @NonNull View target,</td><td></td></tr><tr><td>@ScrollAxis int axes, @NestedScrollType int type)</td><td></td></tr><tr><td>一个滚动事件等开始会触发此回调，可以在这里返回是否需要消耗本次滚动事件</td><td></td></tr><tr><td>void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull</td><td></td></tr><tr><td>V child, @NonNull View target, int dx, int dy, @NonNull int[] consumed,</td><td></td></tr><tr><td>@NestedScrollType int type)</td><td></td></tr><tr><td>如果<code>onStartNestedScroll</code>返回了true，则在滚动中会回调此方法，可以在这里做view做位置等等变化</td><td></td></tr><tr><td>void onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull</td><td></td></tr><tr><td>V child, @NonNull View target, @NestedScrollType int type)</td><td></td></tr><tr><td>一个滚动事件等结束会触发此回调，可以在这里给<code>child</code>添加回弹动画。</td><td></td></tr><tr><td></td><td></td></tr><tr><td><em>表4. Behavior的几个主要方法</em></td><td></td></tr></tbody></table></div>        <h3 id="4-2-基本流程"   >          <a href="#4-2-基本流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-基本流程" class="headerlink" title="4.2 基本流程"></a>4.2 基本流程</h3>      <p>自定义Behavior的流程分为3步：</p><ol><li>判断依赖关系，即谁依赖谁</li><li>当被依赖的view发生了变化时对依赖view进行变化</li><li>处理嵌套滚动事件</li></ol>        <h5 id="4-2-1-判断依赖关系，即谁依赖谁"   >          <a href="#4-2-1-判断依赖关系，即谁依赖谁" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-1-判断依赖关系，即谁依赖谁" class="headerlink" title="4.2.1 判断依赖关系，即谁依赖谁"></a>4.2.1 判断依赖关系，即谁依赖谁</h5>      <p>假设A依赖B，则Behavior应该设置在A上面，然后在<code>layoutDependsOn</code>方法里面，判断如果<code>dependency</code>为B则返回true。</p>        <h5 id="4-2-2-当被依赖的view发生了变化时对依赖view进行变化"   >          <a href="#4-2-2-当被依赖的view发生了变化时对依赖view进行变化" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-2-当被依赖的view发生了变化时对依赖view进行变化" class="headerlink" title="4.2.2 当被依赖的view发生了变化时对依赖view进行变化"></a>4.2.2 当被依赖的view发生了变化时对依赖view进行变化</h5>      <p><code>dependency</code>的位置、方向等变化之后会调用<code>onDependentViewChanged</code>方法，在这个方法里面，可以对view进行跟随变化，比如将view对bottom设置为<code>dependency</code>top位置，则view会始终在<code>dependency</code>的上面，高度跟随<code>dependency</code>动态变化。如果需要在<code>dependency</code>被移除的时候对view进行变化，则重写<code>onDependentViewRemoved</code>即可。</p>        <h5 id="4-2-3-处理嵌套滚动事件"   >          <a href="#4-2-3-处理嵌套滚动事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-3-处理嵌套滚动事件" class="headerlink" title="4.2.3 处理嵌套滚动事件"></a>4.2.3 处理嵌套滚动事件</h5>      <p>处理一个滚动事件的流程是：</p><ol><li><p>判断滑动方向是否是自己需要的</p></li><li><p>处理滑动值</p></li><li><p>滚动事件结束是否需要回弹动画</p></li></ol><p>与此对应的三个方法是：</p><ol><li>boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type)</li></ol><p>其中<code>axes</code>表示的是本次滚动事件的方向、<code>type</code>表示手指触摸或者是惯性滚动。</p><pre><code>    // 判断滚动是否是竖直方向boolean result = (axes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;</code></pre><ol start="2"><li>void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type)</li></ol><p>滚动事件里面的每一次滑动会调用此方法，在这里我们可以对滑动进行拦截处理。<code>consumed</code>是一个数组，表示Behavior消耗了的X、Y方向的滑动值，消耗的滑动值就不会被传递为子view了。</p><ol start="3"><li>void onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View target, @NestedScrollType int type)</li></ol><p>滚动事件结束的时候会调用此方法，可以在这里判断view是否需要回弹到默认位置。<br><strong>需要注意的地方是：通过动画移动view到默认位置也是会触发<code>onNestedPreScroll</code>方法的，可以结合<code>type</code>判断是否是手指触摸导致的。</strong></p>        <h2 id="5-实例"   >          <a href="#5-实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-实例" class="headerlink" title="5 实例"></a>5 实例</h2>      <p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5465576894/aa53/5095/a141/97e6a8aaa1f846962af914808ef83b28.gif"></p><p><em>图3. 实例效果图</em></p><p>从图中可以知道，顶部的图片会跟随列表的滚动，列表下移的时候图片会先下移，超过默认高度之后会有一个放大的效果。也就是说背景图的高度和大小是依赖列表的位置的。所以，我们可以将Behavior设置在背景图上面，让其依赖列表。布局如图3所示。</p><p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5465693999/4a78/141b/6506/8084c8332b7b827d83d2a6bdf3ee85fb.png"></p><p><em>图4. 布局文件</em></p><p>接着开始自定义<code>MyBehavoir</code>。</p><p>重写<code>layoutDependsOn</code>让图片依赖背景列表。</p><pre><code>@Overridepublic boolean layoutDependsOn(@NonNull CoordinatorLayout parent, @NonNull View child, @NonNull View dependency) &#123;    return dependency instanceof NestedScrollView;&#125;</code></pre><p>当列表的位置变化的时候需要对图片的位置进行变化，使图片的底部始终跟随列表的顶部。</p><pre><code>@Overridepublic boolean onDependentViewChanged(@NonNull CoordinatorLayout parent, @NonNull View child, @NonNull View dependency) &#123;    int top = dependency.getTop();    int bottom = child.getBottom();    ViewCompat.offsetTopAndBottom(child, top - bottom);    return true;&#125;</code></pre><p>因为这个列表是竖直滚动的，所以我们只需要监听竖直方向的滚动。</p><pre><code>@Overridepublic boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type) &#123;    return (axes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;&#125;</code></pre><p>让列表监听滚动事件，跟随手指滑动。</p><pre><code>@Overridepublic void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) &#123;    ViewCompat.offsetTopAndBottom(target, -dy);    consumed[1] = dy;&#125;</code></pre><p>看看效果。</p><p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5463962431/9c7d/5de5/23fb/493fc5c848bff12f453879c4004927a5.gif"></p><p><em>图5. 滑动效果演示</em></p><p>现在已经实现了图片底部贴着列表顶部，并且图片滚跟随列表移动。但是这里有一个问题，就是当图片不可见的时候滚动的应该是列表内部元素，而不是对列表进行位移。我们可以通过<code>canScrollVertically</code>判断列表是否滚动到了顶部，如果列表可以向下滑动，则说明列表没有到顶部。</p><pre><code>@Overridepublic void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) &#123;    if (dy &lt; 0) &#123; //手指下滑        //列表是否可以继续下滑，如果不可以，则说明列表到顶了        boolean canScrollDown = target.canScrollVertically(-1);        if (!canScrollDown) &#123;//列表到顶了，此时需要移动列表位置            ViewCompat.offsetTopAndBottom(target, -dy);            consumed[1] = dy; //滑动的距离被Behavior消耗了        &#125;    &#125; else if (dy &gt; 0) &#123; //手指上滑        //如果列表的位置已经在顶部了，则滑动内部元素，否则移动列表的位置        if (target.getTop() &gt; 0) &#123;            int maxDy = Math.min(target.getTop(), dy);            ViewCompat.offsetTopAndBottom(target, -maxDy);            consumed[1] = maxDy;        &#125;    &#125;&#125;</code></pre><p>现在列表和图片都可以滚动了。</p><p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5463990611/e85f/eee8/b06e/d10116319537053473939599c60d9dfc.gif"></p><p><em>图6. 支持列表内部滚动</em></p><p>但是还是有点问题，列表会无限制的下移，我们可以限制列表下移为高度不超过图片的高度。</p><pre><code>@Overridepublic void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, int type) &#123;    if (dy &lt; 0) &#123; //手指下滑        //列表是否可以继续下滑，如果不可以，则说明列表到顶了        boolean canScrollDown = target.canScrollVertically(-1);        if (!canScrollDown) &#123;//列表到顶了，此时需要移动列表位置            //列表下移的位置不得超过 图片的高度            int maxDy = Math.max(dy, target.getTop() - child.getHeight());            ViewCompat.offsetTopAndBottom(target, -maxDy);            //滑动的距离被Behavior消耗了            consumed[1] = maxDy;        &#125;    &#125; else if (dy &gt; 0) &#123; //手指上滑        //如果列表的位置已经在顶部了，则滑动内部元素，否则移动列表的位置        if (target.getTop() &gt; 0) &#123;            int maxDy = Math.min(target.getTop(), dy);            ViewCompat.offsetTopAndBottom(target, -maxDy);            consumed[1] = maxDy;        &#125;    &#125;&#125;</code></pre><p>效果如下：</p><p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5465299267/5bed/6f9b/86aa/6c6e018e0dba5f0926559aa8f4dc81a1.gif"></p><p><em>图7. 限制列表下移的最大位置</em></p><p>现在就剩下最后一个问题了，那就是刚进来的时候图片不可见，我们希望布局的初始位置是图片显示默认高度，列表在图片的底部，所以我们可以重写<code>onLayoutChild</code>对列表进行布局。</p><pre><code>@Overridepublic boolean onLayoutChild(@NonNull CoordinatorLayout parent, @NonNull View child, int layoutDirection) &#123;    parent.onLayoutChild(child, layoutDirection);    //获取child以来的控件列表    List&lt;View&gt; dependencies = parent.getDependencies(child);    if (dependencies.size() &gt; 0) &#123;        //因为这个我们只依赖了一个列表，所以直接取第0个元素        View dependency = dependencies.get(0);        ViewCompat.offsetTopAndBottom(dependency, child.getHeight());    &#125;    return true;&#125;</code></pre><p>最终的效果就是这样的了：</p><p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5465576894/aa53/5095/a141/97e6a8aaa1f846962af914808ef83b28.gif"></p><p><em>图8. 列表默认布局在图片下方</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>getString还是optString？</title>
      <link href="2020/10/29/getString%E8%BF%98%E6%98%AFoptString%EF%BC%9F/"/>
      <url>2020/10/29/getString%E8%BF%98%E6%98%AFoptString%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用Java的JSONObject解析Json数据时经常会遇到需要解析字符串的情况，那是该使用<code>getString</code>还是<code>optString</code>或者其他呢？</p></blockquote>        <h2 id="Json"   >          <a href="#Json" class="heading-link"><i class="fas fa-link"></i></a><a href="#Json" class="headerlink" title="Json"></a>Json</h2>      <p>假设现在有这样一个Json字符串，现在要获取<code>k</code>的值，要怎么做呢？</p><pre><code>&#123;</code></pre><span id="more"></span><pre><code>    &quot;k&quot; : &quot;我是值&quot;&#125;</code></pre>        <h2 id="使用getString"   >          <a href="#使用getString" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用getString" class="headerlink" title="使用getString"></a>使用getString</h2>      <p>我心中暗暗自喜，这还不简单，直接使用JSONObject解析不就行了，看我操作一波。</p><pre><code>String json = &quot;&#123;\&quot;k\&quot;:\&quot;我是值\&quot;&#125;&quot;;try &#123;    JSONObject jsonObject = new JSONObject(json);    String k = jsonObject.getString(&quot;k&quot;);    System.out.println(&quot;k:&quot; + k);&#125; catch (JSONException e) &#123;    e.printStackTrace();&#125;</code></pre><p>成功获取到了k的值“我是值”。</p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92b4d168d8642e72b1b4b7bdi7L2T301?sign=sZWUO6kN6KP9v4wvpi9Vtb8bL00=&expire=1603957453" style=""  alt="popo_2020-10-2318-47-33.jpg"></p><p>那如果Json的内容是这样的，k不存在了呢？</p><pre><code>&#123;    &quot;t&quot; : &quot;我是值&quot;&#125;</code></pre><p>再次运行代码会抛出<code>JSONException</code></p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92b58f68d8642e60e41d096XZC57BH01?sign=qpoxmFtCNsWMzFGw6I59djVE4hI=&expire=1603957453" style=""  alt="popo_2020-10-2318-50-24.jpg"></p>        <h2 id="使用optString"   >          <a href="#使用optString" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用optString" class="headerlink" title="使用optString"></a>使用optString</h2>      <p>虽然异常被catch住了，但是代码也被中断了，大多数情况我希望他能在值不存在的时候返回一个空字符串。于是我又改了一下代码，把<code>getString</code>换成了<code>optString</code>（为了演示的清晰，我把空字符串使用中文输出了出来）。</p><pre><code>String json = &quot;&#123;\&quot;t\&quot;:\&quot;我是值\&quot;&#125;&quot;;try &#123;    JSONObject jsonObject = new JSONObject(json);    String k = jsonObject.optString(&quot;k&quot;);    System.out.println(&quot;k:&quot; +  (k.isEmpty() ? &quot;空字符串&quot; : k));&#125; catch (JSONException e) &#123;    e.printStackTrace();&#125;</code></pre><p>然后成功的返回了我期望的空字符串返回值。</p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92c3ef68d8642e6c1de497MpzmiiKM01?sign=CmvwqPPD3Z_spWCP4R_qb3OFGpc=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.51.58.png"></p><p>直到有一天Json数据变成了这种的，k还存在，只是变成了null。</p><pre><code>&#123;    &quot;k&quot; : null&#125;</code></pre><p>然后解析出来的k是<code>&quot;null&quot;</code>，这就很尴尬了，就算这个k是null，我也希望它解析成空字符串。</p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92c4878c56741bf7d48fdbNa7LGlCL01?sign=22bSnGFwHsqnAdAAAVkW1i-O3F8=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.54.30.png"></p>        <h2 id="判断是否为null"   >          <a href="#判断是否为null" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断是否为null" class="headerlink" title="判断是否为null"></a>判断是否为null</h2>      <p>当然这难不倒我，经过观察我发现，只有当这个数据是null的时候才会出现这个情况，那我提前判断一下是否为null然后在取值不就行了吗，于是有了下面的代码。</p><pre><code>String json = &quot;&#123;\&quot;k\&quot;: null &#125;&quot;;try &#123;    JSONObject jsonObject = new JSONObject(json);    String k = &quot;&quot;;    if (!jsonObject.isNull(&quot;k&quot;)) &#123;        k = jsonObject.optString(&quot;k&quot;);    &#125;    System.out.println(&quot;k:&quot; + (k.isEmpty() ? &quot;空字符串&quot; : k));&#125; catch (JSONException e) &#123;    e.printStackTrace();&#125;</code></pre><p>最后结果也如我所愿，成功的输出了空字符串</p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92c4f468d8642e72b1b7caCYJieitv01?sign=Naokis8SGDl0937v22m0Zwli8zE=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.56.25.png"></p>        <h2 id="为什么会输出”null”"   >          <a href="#为什么会输出”null”" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么会输出”null”" class="headerlink" title="为什么会输出”null”"></a>为什么会输出”null”</h2>      <p>现在我知道在解析字符串的时候应该先判断这个值是否为null然后在使用optString获取值，那为什么值为null的时候会出现<code>&quot;null&quot;</code>呢？<br>点开<code>optString(@Nullable String name)</code>会发现它调用了<code>optString(@Nullable String name, @NonNull String fallback)</code>，然后查看该函数可以看到，当name对应到值存在的时候就直接返回，否则返回fallback的值。而<code>optString(@Nullable String name)</code>默认使用的是空字符作为fallback。 <img   src="http://pfp.ps.netease.com/kmspvt/file/5f92bcd48c56741bf7d48dc19kF1AVmm01?sign=ENNL2Mj-1Uzd_3r5dg4IX0oS8NM=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.21.42.png"></p><p>通过添加断点，可以看到object的值已经变成了<code>&quot;null&quot;</code>。 <img   src="http://pfp.ps.netease.com/kmspvt/file/5f92be2d68d8642e6e165115BdP5NxL101?sign=cjjtIbkODUiGeI8dY0pcwswqDtc=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.27.27.png"></p><p>而<code>opt(@Nullable String name)</code>仅仅是将nameValuePairs对应的值取出来，所以重点变成了nameValuePairs是怎赋值进去的。</p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92be946158bc3fb8967656ZX4U0Ywb01?sign=faKnAXdXcArAhrBM_zJuT02Cd_M=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.28.26.png"></p><p>当我们使用Json字符串创建JSONObject对象的时候，会通过<code>JSONTokener</code>对字符串进行解析，如下：</p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92bfdd6158bc3faebbde40P6qAYtiB01?sign=ATwYOIOoY1GozL3UJrLkuqFl_nY=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.34.41.png"></p><p>当值为null的时候会执行到default语句，调用<code>readLiteral()</code>。</p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92c0826158bc3fa292d0ffTV33plNy01?sign=GHnP4D3MjgvGbXy1Y29e2vLy6VY=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.37.22.png"></p><p>当值为null的时候会返回一个<code>JSONObject.NULL</code>对象，而这个对象的toString方法刚好就是<code>&quot;null&quot;</code>。</p><p>![截屏2020-10-23<br>下午7.39.59.png](<span class="exturl"><a class="exturl__link"   href="http://pfp.ps.netease.com/kmspvt/file/5f92c1442dcade27240ad9e81LDXu6U801?sign=1kTjrSlMRfw-" >http://pfp.ps.netease.com/kmspvt/file/5f92c1442dcade27240ad9e81LDXu6U801?sign=1kTjrSlMRfw-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>GxkX_cfirGgpR6k=&amp;expire=1603957453)</p><p>在<code>optString</code>方法里面会获取对象的<code>toString</code>值，所以最终返回了<code>&quot;null&quot;</code>，那一切至此就可以结案了。</p><p><img   src="http://pfp.ps.netease.com/kmspvt/file/5f92c1f58c56744310599b53Iw5WJr2N01?sign=63dOlo1zcPQGcGQHO97K7-10Snk=&expire=1603957453" style=""  alt="截屏2020-10-23下午7.43.35.png"></p>        <h2 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>      <p>在使用<code>JSONObject</code>解析字符串的时候，如果需求是在值不存在或者为null的时候返回空字符串，可以先对该值进行<code>isNull</code>判断，如果不为null就使用<code>optString</code>获取值，否则返回空字符串。同样的对于其他的<code>optXXXX</code>方法使用前也需要注意一下，比如<code>optJSONObject</code>，该方法可以解析一个JSONObject对象，如果不存在就返回null，不过在使用这个返回的对象之前还是要先进行非空判断的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云函数计算部署Wordpress博客系统</title>
      <link href="2020/07/21/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E9%83%A8%E7%BD%B2Wordpress%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/07/21/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E9%83%A8%E7%BD%B2Wordpress%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/2020/07/20200722034153856.png" alt="阿里云函数计算部署Wordpress"></p>        <h2 id="0-起因"   >          <a href="#0-起因" class="heading-link"><i class="fas fa-link"></i></a><a href="#0-起因" class="headerlink" title="0.起因"></a>0.起因</h2>      <p>这篇文章是对周末折腾的一个记录，一切都源于阿里云客服说我的服务器马上到期了。之前购买的阿里云的ECS，三年下来需要两千多块钱，但是平时用的多的就一个博客系统和账单接口在跑，CPU使用率仅有4%。然后无意间看到阿里的语雀团队使用函数计算大大的减少了服务器的维护成本，也避免了CPU使用率一直很低的情况。受此启发决定将我的博客转移到阿里云函数计算上面，幸运的是官方也给了wordpress搭建教程（仅仅是能用）。<br>附上官方的函数计算与传统ECS价格对比：</p><div class="table-container"><table><thead><tr><th>ITEM</th><th>成本</th><th>稳定性</th></tr></thead><tbody><tr><td>基于 VM 方案</td><td>使用 ecs.t5-lc1m1.small, 22.8元/月</td><td>服务器和数据库在同一台VM,</td></tr></tbody></table></div><span id="more"></span><p>均无主备容灾，同时该规格的主机本身性能弱<br>轻量应用服务器 | 60元/月(1vCPU 1GB 1Mbps 20GB[ssd]) | 服务器和数据库在同一台VM,<br>均无主备容灾，同时该规格的主机本身性能弱<br>函数计算 | sqlite3 版本约为 1元/月 mysql 版本大约 26元/月 | 高  </p>        <h2 id="1-概要"   >          <a href="#1-概要" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h2>      <p>本文将对部署的过程和函数计算+Wordpress的架构做一个简单的描述，如有不对请以<span class="exturl"><a class="exturl__link"   href="https://help.aliyun.com/document_detail/146729.html?source=5176.11533457&userCode=bdcxtb8v&type=copy" >官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>为准。整个文章的目录如图1所示，分为函数计算架构设计、准备工作、搭建Wordpress、配置Wordpress和支持Https五大部分。</p><p><img src="https://file.2fun.xyz/2020/07/20200722063100237.png" alt="图1. 文章目录结构"> <em>图1.<br>文章目录结构</em></p>        <h2 id="2-函数计算-Wordpress的架构设计"   >          <a href="#2-函数计算-Wordpress的架构设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-函数计算-Wordpress的架构设计" class="headerlink" title="2.函数计算+Wordpress的架构设计"></a>2.函数计算+Wordpress的架构设计</h2>      <p>在使用函数计算之前，我们先了解一下函数计算是什么，这样有助于理解每一步在干嘛。下面是阿里云官网的介绍：</p><blockquote><p>函数计算（Function Compute）是一个事件驱动的全托管 Serverless<br>计算服务。您无需管理服务器等基础设施，只需编写代码并上传。函数计算会为您准备好计算资源，并以弹性、可靠的方式运行您的代码。</p></blockquote><p>可以把函数计算理解成一个运行在容器里面的代码片段，我们只需要上传自己的代码片段，函数计算服务会自动帮我们处理运行环境和伸缩配置。但是函数计算只是用来运行一段代码的，它本身是没有上下文记录的功能的，所以官方的做法是搭配使用了阿里云的NAS服务（阿里云文件存储服务）。NAS相当于一台远程的移动硬盘，函数计算引擎可以与这块硬盘进行绑定，以实现文件操作。通过上面的介绍我们就可以看看基于函数计算的Wordpress是怎么架构的。</p><p><img src="https://file.2fun.xyz/2020/07/aa24a63302dfac74a54fbada4b273361bf5d179b.png" alt="图2.函数计算Wordpress架构"><br><em>图2. 函数计算Wordpress架构</em></p><p>如图2所示，客户端的请求会发送到函数计算服务器的PHP运行环境，该环境与NAS进行了绑定，所以我们的请求可以直接操作NAS里面的Wordpress文件。这里如果需要用到数据库的话，就会连接RDS（云数据库服务）进行数据的增删改查。由于所有的函数执行的时候都是对同一个NAS和RDS进行的操作，最后的效果就像是在同一台服务器上面进行的操作一样。<br><strong>重点：Wordpress的源文件是存放在NAS上面的，函数计算仅仅是提供了一个入口，数据库在RDS上面，通过远程连接的方式进行访问。</strong></p>        <h2 id="3-流程"   >          <a href="#3-流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-流程" class="headerlink" title="3.流程"></a>3.流程</h2>      <p>创建Wordpress博客系统一共需要4个步骤，如图3所示，分别是准备阶段、创建Wordpress、配置Wordpress和支持Https，如果不想支持Https的话，那第四步可以省略。</p><p><img src="https://file.2fun.xyz/2020/07/%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97+wordpress%E6%B5%81%E7%A8%8B2.png" alt="图3. 创建wordpress的流程"><br><em>图3. 创建wordpress的流程</em></p>        <h2 id="4-准备阶段"   >          <a href="#4-准备阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-准备阶段" class="headerlink" title="4.准备阶段"></a>4.准备阶段</h2>              <h3 id="4-1购买域名"   >          <a href="#4-1购买域名" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1购买域名" class="headerlink" title="4.1购买域名"></a>4.1购买域名</h3>      <p>一个完整的个人博客需要有一个独立的域名，所以在开发之前需要申请一个个人域名，可以直接在<span class="exturl"><a class="exturl__link"   href="https://wanwang.aliyun.com/domain?source=5176.11533457&userCode=bdcxtb8v&type=copy" >万网官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>进行申请，输入想要的域名下单购买就好。</p><p><img src="https://file.2fun.xyz/2020/07/20200722031827413-1024x436.png" alt="图4. 万网购买域名"><br><em>图4. 万网购买域名</em></p>        <h3 id="4-2域名备案"   >          <a href="#4-2域名备案" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2域名备案" class="headerlink" title="4.2域名备案"></a>4.2域名备案</h3>      <p>购买域名之后就需要进行备案了，如果是在万网上面购买的域名，则可以直接使用阿里云的<span class="exturl"><a class="exturl__link"   href="https://www.aliyun.com/activity/beian/gift?source=5176.11533457&userCode=bdcxtb8v&type=copy" >备案服务</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>进行备案。在发起备案申请之后需要等待阿里云寄送一张幕布过来，收到幕布之后站在幕布前面手持生份证进行拍照提交审核就可以了，整个过程可能需要两周。</p>        <h3 id="4-3开通函数计算服务"   >          <a href="#4-3开通函数计算服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-3开通函数计算服务" class="headerlink" title="4.3开通函数计算服务"></a>4.3开通函数计算服务</h3>      <p>在阿里云<span class="exturl"><a class="exturl__link"   href="https://www.aliyun.com/product/fc?source=5176.11533457&userCode=bdcxtb8v&type=copy" >开通函数计算服务</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，选择<a href="https://www.aliyun.com/product/fc?source=5176.11533457&userCode=bdcxtb8v&type=copy"><br><strong>免费开通</strong></a>，这样就是按量付费，函数计算每月有100万次免费额度，基本上够我们使用了。</p><p><img src="https://file.2fun.xyz/2020/07/20200722032110237.png" alt="图5. 免费开通函数计算"> <em>图5.<br>免费开通函数计算</em></p>        <h3 id="4-5开通NAS服务"   >          <a href="#4-5开通NAS服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-5开通NAS服务" class="headerlink" title="4.5开通NAS服务"></a>4.5开通NAS服务</h3>      <p>在阿里云<span class="exturl"><a class="exturl__link"   href="https://www.aliyun.com/product/nas?source=5176.11533457&userCode=bdcxtb8v&type=copy" >开通使用文件存储NAS服务</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>即可。</p><p><img src="https://file.2fun.xyz/2020/07/20200722032358299.png"> <em>图6. 开通NAS服务</em></p>        <h3 id="4-6开通RDS服务"   >          <a href="#4-6开通RDS服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-6开通RDS服务" class="headerlink" title="4.6开通RDS服务"></a>4.6开通RDS服务</h3>      <p>另外我们还需要为博客创建RDS数据库，进入阿里云，开通<a href="https://www.aliyun.com/product/rds/mysql?source=5176.11533457&userCode=bdcxtb8v&type=copy">RDS-<br>MySQL版</a>，我购买的时候有新客优惠，一年仅需54元，如果没有优惠的话推荐购买3年及以上，这样更划算。</p><p><img src="https://file.2fun.xyz/2020/07/20200722032501994.png" alt="图7. RDS MySQL服务"> <em>图7.<br>RDS MySQL服务</em></p>        <h2 id="5-创建Wordpress"   >          <a href="#5-创建Wordpress" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-创建Wordpress" class="headerlink" title="5.创建Wordpress"></a>5.创建Wordpress</h2>      <p>准备工作完成之后我们就可以开发创建Wordpress了，首先需要下载函数计算的工具fun，并clone fc-wordpress代码到本地。</p>        <h3 id="5-1下载fun工具"   >          <a href="#5-1下载fun工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-1下载fun工具" class="headerlink" title="5.1下载fun工具"></a>5.1下载fun工具</h3>      <p>fun工具提供了多种方式安装，详细信息请查看[官方文档](<span class="exturl"><a class="exturl__link"   href="https://github.com/alibaba/funcraft/blob/master/docs/usage/installation-" >https://github.com/alibaba/funcraft/blob/master/docs/usage/installation-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>zh.md?spm=a2c6h.12873639.0.0.7b8427b4YkbbwW&amp;file=installation-zh.md)。</p>        <h3 id="5-2git-clone-fc-wordpress"   >          <a href="#5-2git-clone-fc-wordpress" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2git-clone-fc-wordpress" class="headerlink" title="5.2git clone fc-wordpress"></a>5.2git clone fc-wordpress</h3>      <p>将fc-wordpress到源码下载到本地。</p><pre><code>git clone https://github.com/awesome-fc/fc-wordpress.git</code></pre>        <h3 id="5-3将Wordpress上传到NAS"   >          <a href="#5-3将Wordpress上传到NAS" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-3将Wordpress上传到NAS" class="headerlink" title="5.3将Wordpress上传到NAS"></a>5.3将Wordpress上传到NAS</h3>      <p><strong>5.3.1初始化NAS</strong> 这里我使用的是MySQL数据库，所以首先cd进入<code>fc-wp-mysql</code>文件夹(<br><strong>强烈建议打开显示隐藏文件的功能，这样更容易理解步骤</strong> )，执行以下命令：</p><pre><code>fun nas initfun nas info</code></pre><blockquote><p><code>fun nas init</code>: 初始化 NAS, 基于您的 .env 中的信息获取(已有满足条件的nas)或创建一个同region可用的nas<br>如果你没有修改 templata.yml 中的配置 service名字， 那么则可以进入下一步； 如果有修改， 会在当前目录生成新的目录<br>.fun/nas/auto-default/{serviceName} (<code>fun nas info</code> 可以列出新的目录), 将默认目录下的<br>.fun/nas/auto-default/fc-wp-mysql/wordpress 的wordpress目录拷贝到 .fun/nas/auto-<br>default/{serviceName} 下， 同时可以删除目录 .fun/nas/auto-default/fc-wp-<br>mysql/wordpress</p></blockquote><p><strong>5.3.2上传到NAS</strong> 执行如下命令将本地的Wordpress文件上传到NAS：</p><pre><code>fun nas syncfun nas ls nas:///mnt/auto/</code></pre><blockquote><p><code>fun nas sync</code>: 将本地 NAS 中的内容（.fun/nas/auto-default/fc-wp-mysql）上传到 NAS 中的<br>fc-wp-mysql 目录 <code>fun nas ls nas:///mnt/auto/</code>: 查看我们是否已经正确将文件上传到了NAS</p></blockquote>        <h3 id="5-4配置域名信息"   >          <a href="#5-4配置域名信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-4配置域名信息" class="headerlink" title="5.4配置域名信息"></a>5.4配置域名信息</h3>      <p>修改<code> index.php</code> 中的<code>$host</code>中的值，<code> $host</code> 修改为自己的域名， 修改 <code>template.yml </code>中<br><code>DomainName: Auto </code>, Auto 修改成自己的域名。 修改 <code>template.yml </code>LogConfig 中的 Project,<br>任意取一个不会重复的名字即可, 有两处地方需要更改，如图8所示。</p><p><img src="https://file.2fun.xyz/2020/07/0cbbe03eebd58f5e6696e3214c9750083f8013ea.png" alt="图8.修改template.yml"><br><em>图8. 修改template.yml</em></p>        <h3 id="5-5发布函数"   >          <a href="#5-5发布函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-5发布函数" class="headerlink" title="5.5发布函数"></a>5.5发布函数</h3>      <p>执行<code>fun deploy</code>，完成最终的部署。 登录控制台 <span class="exturl"><a class="exturl__link"   href="https://fc.console.aliyun.com/" >https://fc.console.aliyun.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，可以看到service 和<br>函数已经创建成功， 并且 service 也已经正确配置。</p><ol start="3"><li>通过浏览器自己的域名，即可看到Wordpress页面。</li></ol>        <h2 id="6-配置Wordpress"   >          <a href="#6-配置Wordpress" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-配置Wordpress" class="headerlink" title="6.配置Wordpress"></a>6.配置Wordpress</h2>      <p>完成Wordpress安装之后我们就可以进行博客具体配置了，首次打开会提示选择一个语言，在底部有一个“简体中文”。选择语言之后就进入正式配置阶段，如图9所示。</p><p>![图9. Wordpress初始页面](<span class="exturl"><a class="exturl__link"   href="https://file.2fun.xyz/2020/07/generate-wp-config-" >https://file.2fun.xyz/2020/07/generate-wp-config-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>file.png) <em>图9. Wordpress初始页面</em></p>        <h3 id="6-1创建RDS数据库"   >          <a href="#6-1创建RDS数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-1创建RDS数据库" class="headerlink" title="6.1创建RDS数据库"></a>6.1创建RDS数据库</h3>      <p>如图9所示，我们需要提供一个数据库，这时可以去RDS<br><span class="exturl"><a class="exturl__link"   href="https://rdsnext.console.aliyun.com/" >MYSQL控制台</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>创建一个数据库。</p><p><strong>6.1.1创建数据库账户</strong> 首先我们创建一个普通账号，用来管理博客的数据库。</p><p><img src="https://file.2fun.xyz/2020/07/WX20200721-121201@2x.png" alt="图10. 创建普通账户"> <em>图10.<br>创建普通账户</em></p><p><strong>6.1.2创建数据库</strong> 然后创建一个数据库，并将权限授予刚才的账户。</p><p><img src="https://file.2fun.xyz/2020/07/WX20200721-121525@2x.png" alt="图11. 创建数据库"> <em>图11.<br>创建数据库</em></p><p><strong>6.1.3设置白名单</strong><br>这时我们的数据库还不能背外面访问，需要先设置白名单，为了简单，我这里是直接添加的允许<code>0.0.0.0/0</code>访问，如果想要更加精细的权限控制，可以查看<span class="exturl"><a class="exturl__link"   href="https://help.aliyun.com/document_detail/100272.html?source=5176.11533457&userCode=bdcxtb8v&type=copy" >官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p><img src="https://file.2fun.xyz/2020/07/WX20200721-122239@2x.png" alt="图12. 设置白名单"> <em>图12.<br>设置白名单</em></p><p><strong>6.1.4获取外网地址</strong> 设置白名单之后就可以申请外网地址了。</p><p><img src="https://file.2fun.xyz/2020/07/WX20200721-130217@2x.png" alt="图13. 获取RDS外网地址"><br><em>图13. 获取RDS外网地址</em></p>        <h3 id="6-2Wordpress绑定数据库"   >          <a href="#6-2Wordpress绑定数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2Wordpress绑定数据库" class="headerlink" title="6.2Wordpress绑定数据库"></a>6.2Wordpress绑定数据库</h3>      <p>数据库创建成功之后就可以配置Wordpress的数据库信息了，需要注意的地方是 <strong>数据库主机要填写RDS的外网地址，而不是locallhost</strong></p><p><img src="https://file.2fun.xyz/2020/07/WX20200721-130652@2x.png" alt="图14. Wordpress绑定数据库"><br><em>图14. Wordpress绑定数据库</em></p>        <h3 id="6-3创建账户和网站信息"   >          <a href="#6-3创建账户和网站信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-3创建账户和网站信息" class="headerlink" title="6.3创建账户和网站信息"></a>6.3创建账户和网站信息</h3>      <p>配置好数据库之后就可以进入网站信息配置页面了，如图15所示，需要填写网站标题、用户名、密码和邮箱等信息。</p><p><img src="https://file.2fun.xyz/2020/07/20200722060955108.png" alt="图15. 创建账户和网站信息"> <em>图15.<br>创建账户和网站信息</em></p>        <h3 id="6-4网站个性化（可选）"   >          <a href="#6-4网站个性化（可选）" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-4网站个性化（可选）" class="headerlink" title="6.4网站个性化（可选）"></a>6.4网站个性化（可选）</h3>      <p>经过上面的步骤，我们的网站就配置完成了，但是这时的网站还十分简陋，外观也不能达到我们的需求，所以我们需要对它换个皮。我尝试在Wordpress的后台直接安装主题，但是每一次都是安装失败，最后我找到了一种安装主题的方式：直接把主题文件上传到NAS里面。</p><p><strong>6.4.1下载主题</strong> 首先去<span class="exturl"><a class="exturl__link"   href="https://wordpress.org/themes" >https://wordpress.org/themes</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>下载喜欢的主题，然后将主题的文件夹拷贝到本地<code>fc-wordpress地址/fc-web- mysql/.fun/nas/auto-default/fc-wp-mysql/wordpress/wp- content/themes</code>文件夹下面，如图16所示，writers文件夹就是我下载的主题。</p><p><img src="https://file.2fun.xyz/2020/07/20200722033434130.png" alt="下载主题"> <em>图16. 下载主题</em></p><p><strong>6.4.2同步NAS</strong> 将主题复制到wordpress的主题文件夹之后，我们需要把本地的wordpress信息与NAS进行同步，执行<code>fun nas sync</code>即可将本地文件上传到NAS上面。这时在我们的Wordpress后台就可以看到新安装的主题了。</p>        <h2 id="7支持Https（可选）"   >          <a href="#7支持Https（可选）" class="heading-link"><i class="fas fa-link"></i></a><a href="#7支持Https（可选）" class="headerlink" title="7支持Https（可选）"></a>7支持Https（可选）</h2>      <p>一切就这么顺利的完成了，直到我用Safari浏览器访问<a href="www.bearever.cn">www.bearever.cn</a>时，我感觉自己遭受了暴击！浏览效果如图17所示。</p><p><img src="https://file.2fun.xyz/2020/07/20200722032808721.png" alt="页面样式丢失"> <em>图17. 页面样式丢失</em></p><p>导致这个的原因是我们的博客现在还不支持Https，百度了一下怎么解决都说是需要改<code>wp- config.php</code>文件，这个文件是配置的时候创建在NAS上面的。问题难就难在这里，我没有办法下载NAS上面的文件进行修改，fun工具目前只支持列出文件目录，使用本地文件替换NAS文件，但是没有下载文件的功能。。。就在我一筹莫展的时候，发现了一个叫[really-<br>simple-ssl](<span class="exturl"><a class="exturl__link"   href="https://wordpress.org/plugins/really-simple-" >https://wordpress.org/plugins/really-simple-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>ssl/)的插件，官方描述说可以让你的网站轻松支持Https，带着试一试的态度下载安装，发现真的可以！</p><p>如果你要让你的博客支持Https的话，需要下载Https证书，然后更新函数计算域名信息，最后安装<a href="https://wordpress.org/plugins/really-simple-ssl/">really-simple-<br>ssl</a>插件就可以了。</p>        <h3 id="7-1下载Https证书"   >          <a href="#7-1下载Https证书" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1下载Https证书" class="headerlink" title="7.1下载Https证书"></a>7.1下载Https证书</h3>      <p>下载证书之前我们需要先去阿里云购买一个证书，然后下载下来。 <strong>7.1.1申请Https证书</strong><br>在阿里云SSL平台购买一个证书，选择免费版的就可以了，如图18所示。</p><p><img src="https://file.2fun.xyz/2020/07/20200722060809233.png" alt="图18. 申请免费版Https证书"><br><em>图18. 申请免费版Https证书</em></p><p><strong>7.1.2下载证书</strong> 证书申请成功之后将证书下载到本地，下载的时候选择Nginx版本的。</p>        <h3 id="7-2更新函数计算域名信息"   >          <a href="#7-2更新函数计算域名信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2更新函数计算域名信息" class="headerlink" title="7.2更新函数计算域名信息"></a>7.2更新函数计算域名信息</h3>      <p>在<span class="exturl"><a class="exturl__link"   href="https://fc.console.aliyun.com/fc/overview" >函数计算控制台</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>选择“自定义域名”，可以看到我们自己的域名信息，点击“修改”将支持协议改为“Http、Https”，如图19所示。其中.pem和.key文件的内容可以直接用记事本打开查看。</p><p><img src="https://file.2fun.xyz/2020/07/20200722060852936.png" alt="图19. 配置Https证书信息"> <em>图19.<br>配置Https证书信息</em></p>        <h3 id="7-3安装really-simple-ssl插件"   >          <a href="#7-3安装really-simple-ssl插件" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3安装really-simple-ssl插件" class="headerlink" title="7.3安装really-simple-ssl插件"></a>7.3安装really-simple-ssl插件</h3>      <p>去[really-simple-ssl主页](<span class="exturl"><a class="exturl__link"   href="https://wordpress.org/plugins/really-simple-" >https://wordpress.org/plugins/really-simple-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>ssl/)下载插件，然后将插件文件夹复制到<code>fc-wordpress地址/fc-web-mysql/.fun/nas/auto-default/fc-wp- mysql/wordpress/wp-content/plugins</code>文件夹下面。执行<code>fun nas sync</code>将本地的本地的插件同步到NAS上面，最后打开Wordpress后台开启really-simple-ssl即可。</p>        <h2 id="8-Enjoy"   >          <a href="#8-Enjoy" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-Enjoy" class="headerlink" title="8.Enjoy"></a>8.Enjoy</h2>      <p>好了，一个Wordpress博客就这么部署完毕了，你已经迈出了成功的第一步，接下来就是不断的丰富你的博客，为她填充智慧与思想！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里外包半年记</title>
      <link href="2020/06/18/%E9%98%BF%E9%87%8C%E5%A4%96%E5%8C%85%E5%8D%8A%E5%B9%B4%E8%AE%B0/"/>
      <url>2020/06/18/%E9%98%BF%E9%87%8C%E5%A4%96%E5%8C%85%E5%8D%8A%E5%B9%B4%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/2020/06/IMG_20191126_191837R.jpg" alt="阿里巴巴西溪园区">2019年11月阴差阳错进入了阿里巴巴视频基础实验室做外包，至今已有半年，收获挺多。本文即是对个人收获的记录，主要分为技术与工作方式两个方面。</p>        <h2 id="技术"   >          <a href="#技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#技术" class="headerlink" title="技术"></a>技术</h2>      <p>如果说要总结自己这段时间技术方面具体的收获的话，那就主要有Android、C/C++和Python三个方面：对Android平台的视频编解码有了一定了解，可以快速的进行视频数据采集和编码；C/C++使用更加熟练，终于不再担心被指针气哭；Python使用也更加熟练了，能够使用Python快速的开发一些工具脚本及跨平台的GUI程序开发。</p>        <h3 id="Android"   >          <a href="#Android" class="heading-link"><i class="fas fa-link"></i></a><a href="#Android" class="headerlink" title="Android"></a>Android</h3>      <p>由于我是在视频基础实验室做外包，所以工作内容都是和视频相关的。入职之后做的第一个项目就是一个视频算法可视化Android软件开发，应用需要调用摄像头获取实时数据，然后使用JNI技术对流进行处理，处理之后的结果需要及时的显示在屏幕上面。处理摄像头数据的时候需要注意视频的帧率，因为CPU处理算法的时间比较长，所以需要判断手机硬件支持的帧率，设置合适的值，甚至是使用人为丢弃部分帧减少计算量。除了帧率还需要考虑到视频的颜色空间，常见的有I420、NV12等，需要根据算法支持情况进行选择或则转换。摄像头读取到的是裸流数据，如果要保存到本地，可能还需要使用编码器进行编码，主要有MediacCodec和FFmpeg两种方案。MediaCodec是Android<br>4.1加入的API，其通过调用手机硬件实现快速的视频编解码，效率非常高，但是不同的手机设备支持的编解码算法不一样，需要根据具体机型判断做优化处理。FFmpeg是一个十分优秀的视频处理库，使用软件算法实现视频的编解码，所以支持的格式十分多，不过效率不及MeidaCodec，需要根据实际情况判断使用。另外视频的绘制也是一个比较复杂的地方，常见的方案有通过OpenGLES或者自己利用Canvas直接绘制。使用OpenGLES渲染效率很高，不过由于项目赶时间，之前对OpenGLES也不熟，所以没有用这个方案。我使用的是利用SurfaceView控件，获取其Canvas对象，然后将视频数据转成Bitmap的方式，这种方式优点就是实现简单，缺点就是占用内存大，性能差。</p><span id="more"></span>        <h3 id="C-C"   >          <a href="#C-C" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3>      <p>在做视频算法可视化软件开发的时候，因为算法都是C语言编译的so库，所以会涉及到C/C++的编程，在这个项目中C/C++的东西还算比较少，多是调用接口传递数据和转换格式的操作。该项目结束之后做了纯C/C++的Linux应用开发，第一次搞Linux遇到很多问题，对C/C++语言的不熟悉也导致项目进度缓慢，那段时间自己也非常焦虑。不过马老板有句鸡汤说了：“当你觉得不舒服的时候，就是你在成长的时候。”，确实是这样，当时虽然很难受，但是让我对Linux环境的使用和C/C++编程更加熟悉了。经过这些事情让我明白了C/C++是很重要的一门技术，无论是否是Android开发都会涉及到，为了弥补自己C/C++的不足，现在也一直在看《C<br>++ Primer Plus》这本书，对于C++初学者，这本书真的写的很好（除去很多地方翻译的很蹩脚），推荐感兴趣的人去看看。</p>        <h3 id="Python"   >          <a href="#Python" class="heading-link"><i class="fas fa-link"></i></a><a href="#Python" class="headerlink" title="Python"></a>Python</h3>      <p>视频算法开发中的很多工作都可以使用Python脚本自动完成，例如视频质量客观检查，通过对比原始视频与编码之后的视频像素的匹配度即可告诉开发者算法的质量。另外，对于视频主观质量检查则需要肉眼观看视频对比，考虑到实验室成员使用的电脑系统很多，有Windows、Mac和Ubuntu，所以需要一个跨平台的解决方案。我选择的方案是使用Qt的Python版本进行开发，Qt是一个很强大的跨平台框架，使用C++编写，但是提供了Python接口，安装一个PyQt5即可进行开发了。另外如果需要对Python的脚本编译成exe可执行文件，可以使用pyinstaller库，然后执行<code>pyinstaller xx.py --onefile</code>就可以了。因为Python是脚本语言，所以第一次写的时候总是一溜从上到下写过去，很少定义函数，但是Python3是有Class的，可以实现面向对象的设计，对于大型的程序还是建议用面向对象的思路编程，可以提高代码的可读性和复用性。</p>        <h2 id="习惯"   >          <a href="#习惯" class="heading-link"><i class="fas fa-link"></i></a><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2>      <p>回顾自己的这半年，技术部分固然有了很多收获，除此之外，也学到了很多工作习惯的东西。 ### 重视文档</p><p>早在进入外包之前，我对于技术文档就非常重视，十分关注企业内部知识的传播效率，曾主动搭建了公司内部的博客平台，分享知识。与善老师（我在阿里的主管）共事之后发现他也是一名对文档有着极致追求的人，对于文档的要求，比我更加严格。他对文字中的标点符号都很在意，如果需要配一个图片都话，对于图片的排列位置，图片元素的配色也很有讲究，这个是我需要学习的地方。</p>        <h3 id="重视注释"   >          <a href="#重视注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#重视注释" class="headerlink" title="重视注释"></a>重视注释</h3>      <p>代码中的注释就如同是给程序员的文档，需要格外重视，切不可因为一时懒惰而忽略了。注释可以提高团队开发时的效率，尤其是现在疫情环境下大家经常会远程办公。很多人不写注释的原因是自己觉得这个地方很简单，没必要。可一旦你离职之后，这块代码归别人负责，那他就不一定可以理解你的思维了。</p>        <h3 id="不要害怕挑战"   >          <a href="#不要害怕挑战" class="heading-link"><i class="fas fa-link"></i></a><a href="#不要害怕挑战" class="headerlink" title="不要害怕挑战"></a>不要害怕挑战</h3>      <p>刚进实验室工作的时候，经常会遇到一些让人很头疼的任务，例如Linux<br>程序的开发，由于自己对Linux和C/C++不熟，导致项目进度缓慢，从而产生了恐惧心理，工作也不积极。但是害怕是解决不了问题的，逃避问题只会让自己更加害怕。在之后的工作中，也经常遇到这种从来没有做过的任务，不过慢慢的就不再害怕了，无非是多花点时间研究一下。当然这个也是有度的，像我就知道自己搞不定深度学习模型的训练，这里面涉及的基础知识太多了，不是几天可以突破的。</p>        <h2 id="End"   >          <a href="#End" class="heading-link"><i class="fas fa-link"></i></a><a href="#End" class="headerlink" title="End"></a>End</h2>      <p>单老师曾经说过一句话让我印象很深，他说：</p><blockquote><p>没有广度的深度是烟囱，没有深度的广度是浮萍。</p></blockquote><p>在技术领域，我涉及了很多，像上文提到的Android、C/C++和Python，自己现在可能连浮萍都算不上。无论如何做技术的多学一点肯定是没错的，只不过需要取舍，例如现在我会更加偏重于C/C++方面的学习，如果一个工作在不紧急的情况下，我会优先考虑使用C/C++。以前的话我可能更加注重实用自己熟悉的技术框架去完成，这样就会让自己在一个领域跳不出来，甚至会有固步自封的可能性。半年的时间就这样过去了，虽然还在阿里做外包，但始终觉得不是个事儿，还是希望自己可以成为一名大厂的正式员工。今年下半年最大的目标就是能进个大厂了，那么，奋斗吧，骚年！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>声网2020春季RTC编程挑战赛总结</title>
      <link href="2020/05/17/%E5%A3%B0%E7%BD%912020%E6%98%A5%E5%AD%A3RTC%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>2020/05/17/%E5%A3%B0%E7%BD%912020%E6%98%A5%E5%AD%A3RTC%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[        <h2 id="项目简介"   >          <a href="#项目简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2>              <h3 id="概述"   >          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h3>      <p>2020年3月参加了声网RTC春季编程挑战赛，为此开发了一款Android视频聊天应用。该应用用于陌生人视频聊天，通过动态马赛克特效、话题匹配等功能减少视频聊天的紧张感和为用户提供聊天话题避免尴尬。</p>        <h3 id="效果图"   >          <a href="#效果图" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3>      <p><img src="https://file.2fun.xyz/2020/05/20200722035847174.jpg"> |<br><img src="https://file.2fun.xyz/2020/07/20200722033155117.png"> |</p><span id="more"></span><p><img src="https://file.2fun.xyz/2020/05/20200722035857290.png"><br>—|—|—<br>初始状态 | 匹配中 | 聊天  </p>        <h2 id="主要功能"   >          <a href="#主要功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2>      <p>该应用分为匹配和聊天两个页面，匹配界面为增加交互体验设计了一个下落和上浮的动画；聊天页面会将视频进行动态马赛克处理，马赛克的级别取决于好感度。同时话题机制可以为聊天双方增加话题避免聊天时的尴尬。</p>        <h3 id="匹配页面"   >          <a href="#匹配页面" class="heading-link"><i class="fas fa-link"></i></a><a href="#匹配页面" class="headerlink" title="匹配页面"></a>匹配页面</h3>      <p>匹配页面用于陌生人聊天匹配，初始化状态下面会调用用户的前置摄像头并显示在屏幕中心的圆形头像里，点击匹配按钮时，头像下落，同时陌生人的圆形头像和匹配中的loading图标一起下落。取消匹配时头像和loading图标上浮，直至移出屏幕，仅留下本人的视频头像。匹配成功则跳转进入聊天页面。<br>[video muted autoplay = autoplay<br>mp4=<span class="exturl"><a class="exturl__link"   href="https://file.2fun.xyz/2020/05/20200517match.mp4//][/video]" >https://file.2fun.xyz/2020/05/20200517match.mp4\\][/video]</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ### 聊天页面</p><p>视频聊天页面分为三个区域，分别是对方视频区，本人视频区和话题区。<br><a href="https://file.2fun.xyz/2020/05/WX20200517-173439@2x.png"><img src="https://file.2fun.xyz/2020/05/WX20200517-173439@2x-474x1024.png" alt="视频聊天的三个区域"></a></p>        <h4 id="视频区"   >          <a href="#视频区" class="heading-link"><i class="fas fa-link"></i></a><a href="#视频区" class="headerlink" title="视频区"></a>视频区</h4>      <p>无论是对方视频预览区还是本人视频预览区，都需要对画面进行动态马赛克处理，而马赛克的等级取决于聊天双方的好感度值。 - 马赛克特效<br>视频的马赛克处理原理是对YUV数据源进行处理，然后将处理后的YUV数据渲染到SurfaceView上面，关于马赛克的具体实现细节可以参考我的<a href="https://www.bearever.cn/algorithm/mosaic/">另外一篇文章</a>，这里不再赘述了。顺带提一下声网的RTCSDK很好用，对于数据采集和渲染无需过多关心，仅需要实现一个自己的特效算法即可。</p><ul><li>好感度 由于视频分为个人和对方，所以这里的好感度是有两个值的，分别是：我对TA的好感度和TA对我的好感度，前者影响本人视频区的马赛克等级，后者影响对方视频区的马赛克等级，好感度越高，马赛克等级越低，直至以真实画面展示。好感度初始值为60，每秒减1，降到0则聊天结束了。通过双击屏幕可以增加我对TA的好感度，</li></ul>        <h4 id="话题"   >          <a href="#话题" class="heading-link"><i class="fas fa-link"></i></a><a href="#话题" class="headerlink" title="话题"></a>话题</h4>      <p>陌生人聊天最担心的就是聊不起来，陷入尴尬，所以我们引入了话题机制。如果用户A与B进行匹配聊天，当A点击具体的话题之后，B的界面会显示一条通知：“对方选择了XX话题”。A与B选择一样的话题会用粉红色高亮出来。当A点击了刷新话题之后，B的话题也会刷新。在开发这个功能的时候我们小组内部也讨论了很久，主要在于直接刷新对方的话题是否会让对方体验不好。最终我们还是选择了这套方案，原因是我们的目的是让有共同话题的人聊起来，刷新话题说明没有自己感兴趣的，如果好感度降至了0仍然没有刷新到感兴趣的话题，那说明两个人本就兴趣不一致。</p><p><img src="https://file.2fun.xyz/2020/05/20200722040757444.png" alt="关于话题刷新的讨论"></p>        <h2 id="缘起"   >          <a href="#缘起" class="heading-link"><i class="fas fa-link"></i></a><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2>      <p>聊到这里了在顺带说一下为什么做这个项目吧，一开始我在鸿洋大神的公众号上面刷到了声网RTC大赛的事情，于是把链接转发给了周神问他要不要搞一搞，周神很爽快的答应了。周神是我上一家公司的主管，属于稀有等级的好领导，不过后来公司裁员。。。。。。一言难尽。</p><p><img src="https://file.2fun.xyz/2020/05/20200722041301452.jpg" alt="约周神"></p><p>有了技术支撑之后，还需要一个做UI设计的同学，于是我把链接转发给了朝怡。我们合作过很多次了，她是一个很有才华的同学，这次的产品设计和UI设计都靠她完成的。周神还夸她是一个宝藏女孩！</p><p><img src="https://file.2fun.xyz/2020/05/20200722041257903.jpg" alt="周神还夸她是一个宝藏女孩！"></p>        <h3 id="Just-for-fun！"   >          <a href="#Just-for-fun！" class="heading-link"><i class="fas fa-link"></i></a><a href="#Just-for-fun！" class="headerlink" title="Just for fun！"></a>Just for fun！</h3>      <p>有了大神助力，一切就顺利多了，在选题方面，我准备了两个方向，一个是视频面试题材，另外一个是8bit视频聊天。前者在目前的疫情期间可以有一定的实际作用，后者则是因为本人喜欢像素风的游戏，觉得这个很好玩。最后大家选择了8bit视频这个题材，因为参加比赛的初衷没有想过会得奖，所以就怎么好玩怎么弄了。</p><p><img src="https://file.2fun.xyz/2020/05/20200722041558641.jpg"></p>        <h2 id="项目开源"   >          <a href="#项目开源" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目开源" class="headerlink" title="项目开源"></a>项目开源</h2>      <p>整个项目使用到了声网的视频聊天SDK和实时消息SDK，用于进行视频聊天和话题信息同步等。目前已经开源，具体地址见<br>[Github:likemosaic](<span class="exturl"><a class="exturl__link"   href="https://github.com/AgoraIO-Community/RTC-" >https://github.com/AgoraIO-Community/RTC-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Hackathon/tree/master/SDKChallengeProject/likemosaic) 。有兴趣的朋友也可以扫码下载APK进行体验。<br><a href="https://file.2fun.xyz/2020/05/Unknown.png"><img src="https://file.2fun.xyz/2020/05/Unknown.png"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AIDL使用</title>
      <link href="2020/04/23/AIDL%E4%BD%BF%E7%94%A8/"/>
      <url>2020/04/23/AIDL%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Android的IPC（跨进程通信）方式有Binder、AIDL、Messenger、文件共享等，AIDL是最常用的方案。但是由于项目中用的不多，所以不熟悉，特意将AIDL的使用过程记录一下，供日后查看。</p>        <h2 id="AIDL接口支持的格式"   >          <a href="#AIDL接口支持的格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#AIDL接口支持的格式" class="headerlink" title="AIDL接口支持的格式"></a>AIDL接口支持的格式</h2>      <p><strong>AIDL的语法与Java接口的语法是一致的，但是不支持定义接口常量</strong> ，并且对于数据的类型是有要求的，仅支持以下几种格式：</p><ul><li>Java的原语类型：<code>int</code>、<code>long</code>、<code>char</code>、<code>bolean</code>等。</li><li><code>String</code></li><li><code>CharSequence</code></li><li>实现<code>Parcelable</code>接口的数据类型</li></ul><span id="more"></span><ul><li><code>List</code> List 中的所有元素必须是以上列表中支持的数据类型，或者您所声明的由 AIDL 生成的其他接口或Parcelable 类型。您可选择将 List 用作“泛型”类（例如，List）。尽管生成的方法旨在使用 List 接口，但另一方实际接收的具体类始终是 ArrayList。</li><li><code>Map</code> Map 中的所有元素必须是以上列表中支持的数据类型，或者您所声明的由 AIDL 生成的其他接口或 Parcelable 类型。不支持泛型 Map（如 Map&lt;String,Integer&gt; 形式的 Map）。尽管生成的方法旨在使用 Map 接口，但另一方实际接收的具体类始终是 HashMap。</li></ul>        <h2 id="AIDL使用方法"   >          <a href="#AIDL使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#AIDL使用方法" class="headerlink" title="AIDL使用方法"></a>AIDL使用方法</h2>      <p>AIDL实现需要3步，分别是：</p><ol><li>创建 .aidl 文件</li><li>创建Service并实现aidl生成的Sub类</li><li>客户端bindService调用Service</li></ol><p>下面以书店的例子举例说明这三个步骤。</p><blockquote><p>实现一个书店的aidl，完成添加图书与查询图书信息的功能。</p></blockquote>        <h3 id="1-创建-aidl文件"   >          <a href="#1-创建-aidl文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-创建-aidl文件" class="headerlink" title="1.创建.aidl文件"></a>1.创建.aidl文件</h3>      <p>使用AndroidStudio可以很方便的创建AIDL文件，将鼠标放在文件夹目录上面，然后右键选择创建AIDL,如下图所示。</p><p><img src="https://file.2fun.xyz/%7B701997D5-CA32-44C3-ADD6-C0391380997A%7D_20200422184556.jpg"></p><p><strong>IBookManager.aidl</strong></p><p>根据我们的需求，需要设计两个方法，分别是<code>void addBook(Book book)</code>和<code>Book getBook(String name)</code>，下面让我们创建一个<code>IBookManager.aidl</code>的文件，如下：</p><pre><code>//IBookManager.aidlpackage cn.bearever.android.book;interface IBookManager &#123;    void addBook(in Book book);    Book getBook(String name);&#125;</code></pre><p><strong>注意</strong> 在aidl里面，非原语参数需要用<code>in</code>、<code>out</code>或者<code>inout</code>标记,例如上面的<code>void addBook (in Book book)</code>。</p><p><strong>Book.aidl</strong></p><p>如果只是这样的话，编译会失败，提示Book找不到:</p><pre><code>cn.bearever.android.book.Book: couldn&#39;t find import for class cn.bearever.android.book.Book</code></pre><p>接着我们在<code>IBookManager.aidl</code>的文件夹下创建<code>Book.aidl</code>文件，如下：</p><pre><code>// Book.aidlpackage cn.bearever.android.book;parcelable Book;</code></pre><p>这里的关键在于<code>parcelable Book;</code>，它指向了一个实现了Parcelable的Book类，所以我们还需要实现一个Book.java的类。需要注意的是<br><strong>Book.java的代码位置不能放在aidl文件夹，需要放在java代码的文件夹下</strong><br>，例如<code>src\main\java\cn\bearever\android\book\Book.java</code>。</p><p><strong>Book.java</strong></p><pre><code>//Book.javapublic class Book implements Parcelable &#123;    public String name;    public int money;    public Book() &#123;    &#125;    public Book(String name, int money) &#123;        this.name = name;        this.money = money;    &#125;    protected Book(Parcel in) &#123;        name = in.readString();        money = in.readInt();    &#125;    @Override    public void writeToParcel(Parcel dest, int flags) &#123;        dest.writeString(name);        dest.writeInt(money);    &#125;    @Override    public int describeContents() &#123;        return 0;    &#125;    public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() &#123;        @Override        public Book createFromParcel(Parcel in) &#123;            return new Book(in);        &#125;        @Override        public Book[] newArray(int size) &#123;            return new Book[size];        &#125;    &#125;;    @NonNull    @Override    public String toString() &#123;        return &quot;书名：&quot; + name + &quot;,价格：&quot; + money;    &#125;&#125;</code></pre><p><strong>注意</strong><br>以为这样就可以了？还没有的！前面我们虽然使用<code>Book.aidl</code>指定了需要用到<code>Book.java</code>类，但是这个类的具体路径还没有确定，需要在<code>IBookManager.aidl</code>里面通过<code>import</code>指定，例如：</p><pre><code>// IBookManager.aidlpackage cn.bearever.android.book;import cn.bearever.android.book.Book; //这一句话就是指定Book的路径！！！！interface IBookManager &#123;    void addBook(in Book book);    Book getBook(String name);&#125;</code></pre>        <h3 id="创建Service并实现aidl生成的Sub类"   >          <a href="#创建Service并实现aidl生成的Sub类" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建Service并实现aidl生成的Sub类" class="headerlink" title="创建Service并实现aidl生成的Sub类"></a>创建Service并实现aidl生成的Sub类</h3>      <p>实现了<code>aidl</code>接口之后AndroidStudio会自动生成一个与aidl同名的java文件,具体生成的代码就不贴上来了，下面我们来实现aidl的接口定义的功能。在java代码文件夹里面创建一个<code>BookService.java</code>的Service，并实现将<code>IBookManager.Sub</code>的实现作为<code>Binder</code>返回。</p><p><strong>BookService.java</strong></p><pre><code>//BookService.javapublic class BookService extends Service &#123;    private BookBinder mBinder;    private HashMap&lt;String, Book&gt; mBookMap;    @Override    public void onCreate() &#123;        super.onCreate();        mBinder = new BookBinder();        mBookMap = new HashMap&lt;&gt;();    &#125;    @Nullable    @Override    public IBinder onBind(Intent intent) &#123;        return mBinder;    &#125;    public class BookBinder extends IBookManager.Stub &#123;        @Override        public void addBook(Book book) throws RemoteException &#123;            if (book == null) &#123;                return;            &#125;            mBookMap.put(book.name, book);        &#125;        @Override        public Book getBook(String name) throws RemoteException &#123;            return mBookMap.get(name);        &#125;    &#125;&#125;</code></pre><p>Service实现之后我们就可以将其注册到AndroidManifest.xml里面了，并为其设置运行的进程，例如：</p><pre><code>&lt;application&gt;    &lt;service        android:name=&quot;.BookService&quot;        android:process=&quot;:remote&quot; /&gt;&lt;/application&gt;</code></pre><p><strong>注意</strong> 接口的访问是多线程进行的，一定要注意线程安全问题！HashMap是线程不安全的，需要根据业务场景使用线程安全的方案。</p><p>前面两个步骤创建的aidl完整代码文件结构如下：</p><p><img src="https://file.2fun.xyz/2E87DE51-6508-47A6-A170-1622CFA772AB_20200423110036.jpg"></p>        <h3 id="3-客户端bindService调用Service"   >          <a href="#3-客户端bindService调用Service" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-客户端bindService调用Service" class="headerlink" title="3.客户端bindService调用Service"></a>3.客户端bindService调用Service</h3>      <p>下面我们在主进程里面来访问remote进程的数据，创建一个<code>MainActivity.java</code>，绑定BookService，通过其返回的service转成IBookManager的接口，然后调用其方法试试。</p><pre><code>//MainActivitypublic class MainActivity extends AppCompatActivity &#123;    private static final String TAG = &quot;MainActivity&quot;;    private IBookManager mBookManager;    private ServiceConnection connection = new ServiceConnection() &#123;        @Override        public void onServiceConnected(ComponentName name, IBinder service) &#123;            mBookManager = IBookManager.Stub.asInterface(service); //注意这里是通过Sub.asInterface转成接口的            try &#123;                //添加图书                mBookManager.addBook(new Book(&quot;哈利波特&quot;, 100));                Log.d(TAG, &quot;添加一本图书&quot;);                //获取图书信息                Book book = mBookManager.getBook(&quot;哈利波特&quot;);                Log.d(TAG, &quot;图书信息:&quot; + book);            &#125; catch (RemoteException e) &#123;                e.printStackTrace();            &#125;        &#125;        @Override        public void onServiceDisconnected(ComponentName name) &#123;        &#125;    &#125;;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Intent intent = new Intent();        intent.setClass(this, BookService.class);        bindService(intent, connection, BIND_AUTO_CREATE);    &#125;    @Override    protected void onDestroy() &#123;        super.onDestroy();        unbindService(connection);    &#125;&#125;</code></pre><p>运行程序打印如下：</p><pre><code>2020-04-23 11:53:04.789 10288-10288/cn.bearever.android.test D/MainActivity: 添加一本图书2020-04-23 11:53:04.790 10288-10288/cn.bearever.android.test D/MainActivity: 图书信息:书名：哈利波特,价格：100</code></pre><p>再看一下运行的进程数量，确实是两个，说明我们的跨进程通信成功了。</p><p><img src="https://file.2fun.xyz/497C7369-87C7-4B3B-8400-E14CA20964A8_20200423115526.jpg"></p>        <h2 id="结语"   >          <a href="#结语" class="heading-link"><i class="fas fa-link"></i></a><a href="#结语" class="headerlink" title="结语"></a>结语</h2>      <p>AIDL是Android里面最常用的IPC方案，虽然对于单进程的项目使用不到，但还是要掌握的。对于Android而言，一个进程就是一个应用，跨进程通信其实也是跨应用通信的解决方案。一搬情况下我们并不希望自己的进程被别人访问，可以加入权限校验，这个部分就不展开了。对于AIDL本身需要注意的要点有：</p><ul><li>AIDL支持的数据类型及Parcelable的实现</li><li>主动import需要的类路径</li><li>方法调用是多线程环境的，要注意线程安全问题。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“万恶”的马赛克是怎么实现的呢？</title>
      <link href="2020/03/25/%E2%80%9C%E4%B8%87%E6%81%B6%E2%80%9D%E7%9A%84%E9%A9%AC%E8%B5%9B%E5%85%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F/"/>
      <url>2020/03/25/%E2%80%9C%E4%B8%87%E6%81%B6%E2%80%9D%E7%9A%84%E9%A9%AC%E8%B5%9B%E5%85%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近参加[声网的RTC开发者大赛](<span class="exturl"><a class="exturl__link"   href="https://segmentfault.com/page/rtc-" >https://segmentfault.com/page/rtc-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>hackathon-2020)开发了一个陌生人[视频聊天应用](<span class="exturl"><a class="exturl__link"   href="https://github.com/Luomingbear/RTC-" >https://github.com/Luomingbear/RTC-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Hackathon/tree/master/SDKChallengeProject/likemosaic)，为了降低聊天时的紧张感，对视频画面进行马赛克处理。此文便是对马赛克算法实现的总结。</p></blockquote><p><img src="https://file.2fun.xyz/mosaic_compare20200420.png"></p>        <h2 id="原理"   >          <a href="#原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#原理" class="headerlink" title="原理"></a>原理</h2>      <p>图片是由一个个像素点组成的，由于间距很小，便形成了图像的效果。将图片变成马赛克样式的本质就是修改像素点，使得一定范围内的像素用相同的颜色值表示。这里的“一定范围”我们暂且称之为马赛克块，马赛克块的大小也就决定了图片马赛克程度的不同。以3x3的像素点大小的马赛克块为例，原始像素点的值为<code>1...9</code>，修改之后全部为<code>n</code>,如下图所示。</p><span id="more"></span><p><img src="https://file.2fun.xyz/mosaic2020202020.jpg"></p><p>根据这个原理，我们只需要将图片分为一个一个的马赛克块，然后遍历它们，使每一个马赛克块用相同的颜色值表示即可。</p><p><img src="https://file.2fun.xyz/mosaic_line_read2020421.jpg"></p>        <h3 id="确定马赛克块坐标"   >          <a href="#确定马赛克块坐标" class="heading-link"><i class="fas fa-link"></i></a><a href="#确定马赛克块坐标" class="headerlink" title="确定马赛克块坐标"></a>确定马赛克块坐标</h3>      <p>将一个马赛克块看作一个整体，图片就被分成了<code>m_width * m_height</code>个马赛克块，那么对于横坐标x，纵坐标y的马赛克块的下标可以通过如下的公式获得。</p><pre><code>index = (y - 1) * m_width + x</code></pre>        <h3 id="确定颜色值"   >          <a href="#确定颜色值" class="heading-link"><i class="fas fa-link"></i></a><a href="#确定颜色值" class="headerlink" title="确定颜色值"></a>确定颜色值</h3>      <p>得到马赛克块之后，就可以把这个区域的像素点修改为同一个值了，这里有几个思路，分别是</p><ol><li>使用左上角的值直接替换其他点的值；</li><li>计算区域像素点的平均值然后替换每一个点；</li><li>使用区域内像素点的中位数值作为其他点的值。</li></ol><p>三种方案在显示效果和计算速度上也有差异，方案1计算快，但是显示会不够平滑。方案2显示最为平滑，计算量比方案1多，但是比方案3更少。方案3因为需要求出中位数，会增加很多比较操作，所以计算量最多，显示效果上也没有平均值的方案平滑，但是轮廓感更强。</p><p><img src="https://file.2fun.xyz/mosaic_value_compare.png"></p>        <h2 id="颜色空间"   >          <a href="#颜色空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h2>      <p>上面仅仅是在理论层面介绍了如何实现马赛克效果，但是在实际的编码中，我们还需要了解图形在数据里面是怎么表示的。这就涉及到 <strong>颜色空间</strong><br>的概念了，常见的颜色空间有RGB、YUV和CMYK（主要应用于打印场景，本文不讲解）等。</p>        <h3 id="RGB"   >          <a href="#RGB" class="heading-link"><i class="fas fa-link"></i></a><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3>      <p>RGB颜色空间是根据颜色在自然界的产生原理来设计的，把颜色分为R：红色、G：绿色和B：蓝色，也就是三原色。一般使用RGB24（也称为RGB888）的颜色空间，即RGB三个分量各使用8bit表示，所以一张图片占用的内存大小就是<code>width _height_ 3</code>字节。RGB颜色空间在计算机里面主要用于图形的采集、显示等领域，例如我们的显示屏显示画面时会使用RGB颜色空间对每一个像素点进行赋值显示。<br>RGB24的数据排列方式为按照像素点将数据分组，每一组有RGB三个分量，对于每一组数据，按照<code>B-&gt;G-&gt;R</code>的顺序排列，如下图所示。</p><p><img src="https://file.2fun.xyz/rgb888_2020421.jpg"></p>        <h3 id="YUV"   >          <a href="#YUV" class="heading-link"><i class="fas fa-link"></i></a><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3>      <p>YUV颜色空间将颜色分为了亮度分量Y和色度分量U和V，因为YUV将亮度分量独立了出来，所以可以兼容老的黑白电视机。常见的YUV格式有YUV444、YUV422和YUV420。对于YUV444、YUV422和YUV420格式的区别，主要是UV分量的分布，如图，空心圆表示UV分量，实心圆表示Y分量。</p><p><img src="https://file.2fun.xyz/yuv444yuv422yuv420.jpg"></p><p>使用YUV420格式相比RGB可以减少一半的带宽，YUV420格式占用的内存大小为<code>width _height + width_ height /4 + width * height /4</code>字节。</p><p>由于YUV420可以节省大量带宽，而人眼对色度信息没有亮度敏感，所以观感不会有明显区别，日常应用最为广泛。根据UV分量在数据中的排布方式，YUV420又分为I420、NV12和YV12等格式。</p><p><strong>I420</strong> I420格式的数据排布如下图所示，先将Y分量全部排进去，然后排U分量最后是V分量。</p><p><img src="https://file.2fun.xyz/yuv420i420.jpg"></p><p><strong>YV12</strong> YV12格式的数据排布如下图所示，先将Y分量全部排进去，然后排V分量最后是U分量。</p><p><img src="https://file.2fun.xyz/yuv420YV12.jpg"></p><p><strong>NV12</strong> NV12格式的数据排布如下图所示，先将Y分量全部排进去，然后U和V分量交替排列。</p><p><img src="https://file.2fun.xyz/yuv420NV12.jpg"></p>        <h2 id="C语言实现"   >          <a href="#C语言实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2>      <p>下面给出I420格式及RGB24格式图像进行马赛克处理的C语言实现，其中马赛克块的颜色值使用平均值法获得，当然此算法还有很多可以改进的地方，例如可考虑加入多线程并发处理提高算法效率。</p><ul><li><p>输入RGB格式数据</p><p>/**</p><ul><li><p>对像素数据进行马赛克处理</p></li><li><p>input_data : 输入的原始像素数据</p></li><li><p>width : 图片的宽度</p></li><li><p>height: 图片的高度</p></li><li><p>channel : 图像通道数，例如RGB24则有3个通道</p></li><li><p>scale : 马赛克块的大小</p></li><li><p>return ： 处理之后的像素数据</p></li><li><p>/<br>void mosaic(unsigned char *input_data, unsigned char *out_data,</p><pre><code>      int width, int height, int channel, int scale)</code></pre><p>{<br>  int index, tindex;<br>  int pix[channel];<br>  for (int i = 0; i &lt; height; i += scale)<br>  {</p><pre><code>  for (int j = 0; j &lt; width; j += scale)  &#123;      index = (width * i + j) * channel;      for (int d = 0; d &lt; channel; d++)      &#123;          pix[d] = 0;      &#125;      //平均值      for (int k = 0; k &lt; scale; k++)      &#123;          for (int p = 0; p &lt; scale; p++)          &#123;              tindex = index + (k * width + p) * channel;              if (tindex &lt; width * height * channel - channel)              &#123;                  for (int d = 0; d &lt; channel; d++)                  &#123;                      pix[d] += input_data[tindex + d];                  &#125;              &#125;          &#125;      &#125;      for (int d = 0; d &lt; channel; d++)      &#123;          pix[d] = pix[d] / scale / scale;      &#125;      for (int k = 0; k &lt; scale; k++)      &#123;          for (int p = 0; p &lt; scale; p++)          &#123;              tindex = index + (k * width + p) * channel;              if (tindex &lt; width * height * channel - channel)              &#123;                  for (int d = 0; d &lt; channel; d++)                  &#123;                      out_data[tindex + d] = pix[d];                  &#125;              &#125;          &#125;      &#125;  &#125;</code></pre><p>  }<br>}</p></li></ul></li><li><p>输入I420格式数据</p><p>/**</p><ul><li><p>对I420格式图像进行马赛克处理</p></li><li><p>input_y : 输入数据的y分量</p></li><li><p>input_u : 输入数据的u分量</p></li><li><p>input_v : 输入数据的v分量</p></li><li><p>out_y : 输出数据的y分量 </p></li><li><p>out_u : 输出数据的u分量 </p></li><li><p>out_v : 输出数据的v分量</p></li><li><p>width : 图片的宽度</p></li><li><p>height: 图片的高度</p></li><li><p>scale : 马赛克块的大小</p></li><li><p>/<br>void mosaicyuv(unsigned char *input_y, unsigned char *input_u, unsigned char *input_v,</p><pre><code>         unsigned char *out_y, unsigned char *out_u, unsigned char *out_v,         int width, int height, int scale)</code></pre><p>{<br>  int len = width * height;<br>  memcpy(out_y, input_y, len);<br>  memcpy(out_u, input_u, len / 4);<br>  memcpy(out_v, input_v, len / 4);<br>  int index, tindex, y;<br>  for (int i = 0; i &lt; height; i += scale)<br>  {</p><pre><code>  for (int j = 0; j &lt; width; j += scale)  &#123;      index = width * i + j;      y = out_y[index];      for (int k = 0; k &lt; scale; k++)      &#123;          for (int p = 0; p &lt; scale; p++)          &#123;              tindex = index + (k * width + p);              if (tindex &lt; len)              &#123;                  y += out_y[tindex];              &#125;          &#125;      &#125;      y = y / scale / scale;      for (int k = 0; k &lt; scale; k++)      &#123;          for (int p = 0; p &lt; scale; p++)          &#123;              tindex = index + (k * width + p);              if (tindex &lt; len)              &#123;                  out_y[tindex] = y;              &#125;          &#125;      &#125;  &#125;</code></pre><p>  }</p><p>  //处理UV分量<br>  int u, v;<br>  index = tindex = u = v = 0;<br>  scale = scale / 2;<br>  for (int i = 0; i &lt; height / 2; i += scale)<br>  {</p><pre><code>  for (int j = 0; j &lt; width / 2; j += scale)  &#123;      index = width / 2 * i + j;      u = v = 0;      for (int k = 0; k &lt; scale; k++)      &#123;          for (int p = 0; p &lt; scale; p++)          &#123;              tindex = index + (k * width / 2 + p);              if (tindex &lt; len / 4)              &#123;                  u = u + out_u[tindex];                  v = v + out_v[tindex];              &#125;          &#125;      &#125;      u = u / scale / scale;      v = v / scale / scale;      for (int k = 0; k &lt; scale; k++)      &#123;          for (int p = 0; p &lt; scale; p++)          &#123;              tindex = index + (k * width / 2 + p);              if (tindex &lt; len / 4)              &#123;                  out_u[tindex] = u;                  out_v[tindex] = v;              &#125;          &#125;      &#125;  &#125;</code></pre><p>  }<br>}</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>H5直播方案总结</title>
      <link href="2020/03/03/H5%E7%9B%B4%E6%92%AD%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
      <url>2020/03/03/H5%E7%9B%B4%E6%92%AD%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[        <h2 id="背景"   >          <a href="#背景" class="heading-link"><i class="fas fa-link"></i></a><a href="#背景" class="headerlink" title="背景"></a>背景</h2>      <p>最近因为工作原因对H5直播方案进行了调研，也算是有所收获，特将此记录下来，如有不对还请指正。此文写于2020年3月，开发与测试环境如下：</p><div class="table-container"><table><thead><tr><th>平台</th><th>版本</th></tr></thead><tbody><tr><td>MacBook</td><td>macOS 10.15.1</td></tr><tr><td>iPhone</td><td>iOS13.3.1</td></tr><tr><td>Android</td><td>9.0</td></tr><tr><td></td><td></td></tr></tbody></table></div><span id="more"></span>        <h2 id="概述"   >          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a>概述</h2>      <p>一个直播系统由前端与后端两部分组成，此文仅探讨前端部分。前端根据视频产生的过程又可以分为视频采集、视频发送与视频播放。对于PC端的浏览器基本上都支持采集、发送和播放，但是对于移动端的浏览器就比较尴尬了，例如iOS的Safari就不支持视频采集（也许是我的方法不对）。</p>        <h2 id="视频采集"   >          <a href="#视频采集" class="heading-link"><i class="fas fa-link"></i></a><a href="#视频采集" class="headerlink" title="视频采集"></a>视频采集</h2>      <p>网页实现视频采集主要是通过[MediaDevices.getUserMedia()](<span class="exturl"><a class="exturl__link"   href="https://developer.mozilla.org/zh-" >https://developer.mozilla.org/zh-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>CN/docs/Web/API/MediaDevices/getUserMedia)方法，不同的浏览器对此的支持程度不同，经测试，IE和iOS的Safari不支持此方法。</p>        <h3 id="采集配置"   >          <a href="#采集配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#采集配置" class="headerlink" title="采集配置"></a>采集配置</h3>      <p>我们可以手动的选择需要采集的数据源，例如是否需要音频/视频，或者视频的大小，甚至是视频的帧率。</p><pre><code>navigator.mediaDevices.getUserMedia(&#123; audio: true, video: &#123; width: 1280, height: 720, frameRate: &#123; ideal: 20, max: 25 &#125; &#125; &#125;)</code></pre>        <h3 id="获取采集的数据"   >          <a href="#获取采集的数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取采集的数据" class="headerlink" title="获取采集的数据"></a>获取采集的数据</h3>      <p>getUserMedia()方法返回一个表示[MediaStream](<span class="exturl"><a class="exturl__link"   href="https://developer.mozilla.org/en-" >https://developer.mozilla.org/en-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>US/docs/Web/API/MediaStream)的[Promise](<span class="exturl"><a class="exturl__link"   href="https://developer.mozilla.org/en-" >https://developer.mozilla.org/en-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>US/docs/Web/JavaScript/Reference/Global_Objects/Promise)对象，使用[URL.createObjectURL()](<span class="exturl"><a class="exturl__link"   href="https://developer.mozilla.org/en-" >https://developer.mozilla.org/en-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>US/docs/Web/API/URL/createObjectURL)可以将其转化为网页标签可以识别的地址，例如将摄像头数据直接显示到video标签上面。</p><pre><code>var video = document.getElementById(video);navigator.mediaDevices.getUserMedia(&#123; audio: true, video: &#123; width: 1280, height: 720, frameRate: &#123; ideal: 20, max: 25 &#125; &#125; &#125;)        .then(function (stream) &#123;            // Older browsers may not have srcObject            if (srcObject in video) &#123;                video.srcObject = stream;            &#125; else &#123;                // Avoid using this in new browsers, as it is going away.                video.src = window.URL.createObjectURL(stream);            &#125;            video.onloadedmetadata = function (e) &#123;                video.play();            &#125;;        &#125;)        .catch(function (err) &#123;            console.log(err.name + :  + err.message);        &#125;);</code></pre>        <h2 id="视频发送"   >          <a href="#视频发送" class="heading-link"><i class="fas fa-link"></i></a><a href="#视频发送" class="headerlink" title="视频发送"></a>视频发送</h2>      <p>获取了视频数据之后，我们还需要将视频发送给服务器或者其他客户端，这里有两个方案分别是[WebRTC](<span class="exturl"><a class="exturl__link"   href="https://developer.mozilla.org/zh-" >https://developer.mozilla.org/zh-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>CN/docs/Glossary/WebRTC)和[WebSockets](<span class="exturl"><a class="exturl__link"   href="https://developer.mozilla.org/zh-" >https://developer.mozilla.org/zh-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>CN/docs/Web/API/WebSockets_API)，而WebSocket根据发送的内容又可以分为图片和视频两种。对于这几种方案主要优缺点如下表所示。</p><div class="table-container"><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>WebRTC</td><td>延迟低，占用带宽小</td><td>观众过多时不支持</td></tr><tr><td>WebSockets发送图片</td><td>方便帧进行单独分析处理，延迟较低</td><td>占用带宽较大</td></tr><tr><td>WebSockets发送视频</td><td>支持视频和音频同时传输，占用带宽少</td><td>切换视频片段时容易卡顿</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div>        <h3 id="WebRTC"   >          <a href="#WebRTC" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h3>      <p>（Web Real Time<br>Communication）WebRTC即网页实时通信协议，可实现浏览器对浏览器的点对点通信，适合用来做视频/语音通话。因为是点对点通信，所以当观众数量太多时就会很复杂。目前网上一些开源的流媒体服务器支持WebRTC协议，可以用来对视频进行处理和转发，本文暂时没有对此进行研究😓。</p>        <h3 id="WebSockets"   >          <a href="#WebSockets" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3>      <p>WebSockets是一种先进的技术。它可以在用户的浏览器和服务器之间打开交互式通信会话。使用此API，您可以向服务器发送消息并接收事件驱动的响应，而无需通过轮询服务器的方式以获得响应。</p>        <h4 id="WebSockets发送图片"   >          <a href="#WebSockets发送图片" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebSockets发送图片" class="headerlink" title="WebSockets发送图片"></a>WebSockets发送图片</h4>      <p>将视频绘制在Canvas上面，然后按照固定的帧率捕获Canvas画面导出为Jpeg，并发送给服务器。这种方案实现简单，但是音频需要单独发送，音视频同步也比较麻烦。</p><pre><code>var video = document.getElementById(video);var canvas = document.getElementById(canvas);var ctx = canvas.getContext(2d);setInterval(function () &#123;    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);    var img = canvas.toDataURL(image/jpeg, 1);    socket.send(img);&#125;, 1000 / 20);</code></pre>        <h4 id="WebSockets发送视频"   >          <a href="#WebSockets发送视频" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebSockets发送视频" class="headerlink" title="WebSockets发送视频"></a>WebSockets发送视频</h4>      <p>将Canvas的图像和麦克风的音频组合录制成视频，然后发送给服务器，录制结束之后立马开始录制新的一个视频。为了减少延迟可以将视频的时长设置短一点，例如2秒。</p><pre><code>var video = document.getElementById(video);var canvas = document.getElementById(canvas);var ctx = canvas.getContext(2d);const mediaRecorder = new mediaRecorder(canvas.captureStream(), &#123;    mimeType: video/webm;codecs=vp9,    audioBitsPerSecond: 128000,    videoBitsPerSecond: 1280 * 720&#125;);const reader = new FileReader();mediaRecorder.ondataavilable = function (e) &#123;    reader.addEventListener(loadend, function () &#123;        socket.send(reader.result);    &#125;);    reader.readAsArrayBuffer(e.data);&#125;setInterval(function () &#123;    mediaRecorder.stop();    mediaRecorder.start();&#125;, 2000);</code></pre>        <h2 id="视频播放"   >          <a href="#视频播放" class="heading-link"><i class="fas fa-link"></i></a><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2>      <p>视频播放是H5直播方案里面的重点，实现视频播放，主要有这几种方案，分别是RTMP、HLS和JSmpeg/Broadway。</p>        <h3 id="RTMP"   >          <a href="#RTMP" class="heading-link"><i class="fas fa-link"></i></a><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h3>      <p>RTMP（Real Time Messaging<br>Protocol）即实时消息传输协议，由Adobe公司提出，需要依赖浏览器的Flash插件进行播放，可使用开源的<span class="exturl"><a class="exturl__link"   href="https://github.com/videojs/video.js" >video.js</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>直接播放RTMP流。在如今所有的浏览器都抛弃Flash的基础上，此方案兼容性有很大的问题，但是现在主流的视频直播网站似乎都是这个方案。</p>        <h3 id="HLS"   >          <a href="#HLS" class="heading-link"><i class="fas fa-link"></i></a><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3>      <p>HLS（Http Live<br>Streaming）是Apple的动态码率自适应技术，包括一个m3u(8)的索引文件，TS媒体分片文件和key加密串文件。其原理就是将一个视频切分为多个单独的小视频，将小视频的地址记录到一个文件里面（m3u8）发送给浏览器，浏览器按顺序播放每一个视频。这种方案在各大视频网站用的很多，因为可以很方便的插入广告。使用浏览器播放HLS视频十分简单，只需要将m3u8的地址放在video标签即可，如下：</p><pre><code>&lt;video controls preload=auto  autoplay=autoplay loop=loop webkit-playsinline&gt;    &lt;source src=http://localhost:8089/hls/test.m3u8 type=application/vnd.apple.mpegurl /&gt;    &lt;p class=warning&gt;Your browser does not support HTML5 video.&lt;/p&gt;&lt;/video&gt;</code></pre>        <h3 id="JSMpeg-Broadway"   >          <a href="#JSMpeg-Broadway" class="heading-link"><i class="fas fa-link"></i></a><a href="#JSMpeg-Broadway" class="headerlink" title="JSMpeg/Broadway"></a>JSMpeg/Broadway</h3>      <p><span class="exturl"><a class="exturl__link"   href="https://github.com/phoboslab/jsmpeg" >JSMpeg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是用JS编写的Mpeg1/MP2解码器，而<span class="exturl"><a class="exturl__link"   href="https://github.com/mbebenita/Broadway" >Broadway</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是用JS编写的H264解码器。之所以将它们视为同一个方案是因为它们都是基于JS解码视频流用Canvas显示，不过JSMpeg支持视频和音频同时解码，而Broadway仅支持视频，所以实际使用JSMpeg会方便些。</p>        <h4 id="FFmpeg参数设置"   >          <a href="#FFmpeg参数设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#FFmpeg参数设置" class="headerlink" title="FFmpeg参数设置"></a>FFmpeg参数设置</h4>      <p>JSmpeg的Github主页里面有一个服务端推流的demo，利用FFmpeg将视频转码并发送到中转服务器，然后再通过WebSockets发送给网页。这里面对于FFmpeg的参数需要注意一下，以免推流之后的视频无法播放，我使用的参数如下：</p><pre><code>ffmpeg -re -i input.mp4 -f mpegts -codec:v mpeg1video -codec:a mp2 -s 640x480 -r 25 http://localhost:8081/&lt;secret&gt;</code></pre><p>具体参数的意思见下表：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-re</td><td><strong>非常重要</strong> 必须放在-i前面，表示按照视频的实际帧率发送数据</td></tr><tr><td>-i</td><td>输入视频源</td></tr><tr><td>-f</td><td>视频容器格式</td></tr><tr><td>-codec:v</td><td>视频编码格式</td></tr><tr><td>-codec:a</td><td>音频编码格式</td></tr><tr><td>-s</td><td>视频大小</td></tr><tr><td>-r</td><td>视频帧率</td></tr><tr><td></td><td></td></tr></tbody></table></div>        <h2 id="相关链接"   >          <a href="#相关链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2>      <ul><li><span class="exturl"><a class="exturl__link"   href="https://github.com/mbebenita/Broadway" >Broadway Github主页</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><a href="">JSMpeg Github主页</a></li><li><span class="exturl"><a class="exturl__link"   href="https://github.com/videojs/video.js" >video.js Github主页</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link"   href="https://www.jianshu.com/p/f5eaeb3fe953" >又拍云关于RTMP、Http FLV、HLS的文章</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link"   href="https://aotu.io/notes/2016/10/09/HTML5-SopCast/?o2src=juejin&o2layout=compat" >H5直播起航</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 快速创建服务器</title>
      <link href="2020/02/19/Python%20%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>2020/02/19/Python%20%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>有时候我们没有带数据线，但是又确实需要将电脑上的文件传输到其他设备上面，该怎么办呢？如果你的电脑上面安装了Python，那么一切就很简单了，只需要一个命令就可以将我们的电脑变成服务器。首先在终端里面cd到我们需要分享的文件夹下面，然后执行：</p><pre><code>python  -m  SimpleHTTPServer   9999(自定义端口)</code></pre><p>我们也可以用这种方式来进行网页浏览测试，比如新写了一个网页，需要看看在手机上面是啥效果，就可以用python轻松地创建一个服务器。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>保持敬畏</title>
      <link href="2020/02/13/%E4%BF%9D%E6%8C%81%E6%95%AC%E7%95%8F/"/>
      <url>2020/02/13/%E4%BF%9D%E6%8C%81%E6%95%AC%E7%95%8F/</url>
      
        <content type="html"><![CDATA[<p>这几天，终于把《三体》三部曲看完了，断断续续看了4个月。在记忆还未消失的时候，总想要写下点什么。我试着总结自己的收获，发现好像无从下手，这个故事太庞大了，里面的内容也十分丰富，有关于物理的、有关于历史的、有关于宇宙学的，也有关于人性的。而我差点就写成了三体故事概要，当我平静下来时，我脑海里出现了几个字：</p><p><strong>保持敬畏</strong></p><p><img src="https://file.2fun.xyz/dakelamaganshamo.jpeg"></p><p>“保持敬畏”是我很早以前在一篇文章里面看到的，文章讲了一个真实的故事：</p><blockquote><p>有两个大学生，相约一起去徒步穿越塔克拉玛干沙漠，起初学弟也不敢去，但是学长说自己长期在外徒步冒险，很有经验，所以学弟答应了。但是他们还是低估了沙漠的危险，第二天就被困在了沙漠。学长留下半瓶水说自己出去找人求救，你在这里等。一天后巡逻队的人发现了留在沙漠的学弟，把他带了回去。学弟问有没有看到自己的学长，巡逻队的人立马去找他的学长，最后在沙漠中发现了他的尸体。</p></blockquote><span id="more"></span><p>文章最后在评价这个故事的时候说， <strong>现在的年轻人不缺少创新和勇气，但是缺少敬畏</strong> 。我觉得说的很对，就一直把这句话记在心里。</p><p><img src="https://file.2fun.xyz/santifengmaintu.jpeg"></p><p>《三体》里面有句话我印象很深：“ <strong>弱小和无知不是生存的障碍，傲慢才是</strong><br>”。当云天明冒着生命危险向人类世界透露了曲率推动可以得到光速飞船的时候，人们选择了躲在阴冷的角落躲避黑暗森林打击。这不仅仅是因为担心曲率驱动导致的空间扭曲提前暴露自己坐标，更是因为建造了容纳数百万人口的星体城之后，觉得即使黑暗森林打击到来了也没有关系，因为他们可以躲在大星体的背后。这也导致了他们最终的灭亡，在面对二向铂的时候，强大的战舰和城市就像放在热锅上的奶酪一样融化、消失、死去。</p><p><img src="https://file.2fun.xyz/daikouzaode2020113.jpeg"></p><p>最近刚好是肺炎的非常时期，看着小区里面扎堆聊天的人、村里面和群众打牌正欢的村干部、坚持办酒席的老人和四处狂奔的孩童等觉得甚是可笑。我最常听到的几句话就是：</p><ul><li>“都是邻居/亲人怎么会传染起！”</li><li>“哪里那么容易传染，这么多人在外面走诶！”</li></ul><p>有一点让我很迷惑，当村里的路障设置之后，出来打牌的人变多了。虽然会有警察开着车播放着“春节年年有，今年莫乱走。。。”的口号，这个时候就会出现有趣的事儿，打牌的人在警车快到的时候就跑回自己家，等警车走了之后又跑出来继续打牌；或者有些人干脆把门关上继续玩。</p><p>我也不知道感染上了肺炎会有多么的痛苦，但我知道春节假期延长了3天，定的返杭车票被取消了，回小区需要企业复工批文，坐地铁还需要健康码。这些之前从来没有发生的事情出现了，难道是因为这个肺炎太简单了吗？这我想起了《流浪地球》里面的一句话“让人类永远保持理智是一种奢望”，放在这里也很适用“<br><strong>让人类永远保持敬畏是一种奢望</strong> ”。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的2019年终总结</title>
      <link href="2020/01/18/%E6%88%91%E7%9A%842019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>2020/01/18/%E6%88%91%E7%9A%842019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>如果用一个字总结2019年的话，那就是“ <strong>南</strong> ”，“ <strong>南</strong><br>”主要体现在工作事业上面：年初从花生有信离职，随后入职杭州布洛，本以为可以长期在公司效劳，可是年底公司又因为经营问题裁员2/3。被裁之后去了阿里巴巴人工智能实验室外包岗，每天都很幸苦，基本属于996的状态，感觉身体有点吃不消，不过还是很有收获（等有空的时候单独写一篇工作总结文章）。</p><p><img src="https://file.2fun.xyz/2020/01/20200722035430143.jpg" alt="南"></p>        <h2 id="2018年Flag"   >          <a href="#2018年Flag" class="heading-link"><i class="fas fa-link"></i></a><a href="#2018年Flag" class="headerlink" title="2018年Flag"></a>2018年Flag</h2>      <p>写2019年总结的时候，特意翻看了一下<a href="https://www.bearever.cn/story/2018summary/">2018年的总结</a>，心想，可别又成了一个失信于己/于人的人，在2018年的总结里面立的Flag是在2019年制作一款独立游戏。<br><img src="https://file.2fun.xyz/review-2018-flag.png" alt="2018年立的Flag">9月份参加 <strong>机核</strong><br>的独立游戏大赛，制作了一款Love2D平台的小游戏，也算是实现了Flag。在这里，非常感谢“阿廖”和“大超”放弃国庆假期来帮助开发，还有中间给予帮助的学妹“亦嘉”和女汉子“朝怡”。虽然游戏最后没有获奖，但是3天极限开发，一边写代码一边画图的过程还是很充实（累成狗）。</p><span id="more"></span><p><img src="https://file.2fun.xyz/love2d-loverun-shotscreeen.png" alt="小游戏的截图"></p>        <h2 id="2019年总结"   >          <a href="#2019年总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#2019年总结" class="headerlink" title="2019年总结"></a>2019年总结</h2>      <p>2018年的总结是按照时间线排的，2019年准备换一个思路。前段时候看梁爽同事的方法挺好，也想尝试一下，总结分为四个部分：专业技能、个人成长、兴趣爱好和月事记。</p>        <h2 id="专业技能"   >          <a href="#专业技能" class="heading-link"><i class="fas fa-link"></i></a><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2>      <p>2019年，专业技能方面有明显的提升，不局限于安卓，主要有以下几块：</p><blockquote><ul><li>安卓</li><li>Python</li><li>C/C++（厚颜无耻的写上去）</li></ul></blockquote>        <h3 id="安卓"   >          <a href="#安卓" class="heading-link"><i class="fas fa-link"></i></a><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h3>      <p>所谓“你知道的越多，你不知道的越多”，做安卓开发一年的时候，我觉得自己到了尽头，好像什么页面都能写，什么动画都能画，工作上的需求都能完成，似乎没有什么能难倒我的了。想想那时的自己，真的是“Too<br>Young Too Simple”。今年自己安卓方面的提升，主要有以下几块：</p><blockquote><ul><li>模块化</li><li>库设计</li><li>团队协作</li></ul></blockquote>        <h4 id="模块化"   >          <a href="#模块化" class="heading-link"><i class="fas fa-link"></i></a><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4>      <p>安卓应用开发，随着业务的发展，最后项目变得十分巨大，单人项目变成了多人项目，就需要模块化了。在杭州布洛的时候对于模块化略有研究，主要的方案是通过抽象一个底层核心库，抽离业务，然后实现一个应用基础库，让不同的业务引用业务库，通过路由进行通信，实现模块化。当项目数量增加的时候，仓库的重要性就体现出来了，对业务库进行封装，上传仓库，其他项目组即可方便的使用，减少开发时间。</p><p><img src="https://file.2fun.xyz/drawio20200118x.png" alt="模块化设计"></p>        <h4 id="库设计"   >          <a href="#库设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#库设计" class="headerlink" title="库设计"></a>库设计</h4>      <p>在杭州布洛的时候设计了很多库方便同事使用，例如“权限库”、“异步链式库”和“IM库”。在进行库设计的时候，遵循了先设计后编码的流程，使用Markdown编写库设计文档，然后和同事商量改进点，最后进行编码。这样可以提高库的实用性和规范化，对于设计模式的使用也会更有经验。</p>        <h4 id="团队协作"   >          <a href="#团队协作" class="heading-link"><i class="fas fa-link"></i></a><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h4>      <p>小公司喜欢全栈工程师，一人包揽所有的活，当公司达到一定的规模的时候，团队协作就十分有必要了。对于安卓来说，多人协作主要是：<br><strong>代码管理、环境统一和功能复用</strong><br>。其中代码管理通过Git/SVN可以解决，如果希望更加规范的化，可以加入代码Review的设计进去。环境统一是多人协作的一个重点，开发人员众多，我们在引用其他库的时候，肯定不希望与自己现有的功能冲突，所以就需要解决统一环境，包括SDK版本、依赖库版本、项目配置等信息。功能复用的核心是业务的抽离，对于程序员的要求主要体现在颗粒度的把握，如果模块化做的足够的好，功能复用也就可以变得很简单。</p>        <h3 id="Python"   >          <a href="#Python" class="heading-link"><i class="fas fa-link"></i></a><a href="#Python" class="headerlink" title="Python"></a>Python</h3>      <p>本年度Python脚本写的较多，对于Python算是有一点儿了解了，已经可以比较熟练的使用Python编写脚本处理日常任务，还能用Python开发带有GUI的工具，提高业务处理效率。不过对于Python进行网络处理这一块还是不熟，应用的比较少。</p>        <h3 id="C-C"   >          <a href="#C-C" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3>      <p>2019年底在阿里做了一点嵌入式开发的工作，需要使用C/C++进行开发。刚接触的时候也是一头雾水，完全不知道从哪里入手，光是编译一个Hello World<br>就很折腾。后来找系统团队发了一点Demo，学着写写，目前嵌入式开发的流程基本明白了：先在PC上面用C/C++开发应用，使用嵌入式设备的开发工具包打包成可执行文件，再拷贝到嵌入式设备里面，运行可执行文件。里面涉及的技术点主要有：C/C++、CMake和Linux等。</p>        <h2 id="个人成长"   >          <a href="#个人成长" class="heading-link"><i class="fas fa-link"></i></a><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2>      <p>个人成长方面，主要是读书和博客更新。</p>        <h3 id="读书情况"   >          <a href="#读书情况" class="heading-link"><i class="fas fa-link"></i></a><a href="#读书情况" class="headerlink" title="读书情况"></a>读书情况</h3>      <p>今年，一共读了6本书，分别是《Android艺术探索》、《Android<br>Gradle权威指南》、《流浪地球》、《人间失格》、《三体Ⅰ》和《三体Ⅱ》。对我影响较大的是《人间失格》和《三体》，一小一大，不同的视野，不同的感受。</p><p><img src="https://file.2fun.xyz/%E6%88%AA%E5%B1%8F2020-01-18%E4%B8%8B%E5%8D%885.13.58.png"></p><p><strong>人间失格</strong></p><p>《人间失格》讲述了一个自卑、自弃的人的悲惨一生。放正常人的眼中，他其实是一个幸运儿，有一个好的出生家庭，有众多异性的喜爱。但是他小心翼翼的经营着自己，免得惹怒别人。看完之后感觉自己很幸运，至少对世间和未来充满希望。</p><p><strong>三体</strong></p><p>《三体》描绘了一个十分宏大的世界，用近乎历朴实的语言讲述了一个非常震撼的故事，从文化大革命时期一直到四百年后的未来。一直听别人说《三体》多么多么牛逼，直到自己亲眼所见整个故事，才觉得这不仅仅是牛逼能形容的。宇宙一百多亿的时间里面，人类的出现是偶然还是必然，为什么到现在仍然没有发现其他文明，大危机爆发时人类如何选择？如果你对这些问题感兴趣，强烈推荐你看看《三体》。</p>        <h3 id="维护博客"   >          <a href="#维护博客" class="heading-link"><i class="fas fa-link"></i></a><a href="#维护博客" class="headerlink" title="维护博客"></a>维护博客</h3>      <p>本年度一共更新了9篇博客，整体质量较低。主要原因是在公司也经常写博客，所以就不想再回家继续写了，来年需要改进。</p>        <h2 id="兴趣爱好"   >          <a href="#兴趣爱好" class="heading-link"><i class="fas fa-link"></i></a><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h2>      <p>兴趣爱好方面，基本上属于退步阶段，之前还会偶尔玩下滑板，2019年碰都没有碰一下，2020年希望还是能够捡起来玩玩。</p>        <h3 id="Vlog"   >          <a href="#Vlog" class="heading-link"><i class="fas fa-link"></i></a><a href="#Vlog" class="headerlink" title="Vlog"></a>Vlog</h3>      <p>都说大疆的 <strong>OSMO Action</strong><br>是拍摄Vlog的神器，双十一的时候我也买了一个，结果一直等到双十二所有的东西才发货完成（大疆的客服真的很差）。但是不得不说Action真的很强，4K/30FPS还可以防抖，加上前置屏幕，使用非常方便。</p><p><img src="https://file.2fun.xyz/31579328672_.pic.jpg"></p>        <h3 id="【机核】游戏大赛"   >          <a href="#【机核】游戏大赛" class="heading-link"><i class="fas fa-link"></i></a><a href="#【机核】游戏大赛" class="headerlink" title="【机核】游戏大赛"></a>【机核】游戏大赛</h3>      <p>十月份的时候参加了机核主办的游戏创作大赛“BOOOM”，因为前面有提到，这里就不详细写了。</p>        <h2 id="月事记"   >          <a href="#月事记" class="heading-link"><i class="fas fa-link"></i></a><a href="#月事记" class="headerlink" title="月事记"></a>月事记</h2>      <p>每个月最重要的事情，主要是下面的这些：</p><ul><li>2月 过年回家，大年初一看《流浪地球》</li></ul><p><img src="https://file.2fun.xyz/IMG_20190205_002312R.jpg"></p><ul><li>4月 入职“杭州布洛科技有限公司”</li></ul><p><img src="https://file.2fun.xyz/IMG_20190415_165709R.jpg"></p><ul><li>5月 游览杭州国际动漫节；宇哥生日一起玩桌游</li></ul><p><img src="https://file.2fun.xyz/21579405877_.pic_hd.jpg"></p><ul><li>7月 公司团建，一起吃日料</li></ul><p><img src="https://file.2fun.xyz/IMG_20190727_111022R.jpg"></p><ul><li>9月 参加【机核】游戏大赛；参观丹姐家的豪宅</li></ul><p><img src="https://file.2fun.xyz/2ee679cb-9d91-4120-988d-f5c7bb71beb5.jpg"></p><ul><li>10月 国庆节去绍兴游玩</li></ul><p><img src="https://file.2fun.xyz/IMG_20191005_141108R.jpg"></p><ul><li>11月 因公司经营问题被裁员；入职阿里人工智能实验室外包岗</li></ul><p><img src="https://file.2fun.xyz/IMG_20191126_191837R.jpg"></p><ul><li>12月 梁爽生日，吃“冬阴功火锅”</li></ul><p><img src="https://file.2fun.xyz/11579421574.jpg"></p>        <h2 id="2020年的Flag"   >          <a href="#2020年的Flag" class="heading-link"><i class="fas fa-link"></i></a><a href="#2020年的Flag" class="headerlink" title="2020年的Flag"></a>2020年的Flag</h2>      <p>一年的结束也就意味着新的一年的到来，这既是总结，也是一个计划，把2020年的Flag立下来，看看明年能有多少收获。</p><p><img src="https://file.2fun.xyz/%E6%88%AA%E5%B1%8F2020-01-18%E4%B8%8B%E5%8D%883.28.00.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle缓存更新</title>
      <link href="2019/08/23/Gradle%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/"/>
      <url>2019/08/23/Gradle%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>今天Jenkins打包的时候报了下面的这个错误，查了很久，是依赖的库版本冲突导致的。</p><pre><code>* What went wrong:Execution failed for task &#39;:app:transformClassesWithMultidexlistForBranchRelease&#39;.&gt; com.android.build.api.transform.TransformException: Error while generating the main dex list.* Try:Run with --info or --debug option to get more log output. Run with --scan to get full insights.</code></pre><span id="more"></span><p>因为我们依赖了库A和库C，而库A依赖了库B，库C依赖了库B，这时我们把库C的做了一个升级，同时库C依赖的库B也升级了一个版本，但是却把库A漏掉了。所以呢我们就又去把库A依赖的库B版本改为了库C依赖的同一个版本。可是我们却不想升级版本号，于是我们自作聪明的把Gradle的缓存文件夹<code>C:\Users\Administrator.gradle\caches\modules-2\files-2.1</code>删除了，接着就出现了一个新的问题，重新编译的包死活不会打包库C进来。原来这个Gradle有一套自己的缓存机制，直接删除这个文件夹是没有用的，但是我们可以使用Gradle语法来强制刷新版本依赖。使用如下命令即可：</p><pre><code>gradlew build --refresh-dependencies</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio Profiler 内存泄漏分析</title>
      <link href="2019/07/04/Android%20Studio%20Profiler%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/"/>
      <url>2019/07/04/Android%20Studio%20Profiler%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>最近的项目中出现了内存泄漏，在踩了好多坑之后，终于解决了遇到的泄漏问题，为了防止下次忘记，所以把这次的经验记录下来。</p>        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h3>      <p>内存泄漏有很多种的情况，在安卓里面，大多是因为内部类持有了<code>Activity</code>或者<code>Context</code>的引用导致<code>Activity</code>或者<code>Context</code>无法释放，最常见的是执行了一个耗时操作，在退出<code>Activity</code>的时候没有关闭耗时操作，导致<code>Activity</code>一直被耗时操作持有。<br>例如网上经常会有讲到使用<code>Handler</code>的时候需要注意泄漏，需要使用静态内部类，并且弱引用<code>Activity</code>解决。这样的地方可以在写代码的时候注意到然后解决，但是有些时候我们也不知道哪里出现了内存泄漏，就需要通过工具帮助我们分析了。</p>        <h3 id="Android-Studio-Profiler"   >          <a href="#Android-Studio-Profiler" class="heading-link"><i class="fas fa-link"></i></a><a href="#Android-Studio-Profiler" class="headerlink" title="Android Studio Profiler"></a>Android Studio Profiler</h3>      <p>Android Studio自带的Profiler就提供了这样的能力，打开Profiler会看到如下的界面，</p><span id="more"></span><p><img src="https://file.2fun.xyz/android_studio_profiler20190704174351.png"><br>然后点击红色选框中的部分，就可以进入内存分析详情如下：<br><img src="https://file.2fun.xyz/android_studio_profiler20190704174635.png"><br>为了查看到内存泄漏，我们需要对app进行一顿操作。如果我们想知道一个<code>TestActivity</code>有没有内存泄漏，那么我们可以频繁的进出<code>TestActivity</code>,按照官网的说法横竖屏切换和回退到桌面再进入app也会增加泄漏的风险。一顿操作猛如虎，要知泄漏有没有，且看下面。<br>当我们频繁操作之后，可以先点击左上角的垃圾桶按钮，进行强制GC，多点几次，接下来点击左上角的下箭头图标生成分析文件，这就是我们判断有没有内存泄漏的关键。<br><img src="https://file.2fun.xyz/android_studio_profiler_dump2019.gif"><br>为了方便查看，我们可以把分组方式改为按照包名分组<br><img src="https://file.2fun.xyz/android_studio_profiler20190704180503.png"><br>那么怎么看有没有泄漏呢？在左下角的堆窗口找到我们想要测试的那个class名，点击会出现如下的窗口：<br><img src="https://file.2fun.xyz/android_studio_profiler20190704181022.png"><br>其中左下角的<code>HandlerActivity</code>和<code>HandlerActivity$1</code>可能第一次看会很迷，难道说我的这个类有两个实例吗,那不就是内存泄漏了么?其实并不是这个意思，<code>$</code>符号只是说明这个类有一个内部类而已，因为内部类会持有外部类的引用。<br>右上角的地方我们可以看到有四个<code>HandlerActivity</code>，那这个说明是内存泄漏了么？是的，这个<code>Instance View</code>就是实例窗口，有几个就说明有几个实例，如果按照逻辑这个对象同时只能有一个实例的话，那就是内存泄漏了。<br>当知道是内存泄漏之后就需要找到泄漏的地方，在右下角有一个引用窗口，可以看到具体是谁引用这个它，导致内存不能及时回收。在右上角的实例窗口选中一个实例，然后在引用窗口选中一条点击右键<code>Jump to Source</code>就可以看到具体引用的地方，然后观察代码就知道是什么问题导致的内存泄漏了。<br><img src="https://file.2fun.xyz/android_profiler20190704181835.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio build failed</title>
      <link href="2019/06/03/AndroidStudio%20build%20failed/"/>
      <url>2019/06/03/AndroidStudio%20build%20failed/</url>
      
        <content type="html"><![CDATA[<p>使用安卓AndroidStudio开发应用的时候，经常会出现编译失败的情况，有的时候，AS会告诉我们是哪里出了问题，但是有的时候只会提示一段类似这样的话：</p><pre><code>org.gradle.api.tasks.TaskExecutionException: Execution failed for task &#39;:chat_lib:compileDebugKotlin&#39;.    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:100)    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:70)    at org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:62)    at org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)</code></pre><span id="more"></span><pre><code>    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:60)    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:97)    ...</code></pre><p>对于这样的描述，我们也只是一头雾水，有没有可能知道更加清除的错误信息呢？答案是有的，而且就在上面的输出日志里面。上面错误信息的第一句话写的是<code>org.gradle.api.tasks.TaskExecutionException: Execution failed for task &#39;:chat_lib:compileDebugKotlin&#39;.</code>,这里已经告诉我们是因为什么出了问题，原来就是执行<code>chat_lib:compileDebugKotlin</code>的时候报错了。我们打开AS的终端，输入:</p><pre><code>gradlew chat_lib:compileDebugKotlin</code></pre><p>运行这个TASK,就可以看到详情的错误原因了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MacOS显示隐藏文件夹</title>
      <link href="2019/05/11/MacOS%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>2019/05/11/MacOS%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[        <h3 id="在MacOS里面显示隐藏文件的快捷键"   >          <a href="#在MacOS里面显示隐藏文件的快捷键" class="heading-link"><i class="fas fa-link"></i></a><a href="#在MacOS里面显示隐藏文件的快捷键" class="headerlink" title="在MacOS里面显示隐藏文件的快捷键"></a>在MacOS里面显示隐藏文件的快捷键</h3>      <pre><code>command+shift+.</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins Gradle 打包的问题</title>
      <link href="2019/03/29/Jenkins%20Gradle%20%E6%89%93%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2019/03/29/Jenkins%20Gradle%20%E6%89%93%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[        <h3 id="错误1"   >          <a href="#错误1" class="heading-link"><i class="fas fa-link"></i></a><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h3>      <pre><code>* What went wrong:Could not determine java version from &#39;10.0.2&#39;.</code></pre><p>解决方案： 这个问题的原因是本地有多个Java版本,卸载掉其他版本的java，保留java8就可以了。</p><span id="more"></span>        <h3 id="错误2"   >          <a href="#错误2" class="heading-link"><i class="fas fa-link"></i></a><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h3>      <pre><code>* What went wrong:A problem occurred configuring project &#39;:avchatkit&#39;.&gt; You have not accepted the license agreements of the following SDK components:  [Android SDK Platform 26, Android SDK Build-Tools 26.0.2].  Before building your project, you need to accept the license agreements and complete the installation of the missing components using the Android Studio SDK Manager.  Alternatively, to learn how to transfer the license agreements from one workstation to another, go to http://d.android.com/r/studio-ui/export-licenses.html</code></pre><p>解决方案： 这个问题的原因是sdk没有统一授权，需要到sdk的安装目录里面，找到<code>bin/sdkmanager</code>，执行下面的命令同意授权即可</p><pre><code>yes | sdkmanager --licenses</code></pre>        <h3 id="错误3"   >          <a href="#错误3" class="heading-link"><i class="fas fa-link"></i></a><a href="#错误3" class="headerlink" title="错误3"></a>错误3</h3>      <pre><code>* What went wrong:A problem occurred configuring project &#39;:avchatkit&#39;.&gt; Failed to notify project evaluation listener.   &gt; org.gradle.api.tasks.compile.CompileOptions.setBootClasspath(Ljava/lang/String;)V</code></pre><p>解决方案 主要问题是是项目使用的gradle4.2，但是Jenkins使用了gradle5<br>所以导致了一些兼容问题，可以在jenkins里面设置为使用项目里面的gradle版本。<br><img src="https://file.2fun.xyz/20190329154228.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 数据库连接失败</title>
      <link href="2019/01/25/SpringBoot%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/"/>
      <url>2019/01/25/SpringBoot%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p>今天在测试springboot的时候遇到一个问题，数据库一直连接不上，服务器报错：</p><blockquote><p>Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The<br>server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more<br>than one time zone. You must configure either the server or JDBC driver (via<br>the serverTimezone configuration property) to use a more specifc time zone<br>value if you want to utilize time zone support.</p></blockquote><p>上网查询了一下，原因是我的表里面有一个字段使用了<code>datetime</code>类型，使用 <em>mybatis-generator</em><br>生成的enty文件里面自动转化为了<code>Date</code>类型，需要指定时区才可以使用，所以在jdbc的url地址后面添加<code>serverTimezone=UTC</code>。完整的地址如下：</p><span id="more"></span><pre><code>spring.datasource.url=jdbc:mysql://192.168.2.199:3306/jump?characterEncoding=utf-8&amp;&amp;useUnicode=true&amp;&amp;zeroDateTimeBehavior=convertToNull&amp;&amp;serverTimezone=UTC</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis报错 There is no getter for property named xx in xxx</title>
      <link href="2019/01/23/Mybatis%E6%8A%A5%E9%94%99%20There%20is%20no%20getter%20for%20property%20named%20xx%20in%20xxx/"/>
      <url>2019/01/23/Mybatis%E6%8A%A5%E9%94%99%20There%20is%20no%20getter%20for%20property%20named%20xx%20in%20xxx/</url>
      
        <content type="html"><![CDATA[<p>编写接口的时候遇到一个错误</p><blockquote><p>Request processing failed; nested exception is<br>org.mybatis.spring.MyBatisSystemException: nested exception is<br>org.apache.ibatis.reflection.ReflectionException: There is no getter for<br>property named ‘record’ in ‘class java.math.BigDecimal’</p></blockquote><p>具体的mybatis配置文件如下:</p><span id="more"></span><pre><code>&lt;select id=&quot;countScore&quot; resultType=&quot;int&quot;&gt;    select count(1) as num from tb_score    &lt;if test=&quot;record != null&quot;&gt;        where score &lt;= #&#123;record,jdbcType=DECIMAL&#125;    &lt;/if&gt;&lt;/select&gt;</code></pre><p>mapper的接口方法如下：</p><pre><code>int countScore(BigDecimal record);</code></pre><p>看了很久一直没有找到原因，最后在网上查到是<code>&lt;if test=&quot;record != null&quot;&gt;</code>的问题，这里我只传了一个参数就是record,但是它提示找不到，解决方案是将这句话改为<code>&lt;if test=&quot;_parameter != null&quot;&gt;</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ终端乱码</title>
      <link href="2019/01/15/IntelliJ%E7%BB%88%E7%AB%AF%E4%B9%B1%E7%A0%81/"/>
      <url>2019/01/15/IntelliJ%E7%BB%88%E7%AB%AF%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>使用IntelliJ编写Spring项目，终端输出乱码的解决办法: 在VM options里面填写<code>-Dfile.encoding=UTF-8</code><br><img src="https://file.2fun.xyz/intellij_20190115111222.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集成360加固和Walle多渠道打包</title>
      <link href="2019/01/11/%E9%9B%86%E6%88%90360%E5%8A%A0%E5%9B%BA%E5%92%8CWalle%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
      <url>2019/01/11/%E9%9B%86%E6%88%90360%E5%8A%A0%E5%9B%BA%E5%92%8CWalle%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><span class="exturl"><a class="exturl__link"   href="https://github.com/Luomingbear/JiaguAndWalle"  title="github链接">github链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>解决360加固导致的渠道信息丢失的问题，同时快速打多渠道包。</p>        <h3 id="用法："   >          <a href="#用法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3>      <ul><li>App添加Walle的依赖<code>compile &#39;com.meituan.android.walle:library:1.1.6&#39;</code></li><li>在config360.py里面添加自己的360账号信息</li><li>在sign.json文件里面添加签名信息和buildToolVersion信息</li><li>各种渠道的定义是在<code>channel</code>这个文件中，请根据项目情况修改</li><li>运行命令<code>python path_of_jiagu_walle.py path_of_apk you_key_name</code> ,这里的可以 <em>key_name</em> 需要配置在<code>sign.json</code>文件里面</li></ul><span id="more"></span>        <h3 id="channel"   >          <a href="#channel" class="heading-link"><i class="fas fa-link"></i></a><a href="#channel" class="headerlink" title="channel"></a>channel</h3>      <p><code>channel</code>文件是存储渠道信息的文件，格式如下：</p><pre><code>360cn #360baidu # 百度wandoujia # 豌豆荚yingyongbao # 应用宝xiaomi # 小米meizu # 魅族vivo # vivooppo # oppohuawei # 华为samsung # 三星chuizi # 锤子</code></pre>        <h3 id="sign-json"   >          <a href="#sign-json" class="heading-link"><i class="fas fa-link"></i></a><a href="#sign-json" class="headerlink" title="sign.json"></a>sign.json</h3>      <p>sign.json存放的是签名信息，字段设计参考</p><pre><code>&#123;    &quot;myKeyName&quot;: &#123;        &quot;keyStore&quot;: &quot;C:\\Users\\Desktop\\out\\xx.jks&quot;,        &quot;alias&quot;: &quot;xxxxx&quot;,        &quot;keyPassword&quot;: &quot;xxxxx&quot;,        &quot;aliasPassword&quot;: &quot;xxx&quot;,        &quot;buildToolVersion&quot;: &quot;27.0.0&quot;    &#125;&#125;</code></pre>        <h3 id="兼容腾讯应用宝市场"   >          <a href="#兼容腾讯应用宝市场" class="heading-link"><i class="fas fa-link"></i></a><a href="#兼容腾讯应用宝市场" class="headerlink" title="兼容腾讯应用宝市场"></a>兼容腾讯应用宝市场</h3>      <p>由于腾讯的应用宝市场需要使用自己的乐加固进行加固，导致之前进行的美团渠道信息丢失，所以需要进行单独的处理。打开乐加固的软件，可以看到，它本身是支持多渠道打包的。我们可以在<code>Android Name</code>一栏写上app定义好的渠道key例如“CHANNEL”,然后<code>配置参数</code>随便写上啥，只要你自己知道这个表示的是应用宝市场就行。<br><img src="https://file.2fun.xyz/LEJIAGU20190111112231.png"><br>然后在app的<code>AndroidManifest.xml</code>里面添加应用宝的渠道设置信息：</p><pre><code>&lt;!--应用宝渠道信息--&gt;&lt;meta-data    android:name=&quot;CHANNEL&quot;    android:value=&quot;lingsir&quot; /&gt;</code></pre>        <h3 id="获取渠道信息"   >          <a href="#获取渠道信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取渠道信息" class="headerlink" title="获取渠道信息"></a>获取渠道信息</h3>      <pre><code>/**     * 获取app渠道（设备来源）     *     * @return     */    public String getAppSource(Context ctx) &#123;        String defChannel = &quot;def&quot;;        if (ctx == null) &#123;            return defChannel;        &#125;        String channel = &quot;&quot;;        //从manifest获取,如果manifest设置了值，说明是使用的应用宝多渠道打包，walle不可用        channel = getMetaData(ctx, &quot;CHANNEL&quot;);        if (!TextUtils.isEmpty(channel) &amp;&amp; !channel.equals(&quot;lingsir&quot;)) &#123;            return channel;        &#125;        //walle从apk包中获取        channel = WalleChannelReader.getChannel(ctx, defChannel);        return channel;    &#125;    /**     * 获取Manifest 里面的meta-data     *     * @param context     * @param key     * @return     */    public static String getMetaData(Context context, String key) &#123;        ApplicationInfo ai = null;        try &#123;            ai = context.getPackageManager().getApplicationInfo(context.getPackageName(),                    PackageManager.GET_META_DATA);        &#125; catch (PackageManager.NameNotFoundException e) &#123;            e.printStackTrace();            return &quot;&quot;;        &#125;        Bundle bundle = ai.metaData;        return bundle.getString(key);    &#125;</code></pre><p>Walle渠道信息读取类</p><pre><code>public final class WalleChannelReader &#123;    private WalleChannelReader() &#123;        super();    &#125;    /**     * get channel     *     * @param context context     * @return channel, null if not fount     */    @Nullable    public static String getChannel(@NonNull final Context context) &#123;        return getChannel(context, null);    &#125;    /**     * get channel or default     *     * @param context context     * @param defaultChannel default channel     * @return channel, default if not fount     */    @Nullable    public static String getChannel(@NonNull final Context context, @NonNull final String defaultChannel) &#123;        final ChannelInfo channelInfo = getChannelInfo(context);        if (channelInfo == null) &#123;            return defaultChannel;        &#125;        return channelInfo.getChannel();    &#125;    /**     * get channel info (include channle &amp; extraInfo)     *     * @param context context     * @return channel info     */    @Nullable    public static ChannelInfo getChannelInfo(@NonNull final Context context) &#123;        final String apkPath = getApkPath(context);        if (TextUtils.isEmpty(apkPath)) &#123;            return null;        &#125;        return ChannelReader.get(new File(apkPath));    &#125;    /**     * get value by key     *     * @param context context     * @param key     the key you store     * @return value     */    @Nullable    public static String get(@NonNull final Context context, @NonNull final String key) &#123;        final Map&lt;String, String&gt; channelMap = getChannelInfoMap(context);        if (channelMap == null) &#123;            return null;        &#125;        return channelMap.get(key);    &#125;    /**     * get all channl info with map     *     * @param context context     * @return map     */    @Nullable    public static Map&lt;String, String&gt; getChannelInfoMap(@NonNull final Context context) &#123;        final String apkPath = getApkPath(context);        if (TextUtils.isEmpty(apkPath)) &#123;            return null;        &#125;        return ChannelReader.getMap(new File(apkPath));    &#125;    @Nullable    private static String getApkPath(@NonNull final Context context) &#123;        String apkPath = null;        try &#123;            final ApplicationInfo applicationInfo = context.getApplicationInfo();            if (applicationInfo == null) &#123;                return null;            &#125;            apkPath = applicationInfo.sourceDir;        &#125; catch (Throwable e) &#123;        &#125;        return apkPath;    &#125;&#125;</code></pre>        <h3 id="为什么不使用乐加固进行多渠道打包"   >          <a href="#为什么不使用乐加固进行多渠道打包" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么不使用乐加固进行多渠道打包" class="headerlink" title="为什么不使用乐加固进行多渠道打包?"></a>为什么不使用乐加固进行多渠道打包?</h3>      <p>乐加固的多渠道打包时间和美团的walle差别不大，但是乐加固没有提供jar包进行操作，导致无法实现自动化操作，所以我选择了walle。</p>        <h3 id="运行注意事项："   >          <a href="#运行注意事项：" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行注意事项：" class="headerlink" title="运行注意事项："></a>运行注意事项：</h3>      <ol><li>保证你Android程序的compileSdKVersion 和 buildToosVersion 版本相同</li><li>建议将jdk升级到1.8</li><li>保证自己本地打包签名可以正常运行</li><li>保证配置的相关路径正确，编码格式为UTF-8，不要带异常字符。</li><li>Android SDK buidtools请使用25.0+版本，越新越好。</li></ol><hr>        <h3 id="参考"   >          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h3>      <p>[**ProtectedApkResignerForWalle**](<span class="exturl"><a class="exturl__link"   href="https://github.com/Jay-" >https://github.com/Jay-</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>Goo/ProtectedApkResignerForWalle)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的2018年终总结</title>
      <link href="2019/01/01/%E6%88%91%E7%9A%842018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>2019/01/01/%E6%88%91%E7%9A%842018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2018年就这样过去了，也是时候写一篇年终总结了。虽然是这么想着的，但是仍然无法下笔，脑袋乱成一团，索性记录一个流水账。</p>        <h3 id="一月"   >          <a href="#一月" class="heading-link"><i class="fas fa-link"></i></a><a href="#一月" class="headerlink" title="一月"></a>一月</h3>      <p>来到新公司三个月刚好转正，最开心的莫过是也给我发了年终奖吧。这个月公司的产品“灵花钱”正式上线，可以让用户在买单的时候享受一定的折扣，感觉是个很朴实的产品，但是有真真切切的带给了用户优惠。公司有位新同事虽是十二月就入职，但是与我同名同姓，也很喜欢“锤子科技”，让我很是惊喜,但是这个同事半年后被离职了。。。<br><img src="https://file.2fun.xyz/61546331613_.pic.jpg"></p>        <h3 id="二月"   >          <a href="#二月" class="heading-link"><i class="fas fa-link"></i></a><a href="#二月" class="headerlink" title="二月"></a>二月</h3>      <p>二月春节，和梁爽一起回家。在K529的列车上，我们一起聊天，一起看窗外发呆，一起玩Switch。大学时光一直梦想的就是可以一起坐火车回家，现在终于实现了。在外打工是件很辛苦的事情，庆幸有她一路陪伴。年初一，去外公的坟前祭拜，甚至不敢相信外公就这样去世了。但是我们家和外婆家的感情似乎比以前更好了，或许这就是失去了才懂得珍惜。</p><span id="more"></span><p><img src="https://file.2fun.xyz/71546332154_.pic.jpg"></p>        <h3 id="三月"   >          <a href="#三月" class="heading-link"><i class="fas fa-link"></i></a><a href="#三月" class="headerlink" title="三月"></a>三月</h3>      <p>刚回公司，忙着敲代码，公司进行了一次名字变更，虽然我们都不喜欢，但还是给改了，变成了“花生有信”。现在看看这个名字也不是那么的难听，毕竟公司的主营业务不再是水果了，换个名字也可以让公司不那么局限。<br><img src="https://file.2fun.xyz/11546329527_.pic.jpg"><br>这个月抽空把“情侣账单”的小程序版本开发出来了，同时上线了微信小程序平台，可以通过扫码体验：<br><img src="https://file.2fun.xyz//file/2019/01/cc5ec5e7ebf44202ab9a73de3ea99a1f_gh_1ad934cdc059_258.jpg" alt="情侣账单小程序码"></p>        <h3 id="四月"   >          <a href="#四月" class="heading-link"><i class="fas fa-link"></i></a><a href="#四月" class="headerlink" title="四月"></a>四月</h3>      <p>因为之前租的房间不能做饭，所以一直想要一个可以做饭的屋子，便和于冲他们在西湖文化广场合租了一个两室一厅的房子。刚搬进来，看到那些年代感的家具，有一种回家的感觉，不过很快就不这么想了，因为房间太旧了，老是出各种问题。尽管家具装修破旧，但是住在那里还是很自在开心的。<br><img src="https://file.2fun.xyz/31546331064_.pic.jpg"></p>        <h3 id="五月"   >          <a href="#五月" class="heading-link"><i class="fas fa-link"></i></a><a href="#五月" class="headerlink" title="五月"></a>五月</h3>      <p>很久么有联系的高中同学，来杭州玩，我们一起去吃了火锅，逛西湖。久别重逢，仍有说不完的话题。<br><img src="https://file.2fun.xyz/11546330362_.pic.jpg"></p>        <h3 id="六月"   >          <a href="#六月" class="heading-link"><i class="fas fa-link"></i></a><a href="#六月" class="headerlink" title="六月"></a>六月</h3>      <p>梁爽一直想去乌镇，本来准备在乌镇戏剧节的时候去，可计划赶不上变化，刚好现在有时间，就定下了去乌镇的票，还特地买了一个拍立得。虽曾是在乌镇呆过一段时间，去了之后才发现对乌镇一点印象也没了，拿着地图一个区域一个区域的逛，饿了就买点小吃，开心就拍拍照。晚上还特自信的告诉她一定要去“似水年华”酒吧，过去发现没有开门，在门口的摇椅上做了一会就走了，后来才知道去错了地方，也是尴尬。<br><img src="https://file.2fun.xyz/21546330578_.pic_hd.jpg"></p>        <h3 id="七月"   >          <a href="#七月" class="heading-link"><i class="fas fa-link"></i></a><a href="#七月" class="headerlink" title="七月"></a>七月</h3>      <p>来公司有十个月了，一直没有薪水变动，便和龙哥提了加薪的事，龙哥说尽量帮我，不过结果很可惜，被老板否了？但是龙哥承诺年底会给我加薪，这也成了我新的工作动力。</p>        <h3 id="八月"   >          <a href="#八月" class="heading-link"><i class="fas fa-link"></i></a><a href="#八月" class="headerlink" title="八月"></a>八月</h3>      <p>八月刚好是爷爷八十大寿的时间，我请了一周的假回重庆拜寿。家里的亲人都从外地回来，周围的街里乡亲前来祝寿，好不热闹！<br><img src="https://file.2fun.xyz/81546333087_.pic.jpg"></p>        <h3 id="九月"   >          <a href="#九月" class="heading-link"><i class="fas fa-link"></i></a><a href="#九月" class="headerlink" title="九月"></a>九月</h3>      <p>王老师来杭州参加一个活动，至从上次上海一别，如今有一年多的时间了。做为我大学最爱的一名老师，无论如何都是要见一面的。本想是能一起去什么地方逛一下，聊聊天，无奈上班不同上学，最后只能下午两点请了一个假。一起在火车东站等火车的时候见了一面，只请王老师喝了杯茶，吃了点鸡排，心里有些愧疚。他说他在筹备自己的电影，真心希望他的电影大卖！<br><img src="https://file.2fun.xyz/41546331334_.pic.jpg"></p>        <h3 id="十月"   >          <a href="#十月" class="heading-link"><i class="fas fa-link"></i></a><a href="#十月" class="headerlink" title="十月"></a>十月</h3>      <p>毕业以后，大学同学里除了宇哥、柯阳和韬哥其他就很少联系了。国庆的前两天，博文说想去南京玩，刚好我一个人在杭州也没事，便答应了他一起去南京。南京之旅很有意思，南京的地名也让我大开眼界，感觉像是在游戏世界一般。南京玩的时候刚好遇到了另外一个大学同学吴雅静，之前都是很好的朋友，难的有机会见面，一起去吃了南京的特色肚皮面。<br><img src="https://file.2fun.xyz/51546331431_.pic.jpg"><br>去南京的时候刚好遇到”森林音乐节”，认识了一位很酷的歌手——“郭顶”，现在他的《水星记》成为了我的单曲循环必选歌曲。<br><img   src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1548238547&di=e07e8bd2e472bb8524e1a468b94460ad&imgtype=jpg&er=1&src=http://i1.hdslb.com/bfs/archive/ab5905dd24ab44eee19c79b5d98645108ce4522c.jpg" style="width: b9999_10000px;" ></p>        <h3 id="十一月"   >          <a href="#十一月" class="heading-link"><i class="fas fa-link"></i></a><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h3>      <p>以前一直想要买一台MacBookPro，看了价格又只能望而却步。那段时间，特别想要做独立游戏玩，想着是时候买一台了，刚好赶上双十一优惠。也是神奇，至从买了电脑之后，游戏就很少玩了，没事就想着写点策划或者代码。梁爽以前一直反对我买，之后只是说我上进了。<br><img src="https://file.2fun.xyz/51546332810_.pic.jpg"></p>        <h3 id="十二月"   >          <a href="#十二月" class="heading-link"><i class="fas fa-link"></i></a><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h3>      <p>龙哥的许诺遥遥无期，在公司的存在感也越来越低。十二月初，想着要不换一家公司，就试着投了几个简历。最后接到了“支付宝”的面试邀请，同时通过了面试。虽然工资很可观，但，思前想后觉得技术支持与我喜欢的工作内容不太匹配，就拒绝了。十二月底，我转岗了Java后端开发，一是因为觉得自己需要学习一些后端的知识，二是因为公司Android开发的需求降低。但是这个过程并不是很顺利，本以为都是使用Java编码理解起来回很容易，结果搭建开发环境就头炸，所以把过程记录下来了，以免日后忘记。<br><img src="https://file.2fun.xyz/screen2019-01-014.44.22.png"></p>        <h3 id="END"   >          <a href="#END" class="heading-link"><i class="fas fa-link"></i></a><a href="#END" class="headerlink" title="END"></a>END</h3>      <p>2018年发生了很多事，无论开心还是难过都已成为了过去，新的一年，希望自己可以把年前立的flag <em>开发一款独立游戏</em><br>做了。之前说过做很多事情，最后都不了了之，今年， <strong>切记一定要坚守计划！</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在SpringMvc中集成Mybatis</title>
      <link href="2018/12/27/%E5%9C%A8SpringMvc%E4%B8%AD%E9%9B%86%E6%88%90Mybatis/"/>
      <url>2018/12/27/%E5%9C%A8SpringMvc%E4%B8%AD%E9%9B%86%E6%88%90Mybatis/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/932056-20170403015857113-916302220.png"><br>Mybatis的详细功能这里不做描述，只讲怎么将Mybatis集成到SpringMvc里面。通过Mybatis我们可以方便的进行数据交互。</p>        <h3 id="1-添加依赖"   >          <a href="#1-添加依赖" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3>      <p>首先我们添加Mybatis的依赖，打开<code>pom.xml</code>在<code>properties</code>添加依赖的版本参数：</p><pre><code>    &lt;properties&gt;</code></pre><span id="more"></span><pre><code>        &lt;mybatis.spring.version&gt;1.2.5&lt;/mybatis.spring.version&gt;        &lt;mybatis.generator.version&gt;1.3.2&lt;/mybatis.generator.version&gt;        &lt;mysql.version&gt;5.1.38&lt;/mysql.version&gt;    &lt;/properties&gt;</code></pre><p>然后在<code>dependencies</code>里面添加如下代码:</p><pre><code>        &lt;!--mybatis start--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis.spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mybatis end--&gt;        &lt;!--mybatis-generator--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis.generator.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>其中<code>mybatis-generator</code>是一个自动生成mybatis文件的插件。还需要在<code>plugins</code>里面添加插件的信息：</p><pre><code>&lt;!--MBG--&gt;&lt;plugin&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;$&#123;mybatis.generator.version&#125;&lt;/version&gt;    &lt;configuration&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;    &lt;/configuration&gt;   &lt;/plugin&gt;</code></pre>        <h3 id="2-配置自动加载ApplicationContext"   >          <a href="#2-配置自动加载ApplicationContext" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-配置自动加载ApplicationContext" class="headerlink" title="2.配置自动加载ApplicationContext"></a>2.配置自动加载ApplicationContext</h3>      <p>打开<code>web.xml</code>，修改为：</p><pre><code>&lt;!DOCTYPE web-app PUBLIC        &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;        &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;&gt;    &lt;display-name&gt;Hello&lt;/display-name&gt;    &lt;!--ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。--&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!--配置applicationContext--&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;!--下面目录下的xml文件会自动加载--&gt;        &lt;param-value&gt;classpath:spring/*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!--配置servlet处理请求--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--自定义servlet配置文件地址--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;!--classpath:指向的是resources文件夹--&gt;            &lt;param-value&gt;classpath:spring/Hello-Servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;        &lt;!--/表示任何形式的请求都可以通过，可以设置为.do表示后缀为.do的接口才可以访问--&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre>        <h3 id="3-配置Mybatis"   >          <a href="#3-配置Mybatis" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-配置Mybatis" class="headerlink" title="3.配置Mybatis"></a>3.配置Mybatis</h3>      <p>在<code>resources</code>下面创建<code>mapper</code>文件夹，作为mybatis的mapper文件夹。配置mybatis先把mybatis和mybatis-<br>generator需要使用到的参数配置到一个单独的文件,然后再调用这个文件的值方便后期修改。</p><ul><li><p>a.创建<code>mybatis.properties</code> 在<code>resources</code>文件夹下面创建一个文件<code>mybatis.properties</code>，将数据库和mybatis-generator需要的参数加进去，如下：</p><p>#jdbc<br>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://192.168.2.199:3306/ming?characterEncoding=utf-8&amp;&amp;useUnicode=true&amp;&amp;zeroDateTimeBehavior=convertToNull<br>jdbc.username=lingsir<br>jdbc.password=123qwe<br>#mybatis-generator的相关配置<br>mybatis.targetProject=src/main/java<br>mybatis.modelPackage=com.bearever.model.entities<br>mybatis.daoMapperPackage=com.bearever.dao<br>mybatis.targetMapperProject=src/main/resources<br>mybatis.sqlMapperPackage=mapper</p></li><li><p>b.创建<code>mybatis-spring.xml</code> 这个文件的作用是引入mybatis的配置，名字无所谓，只要放入web.xml定义的<code>contextConfigLocation</code>文件夹下面就行了，通过<code>ContextLoaderListener</code>可以自动加载目录下的xml文件。</p><?xml version="1.0" encoding="UTF-8"?><p>&lt;beans xmlns=”<span class="exturl"><a class="exturl__link"   href="http://www.springframework.org/schema/beans&quot;" >http://www.springframework.org/schema/beans&quot;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><pre><code>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/tx   http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;context:property-placeholder location=&quot;classpath:mybatis.properties&quot;/&gt;&lt;!--jdbc配置--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置Mybatis的文件 ，mapperLocations配置**Mapper.xml文件位置，configLocation配置mybatis-config文件位置--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;    &lt;!-- 引入mybatis configuration的相关配置 --&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatisConfig.xml&quot;/&gt;&lt;/bean&gt;&lt;!-- 自动扫描了所有的XxxxMapper.xml对应的mapper接口文件，这样就不用一个一个手动配置Mpper的映射了，只要Mapper接口类和Mapper映射文件对应起来就可以了 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;!-- 这里需要注意，必须写入映射文件的目录 --&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.bearever.dao&quot;/&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;&lt;!-- 事物管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></pre></beans></li><li><p>c.创建<code>mybatisConfig.xml</code> 在web.xml定义的<code>contextConfigLocation</code>文件夹下面创建<code>mybatisConfig.xml</code>,在开发中会遇到需要切换数据库环境,可以通过<code>environments</code>配置。</p><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"><configuration>    <properties resource="mybatis/mybatis.properties"/>    <environments default="development">        <environment id="development">            <transactionManager type="JDBC"/>            <dataSource type="POOLED">                <property name="driver" value="${jdbc.drive}"/>                <property name="url" value="${jdbc.url}"/>                <property name="username" value="${jdbc.username}"/>                <property name="password" value="${jdbc.password}"/>            </dataSource>        </environment>    </environments></configuration></li></ul>        <h3 id="4-配置mybatis-generator"   >          <a href="#4-配置mybatis-generator" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-配置mybatis-generator" class="headerlink" title="4.配置mybatis-generator"></a>4.配置mybatis-generator</h3>      <p>通过Mybatis-<br>Generator自动生成mybatis的mapper等文件，在<code>resources</code>创建<code>generatorConfig.xml</code>文件，如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;properties resource=&quot;mybatis.properties&quot;/&gt;    &lt;!--mysql-connector的位置--&gt;    &lt;classPathEntry            location=&quot;C:\Users\luomi\.m2\repository\mysql\mysql-connector-java\5.1.38\mysql-connector-java-5.1.38.jar&quot;/&gt;    &lt;context id=&quot;mybatis&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;!-- 防止生成的代码中有很多注释--&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库--&gt;        &lt;jdbcConnection driverClass=&quot;$&#123;jdbc.driver&#125;&quot;                        connectionURL=&quot;$&#123;jdbc.url&#125;&quot;                        userId=&quot;$&#123;jdbc.username&#125;&quot;                        password=&quot;$&#123;jdbc.password&#125;&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!--Java类型解析器不应该强制型对象字段BigDecimal的使用，此功能是为了使数据库DECIMAL和NUMERIC列容易处理--&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;!--生成Model类存放位置--&gt;        &lt;javaModelGenerator targetPackage=&quot;$&#123;mybatis.modelPackage&#125;&quot; targetProject=&quot;$&#123;mybatis.targetProject&#125;&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;!--生成映射文件存放位置--&gt;        &lt;sqlMapGenerator targetPackage=&quot;$&#123;mybatis.sqlMapperPackage&#125;&quot; targetProject=&quot;$&#123;mybatis.targetMapperProject&#125;&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!--生成Dao类存放位置--&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;$&#123;mybatis.daoMapperPackage&#125;&quot;                             targetProject=&quot;$&#123;mybatis.targetProject&#125;&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;!--生成对应表及类名 ByExample=&quot;false&quot; 不自动生成实例代码--&gt;        &lt;table tableName=&quot;tb_user&quot; domainObjectName=&quot;User&quot;               enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot;               enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;/&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>终端cd到项目目录，执行命令生成mybatis代码和xml,提示<code>BUILD SUCCESS</code>表示配置成功了。</p><pre><code>mvn mybatis-generator:generate</code></pre><p>在代码文件夹里面，会自动生成<code>User</code>、<code>UserMapper</code>和资源文件夹下面的</p>        <h3 id="5-编写Service"   >          <a href="#5-编写Service" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-编写Service" class="headerlink" title="5.编写Service"></a>5.编写Service</h3>      <p>创建<code>UserService</code>接口文件，添加下面的方法：</p><pre><code>public interface UserService &#123;    User findUser(Integer id);&#125;</code></pre><p>实现接口方法，创建<code>UserServiceIml</code>文件，这里需要注意<code>@Service</code>标签，如果不设置<code>value</code>的值会默认将类名首字母小写设置为value，通常我们将他的接口名设置为value。</p><pre><code>@Service(value = &quot;userService&quot;)public class UserServiceIml implements UserService &#123;    @Autowired    private UserMapper userMapper;    @Override    public User findUser(Integer id) &#123;        User user = userMapper.selectByPrimaryKey(id);        if (user == null) &#123;            return new User();        &#125;        return user;    &#125;&#125;</code></pre>        <h3 id="6-编写Controller"   >          <a href="#6-编写Controller" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-编写Controller" class="headerlink" title="6.编写Controller"></a>6.编写Controller</h3>      <p>在<code>Controller</code>里面增加Service引用，通过<code>UserMapper</code>来操作数据库。</p><pre><code>@Controllerpublic class HelloController &#123;    @Autowired    private UserService userService;    @ResponseBody    @RequestMapping(value = &quot;s&quot;, method = RequestMethod.GET)    public ResponseEntity&lt;User&gt; s(@RequestParam(value = &quot;id&quot;, defaultValue = &quot;&quot;) String id) &#123;        if (StringUtils.isEmpty(id)) &#123;            return new ResponseEntity&lt;&gt;(new User(), HttpStatus.OK);        &#125;        Integer uid = Integer.parseInt(id);        User user = this.userService.findUser(uid);        return new ResponseEntity&lt;&gt;(user, HttpStatus.OK);    &#125;&#125;</code></pre>        <h3 id="7-运行"   >          <a href="#7-运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-运行" class="headerlink" title="7.运行"></a>7.运行</h3>      <p>运行项目，打开<code>http://localhost:8085/jump_war/s?id=1</code>，如果你在数据库里面添加了user的表，并且增加了数据，就会看到如下的页面：<br><img src="https://file.2fun.xyz/spring_20181227204113.png"> <strong>Enjoy It</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc返回值中文乱码</title>
      <link href="2018/12/27/SpringMvc%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>2018/12/27/SpringMvc%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>通过<a href="https://www.bearever.cn/server/springmvc-start/" title="SpringMvc搭建">SpringMvc简单搭建</a>完成之后，我们尝试输出中文，结果显示的却是<code>???</code>，下面是解决输出文本乱码的方法。<br>编辑<code>sevlet</code>文件，将<code>mvc:annotation-driven</code>修改为：</p><pre><code>    &lt;!--打开注解扫描--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters&gt;</code></pre><span id="more"></span><pre><code>            &lt;!--解决返回值有中文会乱码的情况--&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot;/&gt;            &lt;/bean&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc配置</title>
      <link href="2018/12/27/SpringMvc%E9%85%8D%E7%BD%AE/"/>
      <url>2018/12/27/SpringMvc%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/spring20181212121212.jpg"><br>Android转Java的第一天，感觉自己什么都不会，仿佛又回到了第一次写Android代码的时候，连个项目都不会创建。因为我们公司使用的SpringMvc的项目架构方式，所以我的第一个任务就是搭建一个SpringMvc的项目。由于其中需要注意的地方太多了，担心自己过一段时间回来就会忘记，所以把具体的步骤纪录下来，供日后查阅。</p>        <h3 id="1-IntelliJ-IDE"   >          <a href="#1-IntelliJ-IDE" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-IntelliJ-IDE" class="headerlink" title="1.IntelliJ IDE"></a>1.IntelliJ IDE</h3>      <p>一开始我下载的社区版的IntelliJ，发现项目中没有Spring的选项，看网上的教程都可以直接点击Spring创建项目，后来才知道<br><strong>需要下载完整版的IDE</strong> ，破解的方式就不写了，可自行百度。</p>        <h3 id="2-创建Maven工程"   >          <a href="#2-创建Maven工程" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-创建Maven工程" class="headerlink" title="2.创建Maven工程"></a>2.创建Maven工程</h3>      <span id="more"></span><p>我们可以直接使用IDE创建SpringMvc的工程，但是由于目录结构与网络教程差异过大，新人表示看不懂，所以选择了创建Maven工程。大多数的Spring项目都是使用Maven构建的，通过它可以方便的实现依赖管理。很多有用的插件也在maven的仓库可以找到。<br><strong>NEW Project</strong> 的时候找到 <strong>Maven</strong> 打开 <strong>Create from archetype</strong> 选择后缀为 <strong>webapp</strong><br>的方式创建项目。 点击 <strong>Next</strong> ，填写goupId等信息就可以打开项目了。<br><img src="https://file.2fun.xyz/spring_20181227144525.png"></p>        <h3 id="3-添加依赖"   >          <a href="#3-添加依赖" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-添加依赖" class="headerlink" title="3.添加依赖"></a>3.添加依赖</h3>      <p>打开<code>pom.xml</code>文件，可以在<code>properties</code>标签里面定义参数，下面的<code>dependencies</code>就可以直接使用了，这样便于版本管理。例如</p><pre><code>&lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;         &lt;!--这是spring的版本号--&gt;        &lt;spring.version&gt;4.3.18.RELEASE&lt;/spring.version&gt;        &lt;jackson.version&gt;2.9.7&lt;/jackson.version&gt;&lt;/properties&gt;</code></pre><p>插入springmvc的依赖</p><pre><code>&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.11&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--json转换的库--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>依赖添加完毕之后，鼠标右键选择<code>Maven-&gt;Reimport</code>就可以将依赖导入项目了。</p>        <h3 id="4-设置文件夹"   >          <a href="#4-设置文件夹" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-设置文件夹" class="headerlink" title="4.设置文件夹"></a>4.设置文件夹</h3>      <p>在<code>src/main</code>目录下面创建两个文件夹<code>java</code>和<code>resources</code>分别作为代码文件夹和资源文件夹。鼠标选中<code>java</code>文件夹，右键执行<code>Make Directory as -&gt;Sources Root</code>；鼠标选中<code>resources</code>文件夹，鼠标右键执行<code>Make Directory as -&gt;Resources Root</code></p>        <h3 id="5-配置web-xml"   >          <a href="#5-配置web-xml" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-配置web-xml" class="headerlink" title="5.配置web.xml"></a>5.配置web.xml</h3>      <p>打开<code>webapp/WEB-INF/web.xml</code>文件配置springMvc。 首先需要添加<code>servlet</code>,在<code>web-app</code>标签内加入如下代码</p><pre><code>    &lt;!--配置servlet处理请求--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--自定义servlet配置文件地址--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;!--classpath:指向的是resources文件夹--&gt;            &lt;param-value&gt;classpath:config/Hello-Servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;Hello&lt;/servlet-name&gt;        &lt;!--/表示任何形式的请求都可以通过，可以设置为.do表示后缀为.do的接口才可以访问--&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><p>打开<code>classpath:config/Hello-Servlet.xml</code>文件，继续配置SpringMvc</p><pre><code>    &lt;!--打开注解扫描--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--注解扫描的位置--&gt;    &lt;context:component-scan base-package=&quot;com.demo&quot;/&gt;    &lt;!--配置view资源的生成器，在prefix文件夹寻找后缀为suffix的文件--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!--寻找jsp文件的路径--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;</code></pre>        <h3 id="6-编写hello-jsp"   >          <a href="#6-编写hello-jsp" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-编写hello-jsp" class="headerlink" title="6.编写hello.jsp"></a>6.编写hello.jsp</h3>      <p>在<code>webapp/WEB-INF/pages</code>下面创建文件<code>hello.jsp</code>,之所以在这个目录是因为我们在<code>/Hello- Servlet.xml</code>里面配置了InternalResourceViewResolver的路径为<code>/WEB-INF/pages/</code>。</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Jsp Page&lt;/body&gt;&lt;/html&gt;</code></pre>        <h3 id="7-编写Controller"   >          <a href="#7-编写Controller" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-编写Controller" class="headerlink" title="7.编写Controller"></a>7.编写Controller</h3>      <p>在<code>com.demo</code>（这个目录取决于你定义的项目goupId）目录下面创建一个<code>HelloController</code>：</p><pre><code>@Controllerpublic class HelloController &#123;    @RequestMapping(value = &quot;helloPage&quot;, method = RequestMethod.GET)    public String helloPage() &#123;        //返回名字为hello.jsp的view        return &quot;hello&quot;;    &#125;    //ResponseBody注解说明返回的不是一个view，而是数据，RequestMapping注解指定接口访问的url地址    @ResponseBody    @RequestMapping(value = &quot;hello&quot;, method = RequestMethod.GET)    public String hello() &#123;        return &quot;Nice to meet U&quot;;    &#125;&#125;</code></pre>        <h3 id="8-运行"   >          <a href="#8-运行" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-运行" class="headerlink" title="8.运行"></a>8.运行</h3>      <p>在IDE的右上角，点击<code>Add Configuration</code>,然后点击做上角的加号，新建一个tomcat服务<br><img src="https://file.2fun.xyz/spring_20181227152642.png"> 提示 <strong>Warning: No<br>artifacts marked for deployment</strong> ,我们点击右边的<code>Fix</code>按钮，选择一个war包，点击<code>Ok</code>就可以了。<br>现在我们运行工程，编译完成之后会默认打开网页，可以看到“Hello World”的默认页面。<br>打开<code>http://localhost:8085/hello_war/helloPage</code>，效果如下：<br><img src="https://file.2fun.xyz/spring_20181227155753.png"><br>打开<code>http://localhost:8085/hello_war/hello</code>，效果如下：<br><img src="https://file.2fun.xyz/spring_20181227155953.png"> 至此简单的SpringMvc就搭建完毕了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AndroidLint使用</title>
      <link href="2018/12/05/AndroidLint%E4%BD%BF%E7%94%A8/"/>
      <url>2018/12/05/AndroidLint%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[        <h3 id="Android-Lint-说明"   >          <a href="#Android-Lint-说明" class="heading-link"><i class="fas fa-link"></i></a><a href="#Android-Lint-说明" class="headerlink" title="Android Lint 说明"></a>Android Lint 说明</h3>      <p>使用lint可以帮助我们找到编码的问题，然后方便解决问题提高代码的稳定性。</p>        <h3 id="命令行调用"   >          <a href="#命令行调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#命令行调用" class="headerlink" title="命令行调用"></a>命令行调用</h3>      <p>在命令行中可调用gradle执行Task，例如在命令行中调用gradle<br>lint即可执行lint任务。对于某个具体的BuildType（例如Debug）和ProductFlavor（例如Huawei），还可以执行gradle<br>lintHuaweiDebug只对这种Build版本做Lint检查。</p><span id="more"></span>        <h3 id="Lint报告"   >          <a href="#Lint报告" class="heading-link"><i class="fas fa-link"></i></a><a href="#Lint报告" class="headerlink" title="Lint报告"></a>Lint报告</h3>      <p>Lint默认会把所有结果以XML和HTML格式，输出到build/reports/lint-results-<br>xxx中，可以在此查看所有Lint问题，包括具体在哪一行，以及Lint问题对应的ID。</p>        <h3 id="常见命令"   >          <a href="#常见命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3>      <p>Android的Gradle环境下，有下面几个常见的Task。</p><ul><li><p>assemble：Gradle内建的编译任务</p></li><li><p>check：Gradle内建的检查任务</p></li><li><p>test：Gradle内建的测试任务</p></li><li><p>build：包含assemble、check、test</p></li><li><p>lint：Android插件定义的Lint检查任务，被包含到check任务中</p></li></ul>        <h3 id="Gradle配置"   >          <a href="#Gradle配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gradle配置" class="headerlink" title="Gradle配置"></a>Gradle配置</h3>      <pre><code>android &#123;    lintOptions &#123;        // 设置为 true，则当 Lint 发现错误时停止 Gradle 构建        abortOnError false        // 设置为 true，则当有错误时会显示文件的全路径或绝对路径 (默认情况下为true)        absolutePaths true        // 仅检查指定的问题（根据 id 指定）        check &#39;NewApi&#39;, &#39;InlinedApi&#39;        // 设置为 true 则检查所有的问题，包括默认不检查问题        checkAllWarnings true        // 设置为 true 后，release 构建都会以 Fatal 的设置来运行 Lint。        // 如果构建时发现了致命（Fatal）的问题，会中止构建（具体由 abortOnError 控制）        checkReleaseBuilds true        // 不检查指定的问题（根据问题 id 指定）        disable &#39;TypographyFractions&#39;,&#39;TypographyQuotes&#39;        // 检查指定的问题（根据 id 指定）        enable &#39;RtlHardcoded&#39;,&#39;RtlCompat&#39;, &#39;RtlEnabled&#39;        // 在报告中是否返回对应的 Lint 说明        explainIssues true        // 写入报告的路径，默认为构建目录下的 lint-results.html        htmlOutput file(&quot;lint-report.html&quot;)        // 设置为 true 则会生成一个 HTML 格式的报告        htmlReport true        // 设置为 true 则只报告错误        ignoreWarnings true        // 重新指定 Lint 规则配置文件        lintConfig file(&quot;default-lint.xml&quot;)        // 设置为 true 则错误报告中不包括源代码的行号        noLines true        // 设置为 true 时 Lint 将不报告分析的进度        quiet true        // 覆盖 Lint 规则的严重程度，例如：        severityOverrides [&quot;MissingTranslation&quot;: LintOptions.SEVERITY_WARNING]        // 设置为 true 则显示一个问题所在的所有地方，而不会截短列表        showAll true        // 配置写入输出结果的位置，格式可以是文件或 stdout        textOutput &#39;stdout&#39;        // 设置为 true，则生成纯文本报告（默认为 false）        textReport false        // 设置为 true，则会把所有警告视为错误处理        warningsAsErrors true        // 写入检查报告的文件（不指定默认为 lint-results.xml）        xmlOutput file(&quot;lint-report.xml&quot;)        // 设置为 true 则会生成一个 XML 报告        xmlReport false        // 将指定问题（根据 id 指定）的严重级别（severity）设置为 Fatal        fatal &#39;NewApi&#39;, &#39;InlineApi&#39;        // 将指定问题（根据 id 指定）的严重级别（severity）设置为 Error        error &#39;Wakelock&#39;, &#39;TextViewEdits&#39;        // 将指定问题（根据 id 指定）的严重级别（severity）设置为 Warning        warning &#39;ResourceAsColor&#39;        // 将指定问题（根据 id 指定）的严重级别（severity）设置为 ignore        ignore &#39;TypographyQuotes&#39;    &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins+Android打包实践</title>
      <link href="2018/12/04/Jenkins+Android%E6%89%93%E5%8C%85%E5%AE%9E%E8%B7%B5/"/>
      <url>2018/12/04/Jenkins+Android%E6%89%93%E5%8C%85%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[        <h3 id="缘由"   >          <a href="#缘由" class="heading-link"><i class="fas fa-link"></i></a><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3>      <p>由于Android项目代码和模块的增加，每次打包需要花费很长的时间，有时候只改了几行代码重新打个包就的等待半个小时，然后啥也干不了，实在是浪费时间，于是决定研究自动化打包，目前Jenkins是使用的比较多的项目构建工具，可以轻松（才怪）实现Android的打包工作。</p>        <h3 id="准备"   >          <a href="#准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#准备" class="headerlink" title="准备"></a>准备</h3>      <p>需要下载Jenkins到你的计算机或者服务器，并且启动服务，这里不重点讲解，可以自行百度。纪录下可能使用到的Jenkins服务命令（windows平台）：<br>- 启动 <code>net start jenkins</code>，这行命令是针对已经配置好了Jenkins服务，并且启动过一次。电脑重启了，需要重新启动服务的情况，注意可能需要管理员权限。</p><span id="more"></span><ul><li><p>停止 <code>net stop jenkins</code></p></li><li><p>重新启动 浏览器输入<code>http://localhost:8080/restart</code></p></li></ul>        <h3 id="安装插件"   >          <a href="#安装插件" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3>      <p>进行Android项目的构建，必须要安装的插件有：<code>Gradle</code>，如果你希望能看到代码编写的问题，还可以安装<code>Android Lint</code>。</p>        <h3 id="Android-Job"   >          <a href="#Android-Job" class="heading-link"><i class="fas fa-link"></i></a><a href="#Android-Job" class="headerlink" title="Android Job"></a>Android Job</h3>      <p>进入Jenkins网站，默认是<code>http://localhost:8080/</code>,点击新建任务，选择 <strong>构建一个自由风格的软件项目</strong> 。<br>在新的页面里面你可以添加一些项目描述，方便识别。</p>        <h4 id="源码管理"   >          <a href="#源码管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4>      <p>在 <strong>源码管理</strong> 栏目，具体配置根据你的实际情况选择即可，例如我的代码保存在subversion的，所以选择 <strong>subversion</strong> ，<br><strong>Repository URL</strong> 填入你的代码在svn的地址。然后点击右边的小钥匙按钮 <em>Add</em> 添加的你的svn账号</p>        <h4 id="构建"   >          <a href="#构建" class="heading-link"><i class="fas fa-link"></i></a><a href="#构建" class="headerlink" title="构建"></a>构建</h4>      <p><img src="https://file.2fun.xyz/wx_20181204140349.png" alt="invoke gradle script"> 选择<br><strong>invoke gradle script</strong> ，在新的面板 <strong>Tasks</strong> 里面填写<code>clean assembleRelease</code>表示先执行clean任务，然后编译所有的release包。<br>通常情况下，这样的配置就可以完成一个简单Android项目的编译了，但是！！！，有些项目的根目录下面没有<code>build.gradle</code>,可能在某个子目录下，这就需要配置目录了。我们展开<br><strong>高级</strong> 按钮，在 <strong>Root Build script</strong><br>里面填入主工程的目录，这里填写的是相对路径，例如你的项目在跟目录下的<code>LSX</code>文件夹,那你填入<code>LSX</code>即可。</p>        <h4 id="巨大的坑"   >          <a href="#巨大的坑" class="heading-link"><i class="fas fa-link"></i></a><a href="#巨大的坑" class="headerlink" title="巨大的坑"></a>巨大的坑</h4>      <p>这里还有一个 <strong>深坑</strong> ！在windows系统里面，编译可能会报一个png格式不对的问题，但是这个png文件根本不是你的项目里面的，可能是Android<br>Support包里面的。这个问题的原因是gradle编译的缓存文件路径名太长了，所以会报这个错误。解决办法是修改缓存地址。这里可以修改主项目目录下面的<code>gradle.properties</code>添加一行代码</p><pre><code>android.buildCacheDir = 你希望的缓存地址</code></pre><p>但是这种写法不便于本地编码，因为如果你的Jenkins不是安装在自己的电脑上的，就会出现缓存地址不存在的问题。这里可以利用Gradle的一个功能，在命令行传入参数,规则是<code>-PK=V</code>，上面的参数就变成了</p><pre><code>-Pandroid.buildCacheDir=&quot;你希望的缓存地址&quot;</code></pre><p><img src="https://file.2fun.xyz/wx_20181204143935.png" alt="gradle script 配置"> （<br><em>这个问题折腾了我一个下午，没想到就一句话说完了</em> ）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>上传aar到maven服务器</title>
      <link href="2018/12/04/%E4%B8%8A%E4%BC%A0aar%E5%88%B0maven%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>2018/12/04/%E4%B8%8A%E4%BC%A0aar%E5%88%B0maven%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>通过maven私服搭建教程，我们成功的搭建了自己的maven服务器，接下来，我们可以把Android项目的模块打包成aar包，可以提高编译速度，也可以减少编程时不小心把代码修改的了问题。</p>        <h3 id="配置上传"   >          <a href="#配置上传" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置上传" class="headerlink" title="配置上传"></a>配置上传</h3>      <ul><li><p>Release 使用Gradle可以非常方便的打包aar并上传，打开模块所在的目录下的<code>build.gradle</code>文件，顶部添加如下代码：</p><p>apply plugin: ‘com.android.library’<br>apply plugin: ‘maven’</p></li></ul><span id="more"></span><pre><code>group &#39;android.cn.bearever&#39; //分组，相当于文件夹version &#39;1.0.1&#39; //版本号</code></pre><p><code>appply plugin: &#39;xxx&#39;</code>表示的是需要引用插件xxx，这里的<code>com.android.library</code>表示需要引用Android库的插件，因为我们需要打包的是一个Android的aar包。下面的<code>maven</code>表示需要引用Maven的插件，这样我们就可以上传到自己的maven服务器了。<br><code>group &#39;android.cn.bear&#39;</code>表示的是这个文件在maven服务器的文件目录，<code>version &#39;1.0.1&#39;</code>就表示这个库的版本是“1.0.1”。 下面我们开始配置上传到maven服务器，在文件的最底部添加如下代码：</p><pre><code>uploadArchives &#123;    repositories &#123;        mavenDeployer &#123;            //release包            repository(url: &#39;http://localhost:8081/nexus/content/repositories/releases&#39;) &#123;                authentication(userName: &#39;admin&#39;, password: &#39;admin123&#39;)            &#125;            //快照            snapshotRepository(url: &#39;http://localhost:8081/nexus/content/repositories/snapshots&#39;) &#123;                authentication(userName: &#39;admin&#39;, password: &#39;admin123&#39;)            &#125;            pom.artifactId = &#39;mylib&#39; //库名字            pom.packaging = &#39;aar&#39; //文件类型        &#125;    &#125;&#125;</code></pre><p>这里的<code>uploadArchives</code>就是上传aar包的Task，<code>mavenDeployer</code>表示这是发布到maven的，<code>repository和snapshotRepository</code>分别表示正式包和快照包的配置。<br><code>url</code>是maven服务器的地址，可以在maven服务器里面查看 <img src="https://file.2fun.xyz/wx_20181204113742.png" alt="maven-summary"><br><code>authentication(userName: &#39;admin&#39;, password: &#39;admin123&#39;)</code>就是maven的登录账号。<br><code>pom.artifactId</code>表示的是这个库的名字，<code>pom.packaging</code>表示的是库的文件格式。<br>最后整个<code>build.gradle</code>文件格式大概如下</p><pre><code>apply plugin: &#39;com.android.library&#39;apply plugin: &#39;maven&#39;group &#39;android.cn.bearever&#39; //分组，相当于文件夹version &#39;1.0.1&#39; //版本号android&#123;&#125;dependencies&#123;&#125;uploadArchives&#123;&#125;</code></pre><ul><li><p>Snapshot 前面提到还有快照版本的库，那么怎么上传快照版本的库呢？只需要在<code>version</code>里面加上<code>-SNAPSHOT</code>就会上传到快照仓库。例如</p><p>apply plugin: ‘com.android.library’<br>apply plugin: ‘maven’</p><p>group ‘android.cn.bear’ //分组，相当于文件夹<br>version ‘1.0.1-SNAPSHOT’ //版本号,-SNAPSHOT表示这是快照版本<br>….</p></li></ul>        <h3 id="生成aar包上传到maven"   >          <a href="#生成aar包上传到maven" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成aar包上传到maven" class="headerlink" title="生成aar包上传到maven"></a>生成aar包上传到maven</h3>      <p>最后进入模块目录在终端输入<code>gradlew uploadArchives</code>就可以了。或者 <code>gradlew moudleName:uploadArchives</code></p>        <h3 id="引用"   >          <a href="#引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用" class="headerlink" title="引用"></a>引用</h3>      <ul><li><p>Release 首先需要规定仓库的地址，在跟项目的<code>build.gradle</code>里面添加</p><p> repositories {</p><pre><code>    maven &#123;        url &#39;http://localhost:8081/nexus/content/repositories/releases&#39;    &#125;    google()    jcenter()&#125;</code></pre></li></ul><p>在其他模块的<code>build.gradle</code>的<code>dependencies</code>添加依赖引用，例如</p><pre><code>dependencies &#123;    .....其他的依赖引用    implementation &#39;android.cn.bearever:mylib:1.0.1&#39;&#125;</code></pre><p>implementation语法规则<code>implementation &#39;groupId:libname:version&#39;</code></p><ul><li>Snapshot</li></ul><p>那怎么引用<code>snapshot</code>版本的库呢，需要在根项目添加快照的仓库地址。例如</p><pre><code>  repositories &#123;        maven &#123;            url &#39;http://localhost:8081/nexus/content/repositories/releases&#39;        &#125;         maven &#123;            url &#39;http://localhost:8081/nexus/content/repositories/snapshots&#39;        &#125;        google()        jcenter()    &#125;</code></pre><p>引用的时候在版本号后面加上<code>-SNAPSHOT</code>就表示需要引用快照版本,例如：</p><pre><code>implementation &#39;android.cn.bearever:mylib:1.0.1-SNAPSHOT&#39;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle 笔记（一）</title>
      <link href="2018/11/30/Gradle%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2018/11/30/Gradle%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/1_GOm7MTviWJdJm_smWDjBHw.png" alt="gradle"></p>        <h3 id="缘由"   >          <a href="#缘由" class="heading-link"><i class="fas fa-link"></i></a><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3>      <p>在Android的开发中，总遇到需要和Gradle脚本打交道的时候，一开始我觉得这个没啥用没有在意，但是每次打包都需要大半个小时，实在难受，遂决定研究学习下Gradle，这篇文章实我学习中的笔记，供日后参考。</p>        <h3 id="Groovy"   >          <a href="#Groovy" class="heading-link"><i class="fas fa-link"></i></a><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3>      <p>Gradle使用Groovy作为开发语音，而Groovy完全兼容Java语法。 需要注意的点：</p><span id="more"></span>        <h4 id="字符串"   >          <a href="#字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4>      <ul><li><code>&#39;&#39;</code>单引号 表示一段不可变的字符串，不可以执行字符串内的表达式计算</li><li><code>&quot;&quot;</code>双引号 表示一段可变的字符串，可以使用字符串内的表达式计算，例如<code>&quot;$&#123;rootProject&#125;&quot;</code></li></ul>        <h4 id="Map"   >          <a href="#Map" class="heading-link"><i class="fas fa-link"></i></a><a href="#Map" class="headerlink" title="Map"></a>Map</h4>      <p>在Groovy里面，Map表示的是一个K-V列表，本质是<code>LinkedHashMap</code>，使用方式如下：</p><pre><code>def map = [&#39;width&#39;:1024,&#39;height&#39;:1820]//下面两种方式都可以取值println map[&#39;width&#39;]println map.height</code></pre>        <h4 id="方法"   >          <a href="#方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法" class="headerlink" title="方法"></a>方法</h4>      <p>在Groovy中，执行一个方法可以不加括号<code>()</code>，例如方法<code>sum(int a,int b)</code>，调用的时候可以写成<code>sum 1,2</code>结果与<code>sum(1,2)</code>一样</p>        <h4 id="get-set"   >          <a href="#get-set" class="heading-link"><i class="fas fa-link"></i></a><a href="#get-set" class="headerlink" title="get/set"></a>get/set</h4>      <p>Java Bean<br>的设计里面，通过<code>get</code>来获取属性值，在Groovy里面不需要写这些方法，直接通过<code>.</code>就可以读取和设置属性的值。例如我们经常使用的获取项目编译目录文件夹<code>rootProject.buildDir</code>，他的本质也是<code>rootProject.getBuildDir()</code>。<br>对于<code>set</code>设置属性，在groovy里面只需要添加``面就可以跟新的值，例如<code>description &#39;这是描述&#39;</code>，等同于<code>setDescription(&#39;这是描述&#39;)</code>。</p>        <h3 id="Gradle"   >          <a href="#Gradle" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3>      <p>asdasd</p>        <h3 id="断言onlyIf"   >          <a href="#断言onlyIf" class="heading-link"><i class="fas fa-link"></i></a><a href="#断言onlyIf" class="headerlink" title="断言onlyIf"></a>断言onlyIf</h3>      <p><code>onlyIf</code>可以用来控制一个Task是否执行，当返回值为<code>true</code>时表示执行，否则表示不执行。这个效果同<code>enabled</code>属性一样可以控制是否执行，但是<code>onlyIf</code>接收的是一个闭包<code>&#123;&#125;</code>可以在里面添加代码进行判断。例如</p><pre><code>taskTest.onlyIf &#123;    false&#125;</code></pre>        <h4 id="编译参数"   >          <a href="#编译参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h4>      <p>在执行<code>gradlew</code>命令的时候，可以添加一些参数来改变编译环境，例如我们在打包APK的时候，可以设计一个字段<code>buildMarket</code>来表示打包的具体应用市场渠道，在编译的时候通过<code>-PK=V</code>的形式这只属性值，其中<code>K V</code>表示的是key和value。</p>        <h4 id="创建任务"   >          <a href="#创建任务" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4>      <ul><li><p>使用任务名+闭包的形式：</p><p>task name{</p><pre><code>doLast&#123;    doSomething....&#125;</code></pre><p>}</p></li><li><p>任务名的形式</p><p>def Task name = task(name)<br>name.doLast{</p><pre><code>doSomething.....</code></pre><p>}</p></li></ul>        <h4 id="查找任务"   >          <a href="#查找任务" class="heading-link"><i class="fas fa-link"></i></a><a href="#查找任务" class="headerlink" title="查找任务"></a>查找任务</h4>      <p>可以通过<code>tasks</code>找到定义好的任务，例如<code>tasks.findByName(name)</code>或者<code>tasks.findByPath(path)</code>等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shader指南(一)</title>
      <link href="2018/11/21/Shader%E6%8C%87%E5%8D%97(%E4%B8%80)/"/>
      <url>2018/11/21/Shader%E6%8C%87%E5%8D%97(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/2018/11/45333de4dcd2c6c3.jpg" alt="Unity水面Shader"><br>尽管Unity为我们开发游戏提供了很多便利，但是在一些需要特殊画面效果的地方，仍然很复杂，其中Shader就是里面的一大难题。</p>        <h3 id="什么是Shader"   >          <a href="#什么是Shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是Shader" class="headerlink" title="什么是Shader"></a>什么是Shader</h3>      <p>Shader程序：GPU执行的，针对3D对象进行操作的程序。</p>        <h3 id="Shader编程有那几种？"   >          <a href="#Shader编程有那几种？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Shader编程有那几种？" class="headerlink" title="Shader编程有那几种？"></a>Shader编程有那几种？</h3>      <ul><li>CG 与DirectX 9.0 以上以及OpenGL 完全兼容。运行时或事先编译成GPU汇编代码</li></ul><span id="more"></span><ul><li><p>HLSL 主要用于Direct3D。平台：Windows</p></li><li><p>GLSL 主要用于OPenGL。 平台：移动平台（IOS,Android）,Mac(only use when you target Mac OS X or OpenGL ES 2.0)</p></li></ul>        <h3 id="Unity3d-里CG输出什么？"   >          <a href="#Unity3d-里CG输出什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Unity3d-里CG输出什么？" class="headerlink" title="Unity3d 里CG输出什么？"></a>Unity3d 里CG输出什么？</h3>      <ul><li><p>Windows Direct3D,GPU汇编代码</p></li><li><p>Mac OpenGL GPU汇编代码</p></li><li><p>Flash Flash GPU 汇编代码</p></li><li><p>IOS/Android Unity会将CG转换成GLSL代码。</p></li></ul><p>总结： <strong>也就是除了移动平台会把CG转换成GLSL代码，其余平台都是转化成汇编代码。</strong></p>        <h3 id="Unity中自定义的Shader"   >          <a href="#Unity中自定义的Shader" class="heading-link"><i class="fas fa-link"></i></a><a href="#Unity中自定义的Shader" class="headerlink" title="Unity中自定义的Shader:"></a>Unity中自定义的Shader:</h3>      <ul><li><p>Surface Shaders 表面着色器（最常用，比固定功能管线高级）（之前默认创建的shader类型）它是 Vertex and fragment shaders 的包装，让我们可以不用关心这些顶点和片段程序的细节，可以直接得到我们想要的着色器。</p></li><li><p>Vertex and Fragment Shaders 顶点和片元着色器（细节处理，偏底层）</p></li></ul>        <h3 id="CG部分函数列表"   >          <a href="#CG部分函数列表" class="heading-link"><i class="fas fa-link"></i></a><a href="#CG部分函数列表" class="headerlink" title="CG部分函数列表"></a>CG部分函数列表</h3>      <div class="table-container"><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>abs(x)</td><td>返回x的绝对值。对x的每个元素都会独立计算一次。</td></tr><tr><td>acos(x)</td><td>返回x的反余弦值。对x的每个元素都会独立计算一次。</td></tr><tr><td>all(x)</td><td>检测x的所有元数的值是否为0.</td></tr><tr><td>any(x)</td><td>检测x是否有某个元数的值为0.</td></tr><tr><td>asfloat(x)</td><td>将x转换为float类型。</td></tr><tr><td>asin(x)</td><td>返回x的反正弦值。对x的每个元素都会独立计算一次。</td></tr><tr><td>asint(x)</td><td>将x转换为int类型。</td></tr><tr><td>asuint(x)</td><td>将x转换为uint类型。</td></tr><tr><td>atan(x)</td><td>返回x的反正切值。</td></tr><tr><td>atan2(y, x)</td><td>返回y、x的反正切值。</td></tr><tr><td>ceil(x)</td><td>返回大于或等于x的最小整数。</td></tr><tr><td>clamp(x, min, max)</td><td>将x截取在[min, max]范围内。</td></tr><tr><td>clip(x)</td><td>如果x中存在值小于0的参数，则丢弃当前像素。</td></tr><tr><td>cos(x)</td><td>返回x的余弦值。</td></tr><tr><td>cosh(x)</td><td>返回x的双曲余弦值。</td></tr><tr><td>cross(x, y)</td><td>返回x、y的叉积。</td></tr><tr><td>D3DCOLORtoUBYTE4(x)</td><td>混合和缩放4D向量x用于补偿一些对UBYTE4支持的硬件。</td></tr><tr><td>ddx(x)</td><td>返回关于屏幕坐标x轴的偏导数。</td></tr><tr><td>ddy(x)</td><td>返回关于屏幕坐标y轴的偏导数。</td></tr><tr><td>degrees(x)</td><td>将x（弧度）转换到角度。</td></tr><tr><td>determinant(m)</td><td>返回的正方形矩阵m的行列式。</td></tr><tr><td>distance(x, y)</td><td>返回x、y之间的距离。</td></tr><tr><td>dot(x, y)</td><td>返回x、y的点积。</td></tr><tr><td>exp(x)</td><td>返回以e为底数，x为指数的指数函数值。</td></tr><tr><td>exp2(x)</td><td>返回以2为底数，x为指数的指数函数值。对x的每个字段都会计算一次。</td></tr><tr><td>faceforward(n, i, ng)</td><td>检测多边形是否位于正面。-n * sign(•(i, ng))。</td></tr><tr><td>floor(x)</td><td>返回小于等于x的最大整数。</td></tr><tr><td>fmod(x, y)</td><td>返回x/y的浮点余数。</td></tr><tr><td>frac(x)</td><td>返回x的小数部分。</td></tr><tr><td>frexp(x, exp)</td><td>返回x的尾数和指数。</td></tr><tr><td>fwidth(x)</td><td>返回 abs(ddx(x)) + abs(ddy(x))，</td></tr><tr><td>GetRenderTargetSampleCount()</td><td>返回渲染目标采样器的个数。</td></tr><tr><td>GetRenderTargetSamplePosition(x)</td><td>返回关于给定采样器的一个采样点(x,y)。</td></tr><tr><td>isfinite(x)</td><td>如果x为有限值则返回true，否则返回false。</td></tr><tr><td>isinf(x)</td><td>如果x为无限值则返回true，否则返回false。</td></tr><tr><td>isnan(x)</td><td>如果x为NAN或QNAN则返回true，否则返回false。</td></tr><tr><td>ldexp(x, exp)</td><td>frexp的逆运算，返回 x * 2 ^ exp。</td></tr><tr><td>length(v)</td><td>返回v向量的长度。</td></tr><tr><td>lerp(x, y, s)</td><td>对x、y进行插值计算。Returns x + s(y - x)。</td></tr><tr><td>lit(n • l, n • h, m)</td><td>返回光照向量（环境光，漫反射光，镜面高光，1）。</td></tr><tr><td>log(x)</td><td>返回以e为底的对数。</td></tr><tr><td>log10(x)</td><td>返回以10为底的对数。</td></tr><tr><td>log2(x)</td><td>返回以2为底的对数。</td></tr><tr><td>max(x, y)</td><td>返回x、y中较大值。</td></tr><tr><td>min(x, y)</td><td>返回x、y中较小值。</td></tr><tr><td>modf(x, out ip)</td><td>把x分割为整数和小数部分。</td></tr><tr><td>mul(x, y)</td><td>返回x、y矩阵相乘的积。</td></tr><tr><td>noise(x)</td><td>Generates a random value using the Perlin-noise algorithm.</td></tr><tr><td>normalize(x)</td><td>返回单位化向量，定义为 x / length(x)。</td></tr><tr><td>pow(x, y)</td><td>返回x^y。</td></tr><tr><td>radians(x)</td><td>将x（角度）转换到弧度。</td></tr><tr><td>reflect(i, n)</td><td>返回入射光线i对表面法线n的反射光线。</td></tr><tr><td>refract(i, n, R)</td><td>返回在入射光线i，表面法线n，折射率为R下的折射光线。</td></tr><tr><td>round(x)</td><td>返回最接近x的整数。</td></tr><tr><td>rsqrt(x)</td><td>返回x平方根的倒数。 1 / sqrt(x) 。</td></tr><tr><td>saturate(x)</td><td>把x截取在[0, 1]之间。</td></tr><tr><td>sign(x)</td><td>返回x的符号。</td></tr><tr><td>sin(x)</td><td>返回x的正弦值。</td></tr><tr><td>sincos(x, out s, out c)</td><td>返回x的正弦值和余弦值。</td></tr><tr><td>sinh(x)</td><td>返回x的双曲正弦值。</td></tr><tr><td>smoothstep(min, max, x)</td><td>如果x的范围是[min, max]，则返回一个介于0和1之间的Hermite插值。</td></tr><tr><td>sqrt(x)</td><td>返回x的平方根，对x的每个字段都会计算一次。</td></tr><tr><td>step(a, x)</td><td>返回 (x &gt;= a) ? 1 : 0 。</td></tr><tr><td>tan(x)</td><td>返回x的正切值。</td></tr><tr><td>tanh(x)</td><td>返回x的双曲正切值。</td></tr><tr><td>tex1D(s, t)</td><td>返回纹理s在t位置的颜色。1D texture lookup.</td></tr><tr><td>tex1Dbias(s, t)</td><td>使用bias返回纹理s在t位置的颜色。1D texture lookup with bias.</td></tr><tr><td>tex1Dgrad(s, t, ddx, ddy)</td><td>1D texture lookup with a gradient.</td></tr><tr><td>tex1Dlod(s, t)</td><td>使用LOD返回纹理s在t位置的颜色。1D texture lookup with LOD.</td></tr><tr><td>tex1Dproj(s, t)</td><td>使用透视分离返回纹理s在t位置的颜色。</td></tr><tr><td>tex2D(s, t)</td><td>返回纹理s在t位置的颜色。</td></tr><tr><td>tex2Dbias(s, t)</td><td>2D texture lookup with bias.</td></tr><tr><td>tex2Dgrad(s, t, ddx, ddy)</td><td>2D texture lookup with a gradient.</td></tr><tr><td>tex2Dlod(s, t)</td><td>2D texture lookup with LOD.</td></tr><tr><td>tex2Dproj(s, t)</td><td>2D texture lookup with projective divide.</td></tr><tr><td>tex3D(s, t)</td><td>3D texture lookup.</td></tr><tr><td>tex3Dbias(s, t)</td><td>3D texture lookup with bias.</td></tr><tr><td>tex3Dgrad(s, t, ddx, ddy)</td><td>3D texture lookup with a gradient.</td></tr><tr><td>tex3Dlod(s, t)</td><td>3D texture lookup with LOD.</td></tr><tr><td>tex3Dproj(s, t)</td><td>3D texture lookup with projective divide.</td></tr><tr><td>texCUBE(s, t)</td><td>Cube texture lookup.</td></tr><tr><td>texCUBEbias(s, t)</td><td>Cube texture lookup with bias.</td></tr><tr><td>texCUBEgrad(s, t, ddx, ddy)</td><td>Cube texture lookup with a gradient.</td></tr><tr><td>tex3Dlod(s, t)</td><td>Cube texture lookup with LOD.</td></tr><tr><td>texCUBEproj(s, t)</td><td>Cube texture lookup with projective divide.</td></tr><tr><td>transpose(m)</td><td>返回m的转置矩阵。</td></tr><tr><td>trunc(x)</td><td>将x的所有元素从浮点值截断到整数值。</td></tr><tr><td></td><td></td></tr></tbody></table></div>        <h3 id="参考"   >          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h3>      <ul><li><span class="exturl"><a class="exturl__link"   href="http://gad.qq.com/article/detail/38240" >http://gad.qq.com/article/detail/38240</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link"   href="https://www.cnblogs.com/rainstorm/archive/2013/05/04/3057444.html" >https://www.cnblogs.com/rainstorm/archive/2013/05/04/3057444.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link"   href="https://onevcat.com/2013/07/shader-tutorial-1/" >https://onevcat.com/2013/07/shader-tutorial-1/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link"   href="https://onevcat.com/2013/08/shader-tutorial-2/" >https://onevcat.com/2013/08/shader-tutorial-2/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>极光推送接收不到消息</title>
      <link href="2018/09/25/%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E6%B6%88%E6%81%AF/"/>
      <url>2018/09/25/%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>第三方系统收不到推送的消息 由于第三方 ROM 的管理软件需要用户手动操作</p><ul><li><p><strong>小米【 MIUI 】</strong> 自启动管理：需要把应用加到【自启动管理】列表，否则杀进程或重新开机后进程无法开启 通知栏设置：应用默认都是显示通知栏通知，如果关闭，则收到通知也不会提示 网络助手：可以手动禁止已安装的第三方程序访问 2G/3G 和 WIFI 的网络和设置以后新安装程序是否允许访问 2G/3G 和 WIFI 的网络 MIUI 7 神隐模式： 允许应用进行自定义配置模式，应用在后台保持联网可用，否则应用进入后台时，应用无法正常接收消息。【设置】下电量和性能中【神隐模式】</p></li><li><p><strong>华为【 Emotion 】</strong> 自启动管理：需要把应用加到【自启动管理】列表，否则杀进程或重新开机后进程不会开启，只能手动开启应用 后台应用保护：需要手动把应用加到此列表，否则设备进入睡眠后会自动杀掉应用进程，只有手动开启应用才能恢复运行 通知管理：应用状态有三种：提示、允许、禁止。禁止应用则通知栏不会有任何提醒</p></li><li><p><strong>魅族【 Flyme 】</strong> 自启动管理：需要把应用加到【自启动管理】列表，否则杀进程或重新开机后进程无法开启 通知栏推送：关闭应用通知则收到消息不会有任何展示 省电管理： 安全中心里设置省电模式，在【待机耗电管理】中允许应用待机时，保持允许，否则手机休眠或者应用闲置一段时间，无法正常接收消息。</p></li><li><p><strong>VIVO【 Funtouch OS 】</strong> 内存一键清理：需要将应用加入【白名单】列表，否则系统自带的“一键加速”，会杀掉进程 自启动管理：需要将应用加入 “i 管家”中的【自启动管理】列表，否则重启手机后进程不会自启。但强制手动杀进程，即使加了这个列表中，后续进程也无法自启动。</p></li></ul><span id="more"></span><ul><li><p><strong>OPPO【 ColorOS 】</strong> 冻结应用管理：需要将应用加入纯净后台，否则锁屏状态下无法及时收到消息 自启动管理：将应用加入【自启动管理】列表的同时，还需要到设置-应用程序-正在运行里锁定应用进程，否则杀进程或者开机后进程不会开启，只能手动开启应用</p></li><li><p><strong>三星</strong> 内存一键优化：需要将应用加入【白名单】列表，否则系统内存优化后，会杀掉应用进程</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AS3.0Gradle引用变化</title>
      <link href="2018/09/21/AS3.0Gradle%E5%BC%95%E7%94%A8%E5%8F%98%E5%8C%96/"/>
      <url>2018/09/21/AS3.0Gradle%E5%BC%95%E7%94%A8%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>从AS3.0开始类库依赖出现了四种新语法如下：  新语法</th><th>旧语法</th><th>功能</th><th>支持类型</th><th>隔离效果</th></tr></thead><tbody><tr><td>implementation</td><td>compile</td><td>编译期间对其他宿主不可见，运行期间可见</td><td>jar，arr</td><td>对其他宿主可见</td></tr><tr><td>api</td><td>compile</td><td>编译和运行期间都可见</td><td>jar，arr</td><td>不隔离</td></tr><tr><td>compileOnly</td><td>provided</td><td>编译期间可见，运行期间不可见</td><td>jar</td><td>不隔离</td></tr><tr><td>runtimeOnly</td><td>provided</td><td>编译期间不可见，运行期间可见</td><td>jar，arr</td><td>编译期间隔离</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>不要在foreach循环里进行元素的remove,add操作</title>
      <link href="2018/07/31/%E4%B8%8D%E8%A6%81%E5%9C%A8foreach%E5%BE%AA%E7%8E%AF%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84remove,add%E6%93%8D%E4%BD%9C/"/>
      <url>2018/07/31/%E4%B8%8D%E8%A6%81%E5%9C%A8foreach%E5%BE%AA%E7%8E%AF%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84remove,add%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。</p><ul><li><p>正确方法：</p><p>List<String> list = new ArrayList&lt;&gt;();<br>list.add(“1”);<br>list.add(“2”);<br>Iterator<String> iterator = list.iterator();</p></li></ul><span id="more"></span><pre><code>while (iterator.hasNext()) &#123;    String item = iterator.next();    if (删除元素的条件) &#123;        iterator.remove();    &#125;&#125;</code></pre><ul><li><p>错误方法</p><p>for (String item : list) {</p><pre><code>if (&quot;1&quot;.equals(item)) &#123;    list.remove(item);&#125;</code></pre><p>}</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重构-改善既有代码的设计（一）</title>
      <link href="2018/07/30/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2018/07/30/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章是我对于《重构-改善既有代码的设计》一书的记录。</p></blockquote>        <h3 id="缘由"   >          <a href="#缘由" class="heading-link"><i class="fas fa-link"></i></a><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3>      <p>我们经常会遇到需要对之前的功能进行修改的局面，当我们重新阅读之前的代码的时候，可能会有这样的感受：“我当时到底是怎么想的啊，我根本看不懂了啊，要怎么加功能呢？写的和*一样”。如果你有这种想法的话，就说明你需要对之前的代码进行重构了。</p>        <h3 id="概念"   >          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念" class="headerlink" title="概念"></a>概念</h3>      <blockquote><p><strong>重构</strong> 是在不影响业务的外在表现的时候对代码进行修改和优化的行为。</p></blockquote><span id="more"></span><p>重构应该是一种编码的思维方式，当你有空的时候就应该对之前的代码进行整理，因为你总会觉得之前的代码写的很烂的，就和你永远觉得兜里的钱很少一样。</p>        <h3 id="方法"   >          <a href="#方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法" class="headerlink" title="方法"></a>方法</h3>      <p>请不要把下面的方法当做唯一，因为这只是我脑袋还记得的东西：</p><ul><li>提炼函数</li><li>移动函数</li><li>数据封装</li><li>…</li></ul>        <h3 id="提炼函数"   >          <a href="#提炼函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#提炼函数" class="headerlink" title="提炼函数"></a>提炼函数</h3>      <p><em>提炼函数</em> 是一个非常常用的重构方式，当我们看到了一个代码行数很多的方法的时候就可以思考一样是不是可以对这个函数进行提炼了。 例如，我们有如下的一段代码：</p><pre><code>void printOrder(double amount)&#123;  printBanner();  //print detail  System.out.println(&quot;name:&quot;+name);  System.out.println(&quot;amount:&quot;+amount);&#125;</code></pre><p>对于这个方法我们可以对它进行提炼，有一个很好的入口就是，当我们看到了一段代码上面有一个注释的时候，我们就可以试着把这段代码单独作为一个方法提炼起来。重构之后就变成了了下面这样：</p><pre><code>void printOrder(double amount)&#123;  printBanner();  printDetail(amount);&#125;void printDetail(double amount)&#123;  System.out.println(&quot;name:&quot;+name);  System.out.println(&quot;amount:&quot;+amount);&#125;</code></pre><p>提炼方法对于代码的理解是会有帮助的，通常我们阅读一个命名优美的方法名的时候就可以知道它的功能了，看详细的代码未必能够很快理解。</p>        <h3 id="移动函数"   >          <a href="#移动函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动函数" class="headerlink" title="移动函数"></a>移动函数</h3>      <p>如果一函数对于另外一个类的依赖大于本身的类，那么我们就可以尝试把这个方法转移到依赖的那个类了。 例如：</p><pre><code>class Acount&#123;  ...  long computeFee()&#123;    if(type == Premium)&#123;      long result = 10;      if(dayOverdrawn&gt;7) result +=(dayOverdrawn -7)*0.85;      return result;    &#125;else &#123;      return dayOverdrawn *1.75;    &#125;  &#125;  long bankCharge()&#123;    long result = 4.5;    if(dayOverdrawn &gt;0) result +=computeFee();    return result;   &#125;&#125;</code></pre><p>上面的方法对于<code>type</code>的依赖很高，对于不同的类型有不同的费用计算，这里我们可以把计算服务费的部分放入<code>AccountType</code>的类里面，如下：</p><pre><code>class AccountType&#123;  long computeFee(int dayOverdrawn)&#123;    if(type == Premium)&#123;      long result = 10;      if(dayOverdrawn&gt;7) result +=(dayOverdrawn -7)*0.85;      return result;    &#125;else &#123;      return dayOverdrawn *1.75;    &#125;  &#125;&#125;</code></pre><p>然后在<code>Account</code>类里面替换一下引用就可以了:</p><pre><code>class Acount&#123;  ...  long bankCharge()&#123;    long result = 4.5;    if(dayOverdrawn &gt;0) result +=type.computeFee(dayOverdrawn);    return result;   &#125;&#125;</code></pre>        <h3 id="数据封装"   >          <a href="#数据封装" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3>      <p>如果我们有一个列表项，但是必须要和其他的数据结合起来才有意义，那么我们可以使用数据封装的方式，使用对象替换数据值。<br>例如，我们有一个订单的类，里面有购买者的基本信息（这只是一个小例子）：</p><pre><code>class Order&#123;  String orderId;  String customName;  String customPhone;  public String getCustomName()&#123;    return customName;  &#125;  public String getCustomPhone()&#123;    return customPhone;  &#125;&#125;</code></pre><p>对于上面的订单类，我们可以把购买者单独作为一个类存在：</p><pre><code>class Custom&#123;  String customName;  String customPhone;  public String getCustomName()&#123;    return customName;  &#125;  public String getCustomPhone()&#123;    return customPhone;  &#125;&#125;</code></pre><p>然后在<code>Order</code>类里面使用<code>Custom</code>来替换之前的购买者信息。 <em>未完待续…</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android8适配指南</title>
      <link href="2018/07/24/Android8%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97/"/>
      <url>2018/07/24/Android8%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[        <h1 id="Android-8-0适配指南"   >          <a href="#Android-8-0适配指南" class="heading-link"><i class="fas fa-link"></i></a><a href="#Android-8-0适配指南" class="headerlink" title="Android 8.0适配指南"></a>Android 8.0适配指南</h1>      <blockquote><p>转载自“鸿洋公众号”</p></blockquote><p>适配是个循序渐进的事情，不要想着一步到位。所以如果你还没有适配6.0或7.0可以先看看我之前的两篇了解一下。</p>        <h3 id="准备工作"   >          <a href="#准备工作" class="heading-link"><i class="fas fa-link"></i></a><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h3>      <p>将我们项目中的targetSdkVersion改为 26（8.0） 或者 27（8.1），记住不要超过27，毕竟我还没有告诉你Android<br>P怎么适配（滑稽）。</p><span id="more"></span>        <h3 id="运行时权限"   >          <a href="#运行时权限" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h3>      <blockquote><p>在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。<br>对于针对 Android 8.0<br>的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。<br>例如，假设某个应用在其清单中列出 <code>READ_EXTERNAL_STORAGE</code> 和<code>WRITE_EXTERNAL_STORAGE</code>。应用请求<br><code>READ_EXTERNAL_STORAGE</code>，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予<br><code>WRITE_EXTERNAL_STORAGE</code>，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android<br>8.0，则系统此时仅会授予<br><code>READ_EXTERNAL_STORAGE</code>；不过，如果该应用后来又请求<code>WRITE_EXTERNAL_STORAGE</code>，则系统会立即授予该权限，而不会提示用户。</p></blockquote><p>所谓权限组如下：<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TL2SZ4e9KjEy2W0pN7uanqFVhFmGNcra216ItNdvvbm72LAGMfs4ukMg/640"><br>所以总结下来，如果你之前是用什么权限就去申请什么权限，那么恭喜你，这个变化不会影响到你。如果你只申请了权限组中的某些权限，却用了同组的其他权限，那么你就需要去适配一下了。<br>那么怎么适配呢，如果你去检查之前每个申请权限的地方，未免太过麻烦。那么你可以根据你项目中的Manifest文件中需要的权限与权限组去对比，整理出你需要申请的各个权限组。比如你需要<code>android.permission.CALL_PHONE</code>(打电话)与<code>android.permission.READ_PHONE_STATE</code>(读取手机状态)<br>这两个权限。那么你就整理出了类似下面的类。</p><pre><code>public class PermissionGroup &#123;     //Phone权限     public static String[] PHONE = new String[] &#123;          Manifest.permission.READ_PHONE_STATE,           Manifest.permission.CALL_PHONE     &#125;;     ...&#125;</code></pre><p>到时在申请权限时就可以直接获取它，一次将它们都申请了。这样就防止了遗漏某个权限，导致的异常。</p>        <h3 id="通知适配"   >          <a href="#通知适配" class="heading-link"><i class="fas fa-link"></i></a><a href="#通知适配" class="headerlink" title="通知适配"></a>通知适配</h3>      <p>其实8.0在通知这里变化还挺多的，比如 <strong>通知渠道、通知标志、通知超时、背景颜色</strong> 的等，详细的说明可以去看官方的Android 8.0 功能和<br>API。 虽然变化很多，但是国内的机子貌似支持的不多。。。我在小米的文档中了解到，Android 已将通知渠道的逻辑纳入 Android<br>Compatibility Definition Document (CDD) 中，意味着所有 Android 厂商都必须支持。所以我们可以放心的去适配。</p><blockquote><p>通知渠道：Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。</p></blockquote><p>我个人很喜欢这个新特性。也就是说，我们可以将我们给用户的通知进行分类，我用高德地图app来举例，从左到右分别是小米(MIUI10)、华为(EMUI<br>8.1.0)、一加(氢OS 5.1)：  小米(MIUI10) | 华为(EMUI 8.1.0) | 一加(氢OS 5.1)<br>—|—|—<br><img   src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLcuWLrWJrDukcUCtLPa7YibFrPxibSQbxqibM4WlGv2JYwSmUbvrslehvg/640?wx_fmt=png" style="" ><br>|<br><img   src="https://mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLDPzaice3qkGXWtAdCiaibLMucDrOg4Jm2nWo80ZP6dPk3TUwkfXwtHPzw/640?wx_fmt=jpeg" style="" ><br>|<br><img   src="https://mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLlDFLsWHZBMn0Afkjn1ibhWzfdApOPfSB7dQ7prjG8qgib1aLh3GiaicJ5Q/640?wx_fmt=jpeg&tp=webp" style="" ><br>可以看到高德地图分的很细致，分为四个组共13个类别(华为貌似对组不生效)。这样有个好处，我们可以控制我们想收到的通知，比如我不喜欢运营活动通知，那我就可以把它关闭。<br>这样避免大量的不必要通知，否则使得用户觉得烦，一棒子打死。直接关闭你的允许通知。当然了，大量app都还没有适配，适配的也都分的不是很细致，比如下图的QQ。(没有对比就没有伤害)<br><img   src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLL0Pvibric8ez96WGo0WSzkR68LjARC4qiaOqgJyMhkHiau4AZ2PUiaurFuw/640?wx_fmt=png" style="" ><br>当然更重要的问题是，如果不去适配，可能通知都不会弹出来。那么适配的方法如下：</p><pre><code>private void createNotificationChannel() &#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;        NotificationManager notificationManager = (NotificationManager)                getSystemService(Context.NOTIFICATION_SERVICE);        //分组（可选）        //groupId要唯一        String groupId = &quot;group_001&quot;;        NotificationChannelGroup group = new NotificationChannelGroup(groupId, &quot;广告&quot;);        //创建group        notificationManager.createNotificationChannelGroup(group);        //channelId要唯一        String channelId = &quot;channel_001&quot;;        NotificationChannel adChannel = new NotificationChannel(channelId,                &quot;推广信息&quot;, NotificationManager.IMPORTANCE_DEFAULT);        //补充channel的含义（可选）        adChannel.setDescription(&quot;推广信息&quot;);        //将渠道添加进组（先创建组才能添加）        adChannel.setGroup(groupId);        //创建channel        notificationManager.createNotificationChannel(adChannel);        //创建通知时，标记你的渠道id        Notification notification = new Notification.Builder(MainActivity.this, channelId)                .setSmallIcon(R.mipmap.ic_launcher)                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))                .setContentTitle(&quot;一条新通知&quot;)                .setContentText(&quot;这是一条测试消息&quot;)                .setAutoCancel(true)                .build();        notificationManager.notify(1, notification);    &#125;&#125;</code></pre><p>效果如下：<br><img   src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLD0miaWuolxicPtTOOiakVtV1ksTjticQbABn4RxkVbo9zWUbLBy2dZHBJg/640?wx_fmt=png" style="" ><br>华为手机当只有一个渠道时，不会显示，会当做默认通知处理，除非一个以上。</p><blockquote><p>注意：当Channel已经存在时，后面的createNotificationChannel方法仅能更新其name/description，以及对importance进行降级，其余配置均无法更新。所以如果有必要的修改只能创建新的渠道，删除旧渠道。</p></blockquote><p>删除渠道代码如下：</p><pre><code>private void deleteNotificationChannel(String channelId)&#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;        NotificationManager mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);        mNotificationManager.deleteNotificationChannel(channelId);    &#125;&#125;</code></pre>        <h3 id="悬浮窗适配"   >          <a href="#悬浮窗适配" class="heading-link"><i class="fas fa-link"></i></a><a href="#悬浮窗适配" class="headerlink" title="悬浮窗适配"></a>悬浮窗适配</h3>      <p>使用 <code>SYSTEM_ALERT_WINDOW</code> 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口：</p><ul><li>TYPE_PHONE</li><li>TYPE_PRIORITY_PHONE</li><li>TYPE_SYSTEM_ALERT</li><li>TYPE_SYSTEM_OVERLAY</li><li>TYPE_SYSTEM_ERROR</li></ul><p>相反，应用必须使用名为 TYPE_APPLICATION_OVERLAY 的新窗口类型。也就是说需要在之前的基础上判断一下：</p><pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;    mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#125;else &#123;    mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#125;</code></pre><p>当然记得需要有权限</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot; /&gt;</code></pre>        <h3 id="安装APK"   >          <a href="#安装APK" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装APK" class="headerlink" title="安装APK"></a>安装APK</h3>      <p>Android 8.0去除了“允许未知来源”选项，所以如果我们的App有安装App的功能（检查更新之类的），那么会无法正常安装。<br>首先在AndroidManifest文件中添加安装未知来源应用的权限:</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt;</code></pre><p>这样系统会自动询问用户完成授权。当然你也可以先使用<br>canRequestPackageInstalls()查询是否有此权限，如果没有的话使用<code>Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES</code>这个action将用户引导至安装未知应用权限界面去授权。</p><pre><code>private static final int REQUEST_CODE_UNKNOWN_APP = 100;private void installAPK()&#123;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;        boolean hasInstallPermission = getPackageManager().canRequestPackageInstalls();        if (hasInstallPermission) &#123;            //安装应用        &#125; else &#123;            //跳转至“安装未知应用”权限界面，引导用户开启权限            Uri selfPackageUri = Uri.parse(&quot;package:&quot; + this.getPackageName());            Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri);            startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP);        &#125;    &#125;else &#123;        //安装应用    &#125;&#125;//接收“安装未知应用”权限的开启结果@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;    super.onActivityResult(requestCode, resultCode, data);    if (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123;        installAPK();    &#125;&#125;</code></pre>        <h3 id="集合的处理"   >          <a href="#集合的处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合的处理" class="headerlink" title="集合的处理"></a>集合的处理</h3>      <p>现在，AbstractCollection.removeAll(null) 和 AbstractCollection.retainAll(null)始终引发<br>NullPointerException；之前，当集合为空时不会引发 NullPointerException。所以我们需要做判空处理。</p>        <h3 id="后台执行限制"   >          <a href="#后台执行限制" class="heading-link"><i class="fas fa-link"></i></a><a href="#后台执行限制" class="headerlink" title="后台执行限制"></a>后台执行限制</h3>      <p>应用在两个方面受到限制：</p><ul><li><strong>后台服务限制：</strong> 处于空闲状态时，应用可以使用的后台服务存在限制。 这些限制不适用于前台服务，因为前台服务更容易引起用户注意。</li><li><strong>广播限制：</strong> 除了有限的例外情况，应用无法使用清单注册隐式广播。 它们仍然可以在运行时注册这些广播，并且可以使用清单注册专门针对它们的显式广播。</li></ul><p>在大多数情况下，应用都可以使用 JobScheduler 克服这些限制。<br>这种方式让应用安排为在未活跃运行时执行工作，不过仍能够使系统可以在不影响用户体验的情况下安排这些作业。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lover</title>
      <link href="2018/07/14/lover/"/>
      <url>2018/07/14/lover/</url>
      
        <content type="html"><![CDATA[<p>/* 您可以在此处加入您的CSS。 点击上方的帮助图标来了解更多。 */</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TabLayout 使用入门</title>
      <link href="2018/07/12/TabLayout%20%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
      <url>2018/07/12/TabLayout%20%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[        <h3 id="介绍"   >          <a href="#介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>      <p>TabLayout是Google官方设计的一个分类UI，效果类似如下：<br><img src="https://file.2fun.xyz/wx20180712162109.png" alt="TabLayout"><br>通常，我们会和ViewPager一起配合使用，实现滑动ViewPager，上面的分类也会跟着切换的效果。</p>        <h3 id="ViewPager设置"   >          <a href="#ViewPager设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#ViewPager设置" class="headerlink" title="ViewPager设置"></a>ViewPager设置</h3>      <p>使用ViewPager之前，需要设置Adapter，推荐使用<code>FragmentStatePagerAdapter</code>或者<code>FragmentPagerAdapter</code>。TabLayout会根据ViewPager的页数显示Tab,默认的Tab是一个文本view，里面的文字需要通过实现Adapter的<code>getPageTitle(int position)</code>方法来自动生成。 TabLayout绑定ViewPager，只需要调用一个方法即可：</p><span id="more"></span><pre><code>mTabLayout.setupWithViewPager(mViewPager);</code></pre>        <h3 id="TabLayout-文本颜色"   >          <a href="#TabLayout-文本颜色" class="heading-link"><i class="fas fa-link"></i></a><a href="#TabLayout-文本颜色" class="headerlink" title="TabLayout 文本颜色"></a>TabLayout 文本颜色</h3>      <p>设置TabLayout的文本的颜色十分简单，有两种方式，一个是xml文件的形式，另一个是java代码的形式。 - xml方法：</p><pre><code>&lt;android.support.design.widget.TabLayout    android:id=&quot;@+id/tab_layout&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;44dp&quot;    app:tabSelectedTextColor=&quot;@color/ls_color_red&quot;    app:tabTextColor=&quot;@color/ls_color_blue&quot;&gt;</code></pre><ul><li><p>java代码形式：</p><p>mTabLayout.setTabTextColors(int normalColor, int selectedColor);</p></li></ul>        <h3 id="Tablayout-文字大小"   >          <a href="#Tablayout-文字大小" class="heading-link"><i class="fas fa-link"></i></a><a href="#Tablayout-文字大小" class="headerlink" title="Tablayout 文字大小"></a>Tablayout 文字大小</h3>      <p>如果是要设置统一的文本大小，也很简单，只需要在<code>values\style</code>里面添加一个风格代码就可以：</p><pre><code>&lt;style name=&quot;MyTabLayoutTextStyle&quot; parent=&quot;TextAppearance.AppCompat.Title&quot;&gt;    &lt;item name=&quot;android:textSize&quot;&gt;@字体大小&lt;/item&gt;&lt;/style&gt;</code></pre><p>然后布局文件里面设置<code>tabTextAppearance</code>参数</p><pre><code>&lt;android.support.design.widget.TabLayout    android:id=&quot;@+id/tab_layout&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;44dp&quot;    app:tabTextAppearance=&quot;@style/OrderTabLayoutTextStyle&quot;&gt;</code></pre><p><strong>但是，如果你想要动态改变文字的大小，例如选中的文字比未选中的大</strong> ，那就不能用这个方法了。</p>        <h3 id="TabLayout-动态改变文字的大小"   >          <a href="#TabLayout-动态改变文字的大小" class="heading-link"><i class="fas fa-link"></i></a><a href="#TabLayout-动态改变文字的大小" class="headerlink" title="TabLayout 动态改变文字的大小"></a>TabLayout 动态改变文字的大小</h3>      <p>由于TabLayout官方没有设置文本大小的方法，所以，我们只能寻找其他的办法，所以我们可以使用自定义View的形式；<code>TabLayout.Tab</code>有一个方法叫<code>setCustomView(@Nullable View view)</code>,通过customView,我们就可以实现对文本大小的控制了。 通过遍历TabLayout的tabs,然后添加自定义的view：</p><pre><code>for (int i = 0; i &lt; mTabLayout.getTabCount(); i++) &#123;    TabLayout.Tab tab = mTabLayout.getTabAt(i);    TextView tv = new TextView(getContext());    LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,             ViewGroup.LayoutParams.WRAP_CONTENT);    tv.setLayoutParams(p);    tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);    tv.setText(tab.getText());    tab.setCustomView(tv);&#125;</code></pre><p>监听tab的切换，然后当tab被选中就把文字大小改变：</p><pre><code>mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123;    @Override    public void onTabSelected(TabLayout.Tab tab) &#123;        if(tab.getCustomView() == null)&#123;            return;        &#125;        //todo-*******对文本大小进行修改*******    &#125;&#125;</code></pre>        <h3 id="改变横线的长度和高度"   >          <a href="#改变横线的长度和高度" class="heading-link"><i class="fas fa-link"></i></a><a href="#改变横线的长度和高度" class="headerlink" title="改变横线的长度和高度"></a>改变横线的长度和高度</h3>      <ul><li><p>高度 控制横线的高度可以在xml文件里面写上<code>tabIndicatorHeight</code>参数。</p></li><li><p>长度 虽然不能直接通过TabLayout的方法对长度进行控制，但是查看源码知道，横线的长度和tab的宽度有关，可以通过反射得到tabview然后设置长度：</p><p>try {</p><pre><code>LinearLayout mTabStrip = (LinearLayout) mTabLayout.getChildAt(0);int dp10 = DeviceUtils.dp2px(10);for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123;    View tabView = mTabStrip.getChildAt(i);    tabView.setPadding(0, 0, 0, 0);    //设置tab左右间距为10dp  注意这里不能使用Padding 因为源码中线的宽度是根据 tabView的宽度来设置的    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams();    params.width = DeviceUtils.dp2px(42);    params.leftMargin = dp10;    params.rightMargin = dp10;    tabView.setLayoutParams(params);    tabView.invalidate();    &#125;</code></pre><p>} catch (Exception e) {</p><pre><code>e.printStackTrace();</code></pre><p>}</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lets Encrypt 使用</title>
      <link href="2018/06/23/Lets%20Encrypt%20%E4%BD%BF%E7%94%A8/"/>
      <url>2018/06/23/Lets%20Encrypt%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[        <h3 id="Lets-Encrypt"   >          <a href="#Lets-Encrypt" class="heading-link"><i class="fas fa-link"></i></a><a href="#Lets-Encrypt" class="headerlink" title="Lets Encrypt"></a>Lets Encrypt</h3>      <p>Lets Encrypt是一个免费的Https签发服务。</p>        <h3 id="acme-sh"   >          <a href="#acme-sh" class="heading-link"><i class="fas fa-link"></i></a><a href="#acme-sh" class="headerlink" title="acme.sh"></a>acme.sh</h3>      <p>acme.sh是一个方便Lets Encrypt生成签证的脚本，可以非常方便的使用。</p>        <h3 id="安装acme-sh"   >          <a href="#安装acme-sh" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装acme-sh" class="headerlink" title="安装acme.sh"></a>安装acme.sh</h3>      <span id="more"></span><p>安装很简单, 一个命令:</p><pre><code>curl  https://get.acme.sh | sh</code></pre><p>普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步: 把 acme.sh 安装到你的 home 目录下:</p><pre><code>~/.acme.sh/</code></pre><p>并创建 一个 bash 的 alias, 方便你的使用:</p><pre><code>alias acme.sh=~/.acme.sh/acme.sh</code></pre>        <h3 id="获取证书"   >          <a href="#获取证书" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h3>      <p>lets encrypt需要使用dns来验证身份，acme可以帮助你自动设置dns，但是你需要配置dns。 如果使用的是阿里云的话，需要通过<br><strong><span class="exturl"><a class="exturl__link"   href="https://ak-console.aliyun.com/#/accesskey"  title="阿里云链接">阿里云链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong><br>设置accessKey,然后将获取到的保存到环境里面。</p><pre><code>export Ali_Key=&quot;sdfsdfsdfljlbjkljlkjssaddfoiwje&quot;export Ali_Secret=&quot;jlsdflanljkljlfdsassklkjflsa&quot;</code></pre><p>现在你就可以生成https证书了</p><pre><code>acme.sh --issue --dns dns_ali -d example.com -d www.example.com</code></pre><p>生成的证书会保存在<code>~/.acme.sh/account.conf</code>目录里面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Eloquent in SlimPHP</title>
      <link href="2018/05/06/Eloquent%20in%20SlimPHP/"/>
      <url>2018/05/06/Eloquent%20in%20SlimPHP/</url>
      
        <content type="html"><![CDATA[        <h3 id="环境安装"   >          <a href="#环境安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3>      <p>在项目目录里面执行 <code>composer require illuminate/database &quot;~5.1&quot;</code></p>        <h3 id="配置数据库"   >          <a href="#配置数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3>      <p>在settings的文件里面添加数据库的配置信息，主要是“db=&gt;”对应的内容。</p><span id="more"></span><pre><code>&lt;?phpreturn [    &#39;settings&#39; =&gt; [        // Slim Settings        &#39;determineRouteBeforeAppMiddleware&#39; =&gt; false,        &#39;displayErrorDetails&#39; =&gt; true,        &#39;db&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;mysql&#39;,            &#39;host&#39; =&gt; &#39;localhost&#39;,            &#39;database&#39; =&gt; &#39;database&#39;,            &#39;username&#39; =&gt; &#39;user&#39;,            &#39;password&#39; =&gt; &#39;password&#39;,            &#39;charset&#39;   =&gt; &#39;utf8&#39;,            &#39;collation&#39; =&gt; &#39;utf8_unicode_ci&#39;,            &#39;prefix&#39;    =&gt; &#39;&#39;,        ]    ],];</code></pre>        <h3 id="使用数据库"   >          <a href="#使用数据库" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3>      <p>在controller的代码里面使用数据库： <code>$table = $c-&gt;get(&#39;db&#39;)-&gt;table(&#39;table_name&#39;);</code> 例如：</p><pre><code>$container[App\WidgetController::class] = function ($c) &#123;    $view = $c-&gt;get(&#39;view&#39;);    $logger = $c-&gt;get(&#39;logger&#39;);    $table = $c-&gt;get(&#39;db&#39;)-&gt;table(&#39;table_name&#39;);    return new \App\WidgetController($view, $logger, $table);&#125;;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="2018/03/22/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>2018/03/22/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[        <h3 id="缘由"   >          <a href="#缘由" class="heading-link"><i class="fas fa-link"></i></a><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3>      <p>今天在看关于设计模式的文章的时候，偶然看到一个叫做“ <strong>备忘录模式</strong> ”的设计模式，感觉名字甚是有趣，便研究了一番。</p>        <h3 id="开始学习"   >          <a href="#开始学习" class="heading-link"><i class="fas fa-link"></i></a><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h3>      <p>备忘录模式，顾名思义就是可以向备忘录一样支持记录过程并且可以查看到每一步的状态的一种设计模式。最常见的使用是一些美图软件里面，需要对图片处理的过程进行记录，用户可以回退到上一步，也可以前进到最新的一步。下面是类图：<br><img src="http://my.csdn.net/uploads/201205/02/1335891550_5966.jpg" alt="类图"></p><ul><li><strong>Originator</strong> 原发器：动作的发起者，负责创建一个备忘录来记录当前对象的内部状态，并可使用备忘录恢复内部状态。</li></ul><span id="more"></span><ul><li><p><strong>Memento</strong> 备忘录：负责存储发起者对象的内部状态， <strong>只有原发器可以创建备忘录并修改备忘录</strong> 。</p></li><li><p><strong>Caretaker</strong> 负责人：用于管理备忘录，但是不能修改备忘录，只负责存储备忘录。</p></li></ul>        <h3 id="举个例子"   >          <a href="#举个例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3>      <p>我们在编写文章的时候，经常会有撤销和回退的需求，这里可以使用备忘录模式设计。为了满足多次撤销的功能，我们可以再负责人类里面持有一个备忘录的列表，这样就可以记录一条过程了。demo的效果图如下：<br><img src="https://file.2fun.xyz/android_memento_parttern_demo_show.gif" alt="输入的撤销会回退demo"><br>具体的类图如下： <img src="https://file.2fun.xyz/article_memento_parttern_uml" alt="文字输入的demo类图"></p><ul><li><p><strong>ArticleMemento</strong> 文章备忘录类：用于对文章的状态进行保存。下面的代码省略了get、set方法。</p><p>public class ArticleMemento {</p><pre><code>        private String title = &quot;&quot;; //标题        private String content = &quot;&quot;; //内容        private int selection = 0; //指针的位置        public ArticleMemento(ArticleOriginator originator) &#123;            this.title = originator.getTitle();            this.content = originator.getContent();            this.selection = originator.getSelection();        &#125; &#125;</code></pre></li><li><p><strong>ArticleOriginator</strong> 文章的原发器，用于创建和修改文章备忘录。</p><p>public class ArticleOriginator {</p><pre><code>private String title = &quot;&quot;; //标题private String content = &quot;&quot;; //内容private int selection = 0; //指针的位置public ArticleMemento createMemento() &#123;    return new ArticleMemento(this);&#125;public ArticleOriginator setArticleMemento(ArticleMemento memento) &#123;    this.title = memento.getTitle();    this.content = memento.getContent();    this.selection = memento.getSelection();    return this;&#125;</code></pre><p>}</p></li><li><p><strong>ArticleCaretaker</strong> 文章备忘录的负责人,管理备忘录历史记录。</p><p>public class ArticleCaretaker {</p><pre><code>private List&lt;ArticleMemento&gt; mMementoList; //备忘录列表private int mMaxLength = 20; //记录的步数 ，限制记录的次数有助于减少内存使用private int index = 0; //记录当前的步数public ArticleCaretaker() &#123;    mMementoList = new ArrayList&lt;&gt;();&#125;/** * 记录一次备忘 * * @param memento */public void saveMemento(ArticleMemento memento) &#123;    //将index后面的删除掉    List&lt;ArticleMemento&gt; removes = new ArrayList&lt;&gt;();    for (int i = index + 1; i &lt; mMementoList.size(); i++) &#123;        removes.add(mMementoList.get(i));    &#125;    mMementoList.removeAll(removes);    if (memento != null) &#123;        mMementoList.add(memento);        //长度超过了最大值就需要将第一个备忘删除掉        if (mMementoList.size() &gt; mMaxLength) &#123;            mMementoList.remove(0);        &#125;    &#125;    index = Math.max(0, mMementoList.size() - 1);&#125;/** * 获取最后一步的备忘 * * @return */public ArticleMemento undo() &#123;    index = Math.max(0, index - 1);    if (mMementoList.size() &gt; 1) &#123;        return mMementoList.get(index);    &#125; else return null;&#125;/** * 恢复一个步骤 * * @return */public ArticleMemento redo() &#123;    //没有记录返回空    if (mMementoList.size() == 0) &#123;        return null;    &#125;    index = Math.min(mMementoList.size() - 1, index + 1);    return mMementoList.get(index);&#125;</code></pre><p>}</p></li></ul><p><strong>使用</strong></p><pre><code>//在需要的地方创建ArticleCaretaker 和ArticleOriginator的对象，然后通过ArticleOriginator获取ArticleMemento对象保存在ArticleCaretaker。通过ArticleCaretaker来进行文章的撤销会回退功能mArticleOriginator = new ArticleOriginator();mArticleCaretaker = new ArticleCaretaker();//修改文章的内容mArticleOriginator      .setContent(s.toString())      .setSelection(s.length());//保存记录mArticleCaretaker.saveMemento(mArticleOriginator.createMemento());//undo和redoArticleMemento memento = mArticleCaretaker.undo();ArticleMemento memento = mArticleCaretaker.redo();</code></pre>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>      <p>备忘录模式适用于需要保存操作记录的地方，需要注意的地方是：<br><strong>备忘录类只能在原发器类里面创建和修改，对其他的类保持封闭，负责人类只负责保存管理备忘录类，不需要知道备忘录类的具体内容和实现</strong> 。</p><ul><li><p><strong>优点</strong> (1)它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。 (2)备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</p></li><li><p><strong>缺点</strong> 资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式初探</title>
      <link href="2018/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2/"/>
      <url>2018/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/designPatternBearever.jpg" alt="设计模式"></p>        <h3 id="面向对象的设计原则"   >          <a href="#面向对象的设计原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h3>      <p>在看设计模式的时候都会多少提到面向对象的设计原则，明白了这些设计原则对于理解设计模式是很有帮助的，所以我就先介绍下面向对象的设计原则。<br>设计原则是为了服务于软件开发， <strong>提高一个软件的可维护性和复用性</strong> 。常见的设计原则如下：  设计原则 | 说明<br>—|—<br>单一原则 | 一个类只负责一个具体领域的职责<br>开闭原则 | 软件实体应对拓展开放，对修改关闭<br>里氏代换原则 | 所有引用基类对象的地方可以透明地使用它子类的对象  </p><span id="more"></span><p>依赖倒转原则 | 抽象不应该依赖于具体细节，细节应该依赖于抽象<br>合成复用原则 | 尽量使用对象组合而不是继承达到复用的目的<br>迪卡特法则 | 一个软件实体应该尽可能少的于其他实体发生关系  </p>        <h3 id="设计模式"   >          <a href="#设计模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3>      <div class="table-container"><table><thead><tr><th>知道了常用的设计原则之后，我们可以看看常见的设计模式，本篇文章不对设计模式进行具体的讨论，具体的请看详细分析的文章。  设计模式</th><th>说明</th></tr></thead><tbody><tr><td>单例模式</td><td>一个类在全局只有一个实例，并且提供全局访问的方法</td></tr><tr><td>工厂模式</td><td>定义一个创建对象的接口，让子类决定具体生成什么</td></tr><tr><td>外观模式</td><td>为一个复杂的业务提供一个统一的入口，使得外部使用更加方便</td></tr><tr><td>迭代器模式</td><td>提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示</td></tr><tr><td>观察者模式</td><td>一对多的依赖关系，被观察对象的状态改变，所有的观察者都会受到通知</td></tr><tr><td>组合模式</td><td>组合多个对象形成树形结构，组合对象和单个对象的使用具有一致性</td></tr><tr><td>适配器模式</td><td>将一个接口转化为客户端希望的另外的接口，使得不兼容的接口可以正常工作</td></tr><tr><td>命令模式</td><td>使用抽象命令类将请求参数化，客户端只需要知道使用命令即可</td></tr><tr><td>策略模式</td><td>将算法的使用和定义分开，让算法可以随客户而变化</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安装软件Android</title>
      <link href="2018/03/15/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6Android/"/>
      <url>2018/03/15/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6Android/</url>
      
        <content type="html"><![CDATA[        <h3 id="缘由"   >          <a href="#缘由" class="heading-link"><i class="fas fa-link"></i></a><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3>      <p>很多时候我们都需要给应用添加更新的功能，当我们下载完了安装包了，肯定是希望能够自动安装新版本的。但是由于安卓系统的限制，我们没法做到无感知的安装，所以就需要使用系统的软件安装器让用户去安装了。</p>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code>/** * 安装apk文件</code></pre><span id="more"></span><pre><code> * * @param apkFile 安装包所在目录 */public static void installApk(Context context, File apkFile) &#123;    Intent intent = new Intent(Intent.ACTION_VIEW);    try &#123;        String[] command = &#123;&quot;chmod&quot;, &quot;777&quot;, apkFile.toString()&#125;;        ProcessBuilder builder = new ProcessBuilder(command);        builder.start();    &#125; catch (IOException ignored) &#123;    &#125;    if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.M) &#123;        intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);        Uri contentUri = FileProvider.getUriForFile(context,                context.getApplicationContext().getPackageName() + &quot;.provider&quot;, apkFile);        intent.setDataAndType(contentUri, context.getContentResolver().getType(contentUri));    &#125; else &#123;        intent.setDataAndType(Uri.fromFile(apkFile), &quot;application/vnd.android.package-archive&quot;);        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);    &#125;    context.startActivity(intent);    //关闭旧版本的应用程序的进程    android.os.Process.killProcess(android.os.Process.myPid());&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数字组合得到24</title>
      <link href="2018/01/03/%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88%E5%BE%97%E5%88%B024/"/>
      <url>2018/01/03/%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88%E5%BE%97%E5%88%B024/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/python_computer24.jpg" alt="寻找24的组合"></p>        <h3 id="缘由"   >          <a href="#缘由" class="heading-link"><i class="fas fa-link"></i></a><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3>      <p>今天同事给我出了一道题：</p><blockquote><p>有四个数字：8、8、3、3，通过加减乘除还有括号，使得结果为24</p></blockquote><p>我一看这么简单的数学题，我弟弟都会，简直就是毫无挑战，于是就拿出笔开始算。“3x8=24”这么简单啊，但是还有两个“3、8”啊！，就这样算了一个小时，还是没算出来，内心很受打击。但是，没关系，我是程序员怎么可能解不出来啊，我非得写个算法算出来。于是有了下面的故事…</p><span id="more"></span>        <h3 id="思路"   >          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h3>      <p>要求出值为24的排列方式，我想到了暴力解法，将每一种可能性算一遍，如果结果刚好是24，那就是我需要的答案了呗。 所以题目就被分解了三个步骤：</p><ul><li>遍历获取数字的排列方式</li><li>对于每一种数字的排列方式，获取符号的排列方式</li><li>计算每一种排列情况的值是否等于目标值</li></ul>        <h3 id="遍历数字的排列可能"   >          <a href="#遍历数字的排列可能" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历数字的排列可能" class="headerlink" title="遍历数字的排列可能"></a>遍历数字的排列可能</h3>      <p><strong>思路：</strong> 4个数字有顺序的排列，其实就是一个排列组合问题，共有4<em>3</em>2*1 =<br>24种可能。我的想法是通过循环的方式遍历每一个可能，则对于第一个数字可以有四个数字可以选择，对于第二个数字则有剩余三个数字可以选择，对于第三个数字则有剩余两个数字可选，最后的一个数字则只剩一种可以选择。</p>        <h3 id="遍历得到符号的排列组合"   >          <a href="#遍历得到符号的排列组合" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历得到符号的排列组合" class="headerlink" title="遍历得到符号的排列组合"></a>遍历得到符号的排列组合</h3>      <p>思路：对于可以使用的符号有“加减乘除”，另外还有括号，其实括号只是改变了计算的顺序，而我们已经将每一个可能的计算顺序排列了出来，所以只需要一步一步的从左往右计算就可以了。在四个数字之间加入符号一共有四个位置：<br><img src="https://file.2fun.xyz/computer24shuzihefuhao.png" alt="符号的位置"><br>只需要对每一个位置进行一次循环求得所有的符号排列情况就好，需要注意的是：第一个符号位只能有“加减号”。</p>        <h3 id="计算"   >          <a href="#计算" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算" class="headerlink" title="计算"></a>计算</h3>      <p>对于每一个数字和符号的排列进行组合的情况，需要进行计算是否与目标值24相等，如果相等就打印出来。因为我们通过前面的组合得到了一个带有计算符号的字符串，这里我们可以使用<code>eval()</code>函数将值计算出来。<br><strong>注意情况：</strong> 由于我们的所有操作都是从左到右一步一步的计算，如图：<br><img src="https://file.2fun.xyz/computer24jisaunss.png" alt="计算步骤"><br>所以会导致无法匹配出<code>8/（1/3）=24</code>的情况，所以，<br><strong>当我们计算出来值为目标值的倒数的时候，就需要将除数与被除数交换位置，这个时候得到的表达式也是对的</strong> 。</p>        <h3 id="完整代码"   >          <a href="#完整代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3>      <pre><code># -*- coding: UTF-8 -*-from fractions import Fraction# 目标值targetNum = 24# 已经输出的结果printList = []# 获取对应的符号# 运算def getNum(num1, num2, fu):    if fu == &#39;/&#39;:        return &quot;Fraction(&quot; + num1 + &quot;,&quot; + num2 + &quot;)&quot;    else:        return str(num1) + fu + str(num2)# 计算结果 ,数字有4位，符号有3位def computer(numlist, fulist):    global printList    global targetNum    # 前面两个数字计算的结果    v = &quot;0&quot;    # 计算表达式    pp = &quot;&quot;    # 遍历符号    # 从左到右依次计算，不需要按照乘除法先算的规则，因为要考虑括号的情况    for x in range(0, len(fulist)):        if x == 0:            v = getNum(&#39;&#39;, numlist[x], fulist[x])            pp = &quot;&quot; + fulist[x] + numlist[x]        else:            v = &quot;(&quot; + getNum(v, numlist[x], fulist[x]) + &quot;)&quot;            pp = &quot;(&quot; + pp + fulist[x] + numlist[x] + &quot;)&quot;    try:        # 判断是否已经输出了这个表达式，如果没有会报错        if printList.index(pp):            return    except Exception as e:        # 拦截错误，计算是否匹配结果        dif = eval(v) - targetNum        if abs(dif) == 0:            printList.append(pp)            print(&#39;----------------------&#39;)            print(pp, &quot;=&quot;, eval(v))            print(&#39;----------------------&#39;)        elif eval(v) == Fraction(1, targetNum):            v = &quot;&quot;            pp = &quot;&quot;            # 除法倒置，将最后的一个除法的除数和被除数交换            for x in range(0, len(fulist)):                if x == 0:                    v = getNum(&#39;&#39;, numlist[x], fulist[x])                    pp = &quot;&quot; + fulist[x] + numlist[x]                else:                    # 如果最后一个符号是“/”，则倒置                    if x == len(fulist) - 1 and fulist[x] == &#39;/&#39;:                        v = &quot;(&quot; + getNum(numlist[x], v, fulist[x]) + &quot;)&quot;                        pp = &quot;(&quot; + numlist[x] + fulist[x] + pp + &quot;)&quot;                    else:                        v = &quot;(&quot; + getNum(v, numlist[x], fulist[x]) + &quot;)&quot;                        pp = &quot;(&quot; + pp + fulist[x] + numlist[x] + &quot;)&quot;            # 同样的计算方式，只打印一次            try:                printList.index(pp)            except Exception as e:                printList.append(pp)                print(&#39;----------------------&#39;)                print(pp, &quot;=&quot;, eval(v))                print(&#39;----------------------&#39;)# 计算排列组合答案def computer24(numList):    global num    # 循环遍历出数字排列组合    for x in range(0, len(numList)):        # 得到第一个数字        a = numList[x]        # 获得剩下的三个数字的列表        restListA = []        for x1 in range(0, len(numList)):            if x1 != x:                restListA.append(numList[x1])        for y in range(0, len(restListA)):            # 第二个数字            b = restListA[y]            restListB = []            for y1 in range(0, len(restListA)):                if y1 != y:                    restListB.append(restListA[y1])                #                for z in range(0, len(restListB)):                    # 第三个数字                    c = restListB[z]                    for z1 in range(0, len(restListB)):                        if z1 != z:                            d = restListB[z1]                            numArray = [a, b, c, d]                            # 得到了数字组合，需要对数字间隔进行填符号                            # 第一个符号                            fulist = [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]                            for q in range(0, 2):                                # 第二位                                for w in range(0, 4):                                    # 第三位                                    for e in range(0, 4):                                        # 第四位                                        for r in range(0, 4):                                            f = [fulist[q], fulist[w],                                                 fulist[e], fulist[r]]                                            # print(numArray, f)                                            computer(numArray, f)computer24([&#39;8&#39;,&#39;8&#39;,&#39;3&#39;,&#39;3&#39;])print(&quot;计算完成！&quot;)</code></pre>        <h3 id="运行实例"   >          <a href="#运行实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h3>      <ul><li><p>计算<code>8、8、3、3</code>组合成<code>24</code><br><code>&gt;&gt;&gt;(8/((-8/3)+3)) = 24</code></p></li><li><p>计算<code>1、5、5、5</code>组合为<code>24</code><br><code>&gt;&gt;&gt;(((-1/5)+5)*5) = 24</code></p></li><li><p>计算<code>4、4、10、10</code>组合为<code>24</code><br><code>&gt;&gt;&gt;(((+10*10)-4)/4)= 24</code></p></li><li><p>计算<code>2、2、11、11</code>组合为<code>24</code><br><code>&gt;&gt;&gt;(((+2/11)+2)*11) = 24</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝牙连接库 IBleLib的使用</title>
      <link href="2017/12/28/%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E5%BA%93%20IBleLib%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2017/12/28/%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E5%BA%93%20IBleLib%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[        <h3 id="蓝牙连接库-IBleLib"   >          <a href="#蓝牙连接库-IBleLib" class="heading-link"><i class="fas fa-link"></i></a><a href="#蓝牙连接库-IBleLib" class="headerlink" title="蓝牙连接库 IBleLib"></a>蓝牙连接库 IBleLib</h3>      <p><strong>IBLeLib</strong> 是一个安卓平台的蓝牙库，可以方便的实现蓝牙的搜索、连接、数据读取的操作。<br><img src="https://file.2fun.xyz/ible_show_logo.jpg" alt="IBleLib"></p>        <h4 id="Github链接"   >          <a href="#Github链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#Github链接" class="headerlink" title="Github链接"></a>Github链接</h4>      <p>所有的代码和Demo都已经上传到了Github，喜欢可以star。<br><a href="https://github.com/Luomingbear/IBleLib"><strong>点击跳转到Github</strong></a></p><span id="more"></span>        <h4 id="效果图"   >          <a href="#效果图" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4>      <p>Demo实现了蓝牙的搜索和链接配对，到数据获取，链接的对象是一个蓝牙电子秤，当电子秤获得质量之后会发送一个数据返回给应用。<br><img src="https://file.2fun.xyz/BleDemo_sample20171228.gif" alt="效果图"></p>        <h3 id="使用方法"   >          <a href="#使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3>      <p>所有的操作都简化到了一个类里面<code>IBleManager</code>，通过调用<code>IBleManager.getInstance()</code>来获取单例对象。</p>        <h4 id="打开关闭"   >          <a href="#打开关闭" class="heading-link"><i class="fas fa-link"></i></a><a href="#打开关闭" class="headerlink" title="打开关闭"></a>打开关闭</h4>      <ul><li><p>打开蓝牙</p><pre><code>IBleManager.getInstance().openBle()</code></pre></li><li><p>关闭蓝牙</p><pre><code>IBleManager.getInstance().closeBle()</code></pre></li><li><p>判断蓝牙是否打开</p><pre><code>IBleManager.getInstance().isOpen()</code></pre></li></ul><p>返回值是布尔值,<code>true</code>:打开，<code>false</code>:关闭</p>        <h4 id="搜索"   >          <a href="#搜索" class="heading-link"><i class="fas fa-link"></i></a><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4>      <ul><li><p>开始搜索</p><pre><code>IBleManager.getInstance().startSearch(Context activity, IBleSearchManager.OnIBleSearchListener listener)</code></pre></li><li><p>结束搜索</p><pre><code>IBleManager.getInstance().stopSearch() </code></pre></li></ul>        <h4 id="连接"   >          <a href="#连接" class="heading-link"><i class="fas fa-link"></i></a><a href="#连接" class="headerlink" title="连接"></a>连接</h4>      <ul><li><p>配对</p><pre><code>IBleManager.getInstance().bond(String mac, OnBleBondListener listener)</code></pre></li><li><p>开始连接</p><pre><code>IBleManager.getInstance().connect(Context context, String mac, UUID uuid, OnBleConnectListener listener)</code></pre></li></ul><p><strong>UUID</strong> :UUID是通用唯一识别码（Universally Unique<br>Identifier）的缩写，蓝牙的每一个服务通过特定的UUID来标识，可以通过查看蓝牙服务于UUID的对应关系来找到自己需要的UUID。</p><ul><li><p>断开连接</p><pre><code>IBleManager.getInstance().disConnect(String mac) </code></pre></li><li><p>是否连接成功</p><pre><code>IBleManager.getInstance().isConnect(String mac)</code></pre></li></ul>        <h4 id="读取数据"   >          <a href="#读取数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4>      <pre><code>IBleManager.getInstance().read(Context context, String mac, UUID uuid, OnIBleReadListener listener)</code></pre>        <h3 id="注意事项"   >          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>      <p>蓝牙的搜索需要使用到定位权限，需要动态申请权限的时候请务必先获取权限然后在搜索蓝牙。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WebView （Android）使用</title>
      <link href="2017/12/20/WebView%20%EF%BC%88Android%EF%BC%89%E4%BD%BF%E7%94%A8/"/>
      <url>2017/12/20/WebView%20%EF%BC%88Android%EF%BC%89%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[        <h3 id="WebView-介绍"   >          <a href="#WebView-介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebView-介绍" class="headerlink" title="WebView 介绍"></a>WebView 介绍</h3>      <p>WebView是安卓平台用来显示网控件，可以实现App的混合开发需求。我们可能会有这样的需求，系统后台发送一个活动给用户，但是这个活动是会变化的，所以不能使用安卓的原生界面直接显示，那样会约束掉UI界面，使用网页来介绍活动就很有用了。<br><img src="https://file.2fun.xyz/webview_sample_gcross.png" alt="机核网的WebView显示文章"></p>        <h3 id="设置"   >          <a href="#设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#设置" class="headerlink" title="设置"></a>设置</h3>      <p>当我们在布局文件里面添加了WebView控件之后，我们就可以对他进行操作了，首先需要对他进行设置，以满足你的需求。</p>        <h4 id="获取WebSettings"   >          <a href="#获取WebSettings" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取WebSettings" class="headerlink" title="获取WebSettings"></a>获取WebSettings</h4>      <span id="more"></span><pre><code>WebSettings webSettings = webView.getSettings();</code></pre>        <h4 id="设置-1"   >          <a href="#设置-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#设置-1" class="headerlink" title="设置"></a>设置</h4>      <pre><code>//如果访问的页面中要与Javascript交互，则webview必须设置支持JavascriptwebSettings.setJavaScriptEnabled(true);// 若加载的 html 里有JS 在执行动画等操作，会造成资源浪费（CPU、电量）// 在 onStop 和 onResume 里分别把 setJavaScriptEnabled() 给设置成 false 和 true 即可//设置自适应屏幕，两者合用webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小//缩放操作webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。webSettings.setBuiltInZoomControls(false); //设置内置的缩放控件。若为false，则该WebView不可缩放webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件//其他细节操作webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存webSettings.setAllowFileAccess(true); //设置可以访问文件webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片webSettings.setDefaultTextEncodingName(&quot;utf-8&quot;);//设置编码格式</code></pre>        <h3 id="加载网页"   >          <a href="#加载网页" class="heading-link"><i class="fas fa-link"></i></a><a href="#加载网页" class="headerlink" title="加载网页"></a>加载网页</h3>      <pre><code>//方式1. 加载一个网页：webView.loadUrl(&quot;http://www.google.com/&quot;);//方式2：加载apk包中的html页面webView.loadUrl(&quot;file:///android_asset/test.html&quot;);//方式3：加载手机本地的html页面webView.loadUrl(&quot;content://com.android.htmlfileprovider/sdcard/test.html&quot;);//方式4：加载html字符串mWebView.loadData(htmlString,&quot;text/html&quot;, &quot;utf-8&quot;);</code></pre>        <h3 id="WebViewClient"   >          <a href="#WebViewClient" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a>WebViewClient</h3>      <p>用来处理各种通知和请求事件 常用的方法</p><ul><li><p>shouldOverrideUrlLoading()<br>当网页跳转到新的地址的时候执行，可以用来拦截跳转等，获取用来进行HTML和app的数据交互。</p></li><li><p>onPageStarted<br>网页开始载入的时候调用。</p></li><li><p>onPageFinished<br>网页加载结束的时候调用。</p></li><li><p>onReceivedError<br>网页加载错误的时候调用，如404。</p></li></ul>        <h3 id="WebChromeClient"   >          <a href="#WebChromeClient" class="heading-link"><i class="fas fa-link"></i></a><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a>WebChromeClient</h3>      <p>辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。</p><ul><li><p>onProgressChanged<br>网页加载进度变化的时候调用。</p></li><li><p>onReceivedTitle<br>获取网页的标题。</p></li><li><p>onJsAlert<br>当网页弹窗显示的时候调用。</p></li><li><p>onJsConfirm<br>当网页点击了确认按钮时候调用。</p></li></ul>        <h3 id="注意事项：如何避免WebView内存泄露"   >          <a href="#注意事项：如何避免WebView内存泄露" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项：如何避免WebView内存泄露" class="headerlink" title="注意事项：如何避免WebView内存泄露"></a>注意事项：如何避免WebView内存泄露</h3>      <ul><li>不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext()</li><li>在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。<pre><code>@Overrideprotected void onDestroy() &#123;    if (mWebView != null) &#123;        mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);        mWebView.clearHistory();        ((ViewGroup) mWebView.getParent()).removeView(mWebView);        mWebView.destroy();        mWebView = null;    &#125;    super.onDestroy();&#125;</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池 Java</title>
      <link href="2017/12/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%20Java/"/>
      <url>2017/12/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%20Java/</url>
      
        <content type="html"><![CDATA[        <h3 id="线程池-介绍"   >          <a href="#线程池-介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池-介绍" class="headerlink" title="线程池 介绍"></a>线程池 介绍</h3>      <p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：</p><blockquote><p>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p></blockquote><p>那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？<br>这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p><span id="more"></span>        <h3 id="Java自带的线程池"   >          <a href="#Java自带的线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java自带的线程池" class="headerlink" title="Java自带的线程池"></a>Java自带的线程池</h3>      <p>JDK自带了几种线程池，在<code>Executors</code>里面可以直接new出来，下面主要介绍常用的四种：</p><ul><li><code>**newFixedThreadPool**</code> 创建一个指定线程数量的线程池，如果线程数量超过指定数量，则会在线程队列里面等待，直到线程池有空余。 </li><li><code>**newCachedThreadPool**</code> 创建一个可缓存的线程池，这种类型的线程池特点是： 1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。 2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。 </li><li><code>**newSingleThreadExecutor**</code> 创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。 </li><li><code>**newScheduleThreadPool**</code> 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。 </li></ul>        <h3 id="线程池的使用"   >          <a href="#线程池的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3>      <p>以单线程的线程池为例：</p><pre><code>ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();        for (int i = 0; i &lt; 10; i++) &#123;            final int index = i;            singleThreadExecutor.execute(new Runnable() &#123;                public void run() &#123;                    try &#123;                        System.out.println(index);                        Thread.sleep(2000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;);        &#125;</code></pre><p>最后的输出结果就是从0打印到9，每次打印间隔2s，并且是有序的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 拨打电话</title>
      <link href="2017/11/15/Android%20%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D/"/>
      <url>2017/11/15/Android%20%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[        <h2 id="拨打电话"   >          <a href="#拨打电话" class="heading-link"><i class="fas fa-link"></i></a><a href="#拨打电话" class="headerlink" title="拨打电话"></a>拨打电话</h2>      <p>Android拨打电话有两种方式，一个是 <strong>调用拨号盘</strong> ，然后用户点击拨号按钮，代码如下</p><pre><code>/**  * 调用拨号界面  * @param phone 电话号码  */  </code></pre><span id="more"></span><pre><code>private void call(String phone) &#123;      Intent intent = new Intent(Intent.ACTION_DIAL,Uri.parse(&quot;tel:&quot;+phone));      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);      startActivity(intent);  &#125;  </code></pre><p>另外的一种方式是 <strong>直接拨号</strong> ，代码如下:</p><pre><code>/**  * 调用拨号功能  * @param phone 电话号码  */  private void call(String phone) &#123;      Intent intent=new Intent(Intent.ACTION_CALL,Uri.parse(&quot;tel:&quot;+phone));      startActivity(intent);  &#125;  </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Html Canvas 自定义绘图</title>
      <link href="2017/10/19/Html%20Canvas%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%9B%BE/"/>
      <url>2017/10/19/Html%20Canvas%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[        <h3 id="Html-Canvas-自定义绘图"   >          <a href="#Html-Canvas-自定义绘图" class="heading-link"><i class="fas fa-link"></i></a><a href="#Html-Canvas-自定义绘图" class="headerlink" title="Html Canvas 自定义绘图"></a>Html Canvas 自定义绘图</h3>      <p>制作 Html 的时候我们总是不可避免的会遇到需要自定义 Canvas<br>绘图的情况，最近我在做网页的时候就遇到了需要需要自定义的绘图控件，效果图如下，框起来的地方就是我遇到的难点：<br><img src="https://file.2fun.xyz/card_canvas_show.png" alt="canvas效果"><br>这是一个可以变化的进度条，上面有一个标签指向进度的位置。直接用html标签组合不实用，于是我想到了使用canvas的方式来绘制。</p>        <h3 id="需求分析"   >          <a href="#需求分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3>      <ul><li>只需要简单引用一个js文件</li></ul><span id="more"></span><ul><li>实现一个类，所有操作可以通过该类方法直接设置</li><li>可以复用</li></ul>        <h3 id="实现类"   >          <a href="#实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3>      <p><code>js</code>是脚本语言，没有类的概念，但是我们可以使用方法来实现类似类的效果，具体方法是:</p><pre><code>//类function ClassName()&#123;    this.a = 0; //假设定义变量 a = 0    // ....变量定义 //    //方法    function functionName()&#123;        //具体交互        this.a = 1 //改变变量的值    &#125;&#125;</code></pre>        <h3 id="Canvas绘图"   >          <a href="#Canvas绘图" class="heading-link"><i class="fas fa-link"></i></a><a href="#Canvas绘图" class="headerlink" title="Canvas绘图"></a>Canvas绘图</h3>      <p>接下来我们来实现效果图的进度条效果，通过观察可以发现进度条控件可以分为两个部分，一个是底下的长条，另一部分就是上面的标签了。所以我们可以分为两个步骤来实现这个效果。</p>        <h4 id="实现长条"   >          <a href="#实现长条" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现长条" class="headerlink" title="实现长条"></a>实现长条</h4>      <p>我们可以将进度条拆分为上下两层，底下的灰色圆角矩形和表示进度的橘色圆角矩形，因为两个圆角矩形的区别只有长度和颜色，所以我们可以定义一个方法，用来绘制指定长度和颜色的圆角矩形：</p><pre><code>/**画圆角矩形 * progress :进度1 -100 * color ：颜色*/this.drawRectLine = function(progress, color) &#123;    progress = Math.min(progress, 100);    progress = Math.max(progress, 0);    var height = this.canvas.getBoundingClientRect().height;        //进度条的高度    var lineHeight = height / 5;    var width = this.canvas.width - lineHeight / 2;                //设置填充颜色    this.ctx.fillStyle = color;        //开始绘制路径    this.ctx.beginPath();        //设置起点    this.ctx.moveTo(lineHeight / 2, height - lineHeight);    //终点的x坐标    var endX = progress / 100.0 * width;    endX = Math.max(endX, lineHeight / 2);        //绘制直线    this.ctx.lineTo(width - lineHeight / 2, height - lineHeight);        //绘制圆弧    this.ctx.arc(endX, height - lineHeight / 2, lineHeight / 2, -Math.PI / 2, Math.PI / 2);    this.ctx.lineTo(lineHeight / 2, height);    this.ctx.arc(lineHeight / 2, height - lineHeight / 2, lineHeight / 2, Math.PI / 2, -Math.PI / 2);        //填充路径    this.ctx.fill();&#125;</code></pre>        <h4 id="绘制进度标签"   >          <a href="#绘制进度标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#绘制进度标签" class="headerlink" title="绘制进度标签"></a>绘制进度标签</h4>      <p>进度标签分为地步的气泡和上面的文字，可以分为两步完成。首先实现气泡背景，方法与绘制圆角矩形类似，只需要根据形状绘制路径填充即可。接下来是绘制文字：</p><pre><code>//画文字this.drawText = function() &#123;    //设置文字的颜色    this.ctx.fillStyle = &quot;white&quot;;    //设置文字的字体    this.ctx.font = &quot;&quot; + this.canvas.height / 4 + &quot;px OpenSans&quot;;    //设置显示的文本    var s = &quot;筹款中&quot;    if(this.progress &gt;= 100)        s = &quot;完成&quot;    //根据进度计算文字的x坐标    var x = this.progress / 100.0 * (this.canvas.width) - this.ctx.measureText(s).width / 2;    if(x &lt; this.tagWidth / 2)        x = this.tagWidth / 2 - this.ctx.measureText(s).width / 2;    else if(x &gt; this.canvas.width - this.tagWidth)        x = this.canvas.width - this.tagWidth / 2 - this.ctx.measureText(s).width / 2;    var y = this.canvas.height / 5 * 1.5;    //绘制文字    this.ctx.fillText(s, x, y);&#125;</code></pre>        <h3 id="定义外部调用方法"   >          <a href="#定义外部调用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义外部调用方法" class="headerlink" title="定义外部调用方法"></a>定义外部调用方法</h3>      <p>实现了绘制的逻辑之后，我们还需要定义一个方法，来实现进度的显示和改变。</p><pre><code>// 设置进度this.setProgress = function(progress) &#123;    this.progress = progress;    this.showProgress();&#125;//显示进度this.showProgress = function() &#123;    this.drawRectLine(100.0, this.bgColor);    this.drawRectLine(this.progress, this.hiColor);    this.drawTag();    this.drawText();&#125;</code></pre>        <h3 id="注意事项"   >          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>      <p>这里有一个很大的坑，就是canvas默认是<code>300x150</code>的大小，就算你在html里面设置了宽高，它也只会根据这个大小进行拉伸，所以显示会有拉伸现象。<br><strong>解决办法：</strong> 根据canvas的大小对画布进行重新设置大小：</p><pre><code>//重新设置画布的大小，解决画布拉伸的问题this.canvas.width = this.canvas.offsetWidth;this.canvas.height = this.canvas.offsetHeight;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer （Python）变态跳台阶</title>
      <link href="2017/10/12/%E5%89%91%E6%8C%87Offer%20%EF%BC%88Python%EF%BC%89%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>2017/10/12/%E5%89%91%E6%8C%87Offer%20%EF%BC%88Python%EF%BC%89%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐在线编程平台"   >          <a href="#推荐在线编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐在线编程平台" class="headerlink" title="推荐在线编程平台"></a>推荐在线编程平台</h3>      <p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote>        <h3 id="分析"   >          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h3>      <span id="more"></span><p>这是“<a href="https://www.bearever.cn/archives/473">跳台阶</a>”的一个变形，我们可以用相同的思路来计算：</p><ol><li>令<code>f(n)</code>表示跳n级台阶的跳法</li><li>假设青蛙第一次跳了一级台阶，那么剩下n-1级台阶有<code>f(n-1)</code>种跳法； 如果第一次跳了两级台阶，则剩下n-2级台阶有<code>f(n-2)</code>种跳法。 </li><li>以此类推，可以得到： <code>f(n) = f(0) + f(1) + f(2) + ... + f(n-2) + f(n-1)</code> 通过这个公式，我们可以知道: <code>f(n-1) = f(0) + f(1) + f(2) + ... + f(n-2)</code></li><li>所以<code>f(n) = 2 * f(n-1)</code> 说明跳n级台阶的跳法就是跳上前一级跳法的两倍，所以我们可以通过递归来计算。 </li></ol>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-class Solution:    def jumpFloorII(self, number):        if number == 0:            return 0        elif number == 1:            return 1        else:            a = 1            for i in xrange(number - 1):                b = 2 * a                a = b            return a</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（Python） 跳台阶</title>
      <link href="2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐在线编程平台"   >          <a href="#推荐在线编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐在线编程平台" class="headerlink" title="推荐在线编程平台"></a>推荐在线编程平台</h3>      <p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote>        <h3 id="分析"   >          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h3>      <span id="more"></span><p>对于本题,前提只有一次 1阶或者2阶的跳法。 a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);<br>b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2) c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)<br>d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2 e.可以发现最终得出的是一个斐波那契数列：<br><img src="https://file.2fun.xyz/fibonacci_jump_function.png" alt="斐波那契数列"></p>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-class Solution:    def jumpFloor(self, number):        a = 1        b = 2        if number == 1:            return a        elif number == 2:            return b        # 循环计算        for i in range(number - 2):            # 设置临时变量记录加上之后的值            c = a + b            # 更新值            a = b            b = c        return b</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（Python） 斐波那契数列</title>
      <link href="2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐在线编程平台"   >          <a href="#推荐在线编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐在线编程平台" class="headerlink" title="推荐在线编程平台"></a>推荐在线编程平台</h3>      <p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 n&lt;=39</p></blockquote>        <h3 id="分析"   >          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h3>      <span id="more"></span><p>题目要求求出斐波那契数列的第n项，我们需要先弄明白什么是斐波那契数列，然后后就可以轻松的求解了。</p>        <h3 id="概念"   >          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念" class="headerlink" title="概念"></a>概念</h3>      <blockquote><p><strong>斐波那契数列：</strong><br>指的是这样一个数列：0、1、1、2、3、5、8、13、21、……在数学上，斐波纳契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*），用文字来说，就是斐波那契数列列由<br>0 和 1 开始，之后的斐波那契数列系数就由之前的两数相加。</p></blockquote>        <h3 id="思路"   >          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h3>      <p>根据斐波那契数列的概念，我们可以通过递归的方式求得第n项，但是这样计算量会很大，编程平台是不能通过的，提示时间超时。那么我们就优化一下算法，用递推的方式，将前面两个值的数据记录下来，循环添加前面两个数的值就可以了。</p>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-class Solution:    def Fibonacci(self, n):        a = 0        b = 1        if n == 0:            return a        elif n == 1:            return b        elif n == 2:            return 1        # 循环计算        for i in range(n - 1):            # 设置临时变量记录加上之后的值            c = a + b            # 更新值            a = b            b = c        return b</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（Python）旋转数组的最小数字</title>
      <link href="2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐在线编程平台"   >          <a href="#推荐在线编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐在线编程平台" class="headerlink" title="推荐在线编程平台"></a>推荐在线编程平台</h3>      <p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote>        <h3 id="分析"   >          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h3>      <span id="more"></span><p>由题目可以知道，原数组的右边大于左边，旋转之后的数组的最小值就是他们的分界，所以我们只需要找到这个分界就可以了。通过循环，一旦有一个值小于列表第一个值那么他就一定在分界处。</p>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-class Solution:    def minNumberInRotateArray(self, rotateArray):        if len(rotateArray) == 0:            return 0        min = rotateArray[0]        for x in rotateArray:            if x &lt; min:                min = x                break        return min</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（Python） 两个栈来实现队列</title>
      <link href="2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐在线编程平台"   >          <a href="#推荐在线编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐在线编程平台" class="headerlink" title="推荐在线编程平台"></a>推荐在线编程平台</h3>      <p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote>        <h3 id="分析"   >          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h3>      <span id="more"></span><p>题目要求我们用两个栈实现队列的效果，在python里面没有栈，但是我们可以用List模拟。<code>list.append(obj)</code>和<code>list.pop()</code>可以表示栈进和出操作。所以我们只需要想办法实现队列的队首删除的效果：我们可以用一个栈1来记录插入，用栈2将记录的数据进行颠倒顺序，这样获取栈1的第一个元素就是等同于获取栈2的最后一个元素。</p>        <h4 id="基本概念"   >          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4>      <ul><li><strong>栈</strong> 栈是一种特殊的线性表，限定在表头进行插入和删除操作。 </li><li><strong>队列</strong> 队列是一种特殊的线性表，限定在表尾插入，表头删除。 </li></ul>        <h4 id="相关方法"   >          <a href="#相关方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4>      <p><strong>append()</strong></p><blockquote><pre><code>list.append(obj)</code></pre><ul><li><code>obj</code> -- 添加到列表末尾的对象。</li></ul></blockquote><p><strong>pop()</strong></p><blockquote><pre><code>list.pop(obj=list[-1])</code></pre><ul><li><code>obj</code> -- 可选参数，要移除列表元素的对象，默认最后一个</li></ul></blockquote>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-class Solution:    def __init__(self):        self.stack1 = []        self.stack2 = []    def push(self, node):        self.stack1.append(node)    def pop(self):        if self.stack2 == []:            while self.stack1:                p = self.stack1.pop()                self.stack2.append(p)        return self.stack2.pop()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（Python）重建二叉树</title>
      <link href="2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐在线编程平台"   >          <a href="#推荐在线编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐在线编程平台" class="headerlink" title="推荐在线编程平台"></a>推荐在线编程平台</h3>      <p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote>        <h3 id="相关知识"   >          <a href="#相关知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3>      <span id="more"></span><p>题目要求根据前序遍历序列和中序遍历序列还原二叉树，我们先对二叉树进行简单的介绍，在简单介绍前序遍历、中序遍历、后序遍历的原理。</p>        <h4 id="基本概念"   >          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4>      <p>二叉树是树的特殊一种:每个结点最多有两颗子树，结点的度最大为2;左子树和右子树是有顺序的，次序不能颠倒。<br><img src="https://file.2fun.xyz/twoforktree1.png" alt="二叉树"></p>        <h4 id="遍历"   >          <a href="#遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4>      <ul><li>前序遍历 访问顺序：根节点 <code>-&gt;</code> 左子树 <code>-&gt;</code> 右子树。 </li><li>中序遍历 访问顺序：左子树 <code>-&gt;</code> 根节点 <code>-&gt;</code> 右子树。 </li><li>后序遍历 访问顺序：左子树 <code>-&gt;</code> 右子树 <code>-&gt;</code> 根节点。 </li></ul><p><img src="https://file.2fun.xyz/twoforktree_bianli.png" alt="二叉树遍历效果图"></p>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:        def reConstructBinaryTree(self, pre, tin):        if (len(pre) == 0):            return None        elif(len(pre) == 1):            return TreeNode(pre[0])        else:            rootNode = TreeNode(pre[0])            #遍历获得左节点            rootNode.left = self.reConstructBinaryTree(                pre[1: tin.index(pre[0]) + 1], tin[:tin.index(pre[0])])            #遍历获得右节点            rootNode.right = self.reConstructBinaryTree(                pre[tin.index(pre[0]) + 1:], tin[tin.index(pre[0]) + 1:])            return rootNode</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（Python） 从尾到头打印链表</title>
      <link href="2017/10/10/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>2017/10/10/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐编程平台"   >          <a href="#推荐编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐编程平台" class="headerlink" title="推荐编程平台"></a>推荐编程平台</h3>      <p><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>输入一个链表，从尾到头打印链表每个节点的值。</p></blockquote>        <h3 id="分析"   >          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h3>      <span id="more"></span><p>链表的结构如下：</p><pre><code>class ListNode:     def __init__(self, x):         self.val = x         self.next = None</code></pre><p>题目比较简单，要求是逆序打印链表的值，通过查看其他的语言版本的方法函数，我们可以知道系统判断成功的要求是返回一个逆序的数组。所以我们可以先构造一个空数组，通过判断<code>ListNode</code>的<code>next</code>查看下一个<code>ListNode</code>的值，将<code>ListNode</code>的<code>val</code>保存在数组里面就可以了。需要注意的时题目要求逆序，所以我们在保存数据的时候要插入到首位，涉及的方法为<code>insert()</code>。<br><strong>insert()</strong></p><blockquote><pre><code>list.insert(index, obj)</code></pre><ul><li><code>index </code>-- 对象 obj 需要插入的索引位置。</li><li><code>obj </code>-- 要插入列表中的对象。</li></ul></blockquote>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    # 返回从尾部到头部的列表值序列，例如[1,2,3]    def printListFromTailToHead(self, listNode):        l = []        head = listNode        while head:            l.insert(0, head.val)            head = head.next        return l</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（Python）替换空格</title>
      <link href="2017/10/10/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>2017/10/10/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐编程平台"   >          <a href="#推荐编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐编程平台" class="headerlink" title="推荐编程平台"></a>推荐编程平台</h3>      <p><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are<br>Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote>        <h3 id="分析"   >          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h3>      <span id="more"></span><p>题目要求替换空格，使用<code>Python</code>可以轻松的实现这个效果,使用Python的内置函数<code>replace</code>即可 <strong>replace()</strong></p><blockquote><pre><code>str.replace(old, new[, max])</code></pre><ul><li><code>old</code> -- 将被替换的子字符串。</li><li><code>new</code> -- 新字符串，用于替换old子字符串。</li><li><code>max</code> -- 可选字符串, 替换不超过 max 次</li></ul></blockquote>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-class Solution:    # s 源字符串    def replaceSpace(self, s):        # write code here        return s.replace(&#39; &#39;,&#39;%20&#39;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer（Python）二维数组中的查找</title>
      <link href="2017/10/10/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>2017/10/10/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[        <h3 id="推荐在线编程平台"   >          <a href="#推荐在线编程平台" class="heading-link"><i class="fas fa-link"></i></a><a href="#推荐在线编程平台" class="headerlink" title="推荐在线编程平台"></a>推荐在线编程平台</h3>      <p><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com/" >牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="题目描述"   >          <a href="#题目描述" class="heading-link"><i class="fas fa-link"></i></a><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3>      <blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote>        <h3 id="分析"   >          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h3>      <span id="more"></span><p>由题意我们可以知道，该二维数组最左上角的元素最小，最右下角的元素最大，所以我们可以先判断目标值与这两个元素的大小。这里有两种情况我们可以分别考虑：</p><ul><li><p><strong>目标超过这两个元素的范围</strong><br>如果目标小于数组最小值或者大于最大值，那么我们就可以判断出它不在二维数组里面。</p></li><li><p><strong>目标在两个元素之间</strong><br>当目标元素在两个值之间的时候，我们可以对二维数组进行遍历，判断每一层的元素：如果目标元素比该层第一个小或者比最后一个元素大，则说明不在该层，直接跳过。如果目标元素在该层范围里面，则遍历该层，如果没有元素与之匹配则说明该二维数组不包含目标值。</p></li></ul>        <h3 id="代码"   >          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h3>      <pre><code># -*- coding:utf-8 -*-class Solution:    # array 二维列表    def Find(self, target, array):        if (array == None or len(array) == 0):            return 0        for x in array:            if (x == None or len(x) == 0):                return 0            if (x[0] &gt; target and x[len(x) - 1] &lt; target):                break            for y in x:                if (y == target):                    return 1        return 0</code></pre><p>也可以直接用两个for循环判断每一个元素与目标的值</p><pre><code># -*- coding:utf-8 -*-class Solution:    # array 二维列表    def Find(self, target, array):        for x in array:            for y in x:                if (y == target):                    return 1        return 0</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建自己的VPN服务器</title>
      <link href="2017/10/07/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84VPN%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>2017/10/07/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84VPN%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[        <h3 id="购买服务器"   >          <a href="#购买服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3>      <p>搭建VPN的重要一步就是选择一个境外的服务器用来代理数据，这里推荐使用<a href="https://www.vultr.com/?ref=7226530"><br><strong>vultr</strong></a>，性价比高，按小时计费，不满意直接销毁就可以了。<br>可以点击下面的图片注册，对我们都有好处的。<br><a href="https://www.vultr.com/?ref=7226530"><img src="https://www.vultr.com/media/banner_1.png"></a></p>        <h3 id="安装Shadowsocks脚本"   >          <a href="#安装Shadowsocks脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装Shadowsocks脚本" class="headerlink" title="安装Shadowsocks脚本"></a>安装Shadowsocks脚本</h3>      <p>Shadowsocks是一个基于python的轻量级socks代理软件,可以在任何系统简单的实现访问被屏蔽的网站。网友也常称为科学上网，简称ss,在此分享与记录CentOS一键安装shadowsocks脚本。</p><span id="more"></span>        <h4 id="使用root用户登录，运行以下命令：按照提示输入即可"   >          <a href="#使用root用户登录，运行以下命令：按照提示输入即可" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用root用户登录，运行以下命令：按照提示输入即可" class="headerlink" title="使用root用户登录，运行以下命令：按照提示输入即可"></a>使用root用户登录，运行以下命令：按照提示输入即可</h4>      <pre><code>wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</code></pre>        <h4 id="安装完成后，脚本提示如下："   >          <a href="#安装完成后，脚本提示如下：" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装完成后，脚本提示如下：" class="headerlink" title="安装完成后，脚本提示如下："></a>安装完成后，脚本提示如下：</h4>      <pre><code>Congratulations, shadowsocks install completed!Your Server IP:your_server_ipYour Server Port:8989Your Password:your_passwordYour Local IP:127.0.0.1Your Local Port:1080Your Encryption Method:aes-256-cfbWelcome to visit:http://teddysun.com/342.htmlEnjoy it!</code></pre>        <h4 id="卸载方法"   >          <a href="#卸载方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h4>      <pre><code>./shadowsocks.sh uninstall</code></pre>        <h4 id="配置文件"   >          <a href="#配置文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4>      <p>配置文件路径为：<code>/etc/shadowsocks.json</code> 单用户配置：</p><pre><code>&#123;    &quot;server&quot;:&quot;your_server_ip&quot;,    &quot;server_port&quot;:8989,    &quot;local_address&quot;:&quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;yourpassword&quot;,    &quot;timeout&quot;:300,    &quot;method&quot;:&quot;aes-256-cfb&quot;,    &quot;fast_open&quot;: false&#125;</code></pre><p>多用户配置：</p><pre><code>&#123;    &quot;server&quot;:&quot;0.0.0.0&quot;,    &quot;local_address&quot;:&quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,    &quot;port_password&quot;:&#123;         &quot;8989&quot;:&quot;password0&quot;,         &quot;9001&quot;:&quot;password1&quot;,         &quot;9002&quot;:&quot;password2&quot;,         &quot;9003&quot;:&quot;password3&quot;,         &quot;9004&quot;:&quot;password4&quot;    &#125;,    &quot;timeout&quot;:300,    &quot;method&quot;:&quot;your_encryption_method&quot;,    &quot;fast_open&quot;: false&#125;</code></pre>        <h4 id="五、相关使用命令"   >          <a href="#五、相关使用命令" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、相关使用命令" class="headerlink" title="五、相关使用命令"></a>五、相关使用命令</h4>      <ul><li><p>启动 <code>/etc/init.d/shadowsocks start</code></p></li><li><p>停止 <code>/etc/init.d/shadowsocks stop</code></p></li><li><p>重启 <code>/etc/init.d/shadowsocks restart</code></p></li><li><p>状态 <code>/etc/init.d/shadowsocks status</code></p></li></ul><p><strong>使用方法：</strong> 默认配置服务器端口：8989客户端端口：1080，密码：自己设定（如不设定，默认为teddysun.com），多用户配置后需要<br><strong>重启</strong> shadowsocks服务。</p>        <h3 id="安装BBR加速"   >          <a href="#安装BBR加速" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装BBR加速" class="headerlink" title="安装BBR加速"></a>安装BBR加速</h3>      <p>终端输入</p><pre><code>wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</code></pre><p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。</p>        <h3 id="客户端下载"   >          <a href="#客户端下载" class="heading-link"><i class="fas fa-link"></i></a><a href="#客户端下载" class="headerlink" title="客户端下载"></a>客户端下载</h3>      <ul><li><p><strong>Win:</strong> <span class="exturl"><a class="exturl__link"   href="https://file.2fun.xyz/Shadowsocks_win-4.0.6.zip" >点击下载</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><strong>Mac:</strong> <span class="exturl"><a class="exturl__link"   href="https://file.2fun.xyz/Shadowsocks_macos-1.6.1.zip" >点击下载</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><strong>Android：</strong> <span class="exturl"><a class="exturl__link"   href="https://file.2fun.xyz/shadowsocks_android-4-1-8.zip" >点击下载</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li></ul>        <h3 id="注意事项"   >          <a href="#注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>      <p>用centOS6系统配置了多用户之后可能会出现多用户配置失败的问题，这个问题是由于系统的防火墙关闭了端口，我们可以在服务器提供商的控制面板设置防火墙。这里简单写下Vultr的防火墙设置：<br><strong>进入防火墙配置</strong> <img src="https://file.2fun.xyz/vultr_firwall_panal.png" alt="进入防火墙设置"><br><strong>配置防火墙</strong> 将你在<code>/etc/shadowsocks.json</code>里面配置的端口添加进去<br><img src="https://file.2fun.xyz/vultr_firwall_setting.png" alt="配置防火墙"><br>如果设置面板添加了端口之后仍然不行可以尝试命令行的方式：</p><ul><li><p>查看开启的端口列表： <code>firewall-cmd --list-ports</code></p></li><li><p>开启某个端口 <code>firewall-cmd --zone=public --add-port=9001/tcp --permanent</code>，此处的9001替换为你想要开启的端口号</p></li><li><p>重启防火墙 <code>firewall-cmd --reload</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android侧滑菜单实现</title>
      <link href="2017/09/29/Android%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>2017/09/29/Android%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[        <h3 id="引言"   >          <a href="#引言" class="heading-link"><i class="fas fa-link"></i></a><a href="#引言" class="headerlink" title="引言"></a>引言</h3>      <p>所有代码已经上传到 <strong><span class="exturl"><a class="exturl__link"   href="https://github.com/Luomingbear/SedeslipLayout" >GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong><br>，有兴趣的可以下载查看。 在平时的生活中，我们经常会看到一些使用了侧滑菜单的应用，例如QQ、滴滴等，侧滑动画可以增加应用的活性，显得不那么死板，如图：<br><img src="https://file.2fun.xyz/sidesliplayout_gcross_shows.gif" alt="“机核”侧滑菜单"><br>今天我们的任务是实现了一通用的侧滑布局，不仅仅支持左右滑，还支持上下滑。</p>        <h3 id="自定义FrameLayout"   >          <a href="#自定义FrameLayout" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义FrameLayout" class="headerlink" title="自定义FrameLayout"></a>自定义FrameLayout</h3>      <p>我选择通过自定义的FrameLayout来实现侧滑菜单的效果，因为我希望能够实现四个边都可以侧滑，并且可以通过配置来自由的设置侧滑的view，每个侧滑菜单可以自由的设定显示比例。于是我设计了一个<code>ViewItem</code>的类，用来存放view的缩放比例信息。</p><span id="more"></span><pre><code> //布局和缩放比例的类,已经省略 set/get方法    class ViewItem &#123;        View layout; //View视图        float scale; //显示比例    &#125;</code></pre>        <h3 id="显示主界面"   >          <a href="#显示主界面" class="heading-link"><i class="fas fa-link"></i></a><a href="#显示主界面" class="headerlink" title="显示主界面"></a>显示主界面</h3>      <p>通过重写<code>onLayout(boolean changed, int left, int top, int right, int bottom)</code>，我们可以自由的设定view的显示位置和大小。</p><pre><code>   @Override    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;        //移除所有的布局        removeAllViewsInLayout();        //加入主界面        if (mHomeView != null) &#123;            addView(mHomeView);            mHomeView.layout(0, 0, mWidth, mHeight);        &#125;    &#125;</code></pre><p>其中<code>mWidth</code>和<code>mHeight</code>表示空间的宽高，可以在<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>方法里面设置，每次当空间大小发生变化的时候就更新宽高。 最后效果如下：<br><img src="https://file.2fun.xyz/sidesliplayout_homeview.png" alt="显示主界面"></p>        <h3 id="显示侧滑的菜单页面"   >          <a href="#显示侧滑的菜单页面" class="heading-link"><i class="fas fa-link"></i></a><a href="#显示侧滑的菜单页面" class="headerlink" title="显示侧滑的菜单页面"></a>显示侧滑的菜单页面</h3>      <p>在上面的代码后面加上如下的方法，添加上下左右的侧滑菜单。</p><pre><code>//加入左边的界面        addItemView(mLeftViewItem, Gravity.LEFT);        //加入上面边的界面        addItemView(mTopViewItem, Gravity.TOP);        //加入右边的界面        addItemView(mRightViewItem, Gravity.RIGHT);        //加入下边的界面        addItemView(mBottomViewItem, Gravity.BOTTOM);</code></pre><p>其中<code>addItemView(SideslipViewItem viewItem, int position)</code>是根据传递的viewItem和position设置显示的内容和位置</p><pre><code> /**     * 添加侧滑的view     *     * @param viewItem     * @param position 位置     */    private void addItemView(SideslipViewItem viewItem, int position) &#123;        if (viewItem == null || viewItem.getLayout() == null)            return;        switch (position) &#123;            case Gravity.LEFT: &#123;                int x = (int) (-mWidth * viewItem.getScale());                viewItem.getLayout().layout(x, 0, 0, mHeight);            &#125;            case Gravity.TOP: &#123;                int t = (int) (-mHeight * viewItem.getScale());                viewItem.getLayout().layout(0, t, 0, 0);            &#125;            case Gravity.RIGHT: &#123;                int r = (int) (mWidth * (1 + viewItem.getScale()));                viewItem.getLayout().layout(mWidth, 0, r, mHeight);            &#125;            case Gravity.BOTTOM: &#123;                int b = (int) (mHeight * (1 + viewItem.getScale()));                viewItem.getLayout().layout(0, mHeight, mWidth, b);            &#125;        &#125;    &#125;</code></pre>        <h3 id="添加手指交互"   >          <a href="#添加手指交互" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加手指交互" class="headerlink" title="添加手指交互"></a>添加手指交互</h3>      <p>为了不影响内部的view的点击响应，我们需要在<code>onInterceptTouchEvent(MotionEvent ev)</code>里面处理手指触摸逻辑，返回值为<code>true</code>则说明拦截掉触摸事件，不向下层传递。先定义几个变量：</p><pre><code>    private float mTouchStartX = 0;  //手指按下的x    private float mTouchStartY = 0; //手指按下的y    private float mTouchMoveX = 0; //移动的x    private float mTouchMoveY = 0; //移动的y    private float mInterceptMoveX = 0; //手指移动的x    private float mInterceptMoveY = 0; //手指移动的y</code></pre><p>重写<code>onInterceptTouchEvent(MotionEvent ev)</code>:</p><pre><code>    @Override    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;        switch (ev.getAction()) &#123;            case MotionEvent.ACTION_DOWN: &#123;                //保存手指按下的坐标                mTouchStartX = ev.getX();                mTouchStartY = ev.getY();                mInterceptMoveX = mTouchStartX;                mInterceptMoveY = mTouchStartY;                mTouchMoveX = mTouchStartX;                mTouchMoveY = mTouchStartY;                touchDownTime = System.currentTimeMillis(); //保存当前时间                break;            &#125;            case MotionEvent.ACTION_MOVE: &#123;                float x = ev.getX();                float y = ev.getY();                mInterceptMoveX = x - mInterceptMoveX;                mInterceptMoveY = y - mInterceptMoveY;                                /**                 * 先判断手指按下时是否在边界                 * 如果在边界，并且手指滑动的距离大于10； 则拦截触摸事件                 */                if (computeIsTouchInSide(mTouchStartX, mTouchStartY) || isShowingSide) &#123;                    if (Math.abs(mInterceptMoveX) &gt; 10 || Math.abs(mInterceptMoveY) &gt; 10) &#123;                        return true;                    &#125;                &#125;                break;            &#125;        &#125;        return super.onInterceptTouchEvent(ev);    &#125;   /**     * 计算手指按下的位置是否是在侧滑响应区域     *     * @param x 按下x     * @param y 按下y     * @return     */    private boolean computeIsTouchInSide(float x, float y) &#123;        if (x &lt; mWidth / 4 || x &gt; mWidth / 4f * 3 || y &lt; mHeight / 4 || y &gt; mHeight / 4f * 3)            return true;        return false;    &#125;</code></pre><p>拦截了触摸事件之后，我们在<code>onTouchEvent(MotionEvent event)</code>里面进行事件的处理。因为要实现手指跟随的效果，所以我们要对<code>MotionEvent.ACTION_MOVE</code>进行处理。</p><pre><code>    @Override    public boolean onTouchEvent(MotionEvent event) &#123;        switch (event.getAction()) &#123;            case MotionEvent.ACTION_MOVE: &#123;                float x = event.getX();                float y = event.getY();                //变化的值                float disX = x - mTouchMoveX;                float disY = y - mTouchMoveY;                //更新上一次手指滑动的坐标                mTouchMoveX = x;                mTouchMoveY = y;                Log.d(TAG, &quot;onTouchEvent: x:&quot; + disX);                //移动view                touchMoveViews(disX, disY);                break;            &#125;    &#125;</code></pre><p>最后效果如下： <img src="https://file.2fun.xyz/sidesliplayout_normal_move.gif" alt="简单的手指交互"></p>        <h3 id="添加动画效果"   >          <a href="#添加动画效果" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加动画效果" class="headerlink" title="添加动画效果"></a>添加动画效果</h3>      <p>给布局加上动画，当手指抬起来的时候就执行，在上面的代码里面加上<code>MotionEvent.ACTION_CANCEL</code>和<code>MotionEvent.ACTION_UP</code>的处理</p><pre><code>            case MotionEvent.ACTION_CANCEL:            case MotionEvent.ACTION_UP: &#123;                float x = event.getX();                float y = event.getY();                //移动距离不够则不进行动画                if (Math.abs(x - mTouchStartX) &lt; 50 &amp;&amp; Math.abs(y - mTouchStartY) &lt; 50)                    break;                /**                 * 计算手指抬起的位置，判断是否应该显示或者隐藏侧滑菜单                 */                if (computeIsShowSide(event.getX(), event.getY()))                    animateShowSideView(event.getX(), event.getY(), mMoveSide);                else                    animateHideSideView(event.getX(), event.getY(), mMoveSide);                break;            &#125;</code></pre><p>判断是否需要显示或者隐藏的方法如下:</p><pre><code>   /**     * 计算是需要显示侧滑菜单还是隐藏     *     * @return true:显示侧滑菜单 false ：隐藏侧滑菜单     */    private boolean computeIsShowSide(float x, float y) &#123;        //如果手指放下的时候没有在规定区域，则不进行动画        if (isShowingSide &amp;&amp; !computeIsTouchInSide(mTouchStartX, mTouchStartY))            return true;        else if (!isShowingSide &amp;&amp; !computeIsTouchInSide(mTouchStartX, mTouchStartY))            return false;        long time = System.currentTimeMillis() - touchDownTime;        float speed = 0;        switch (mMoveSide) &#123;            case Gravity.LEFT: &#123;                speed = (x - mTouchStartX) / time;                if (speed &gt; 1)                    return true;                break;            &#125;            case Gravity.RIGHT: &#123;                speed = (x - mTouchStartX) / time;                if (speed &lt; -1)                    return true;                break;            &#125;            case Gravity.TOP: &#123;                speed = (y - mTouchStartY) / time;                if (speed &gt; 1)                    return true;                break;            &#125;            case Gravity.BOTTOM: &#123;                speed = (y - mTouchStartY) / time;                if (speed &lt; -1)                    return true;                break;            &#125;        &#125;        //手指滑动超过半个屏幕也可以启动动画        if ((x - mTouchStartX) &gt; mWidth / 2 || (y - mTouchStartY) &gt; mHeight / 2)            return true;        return false;    &#125;</code></pre><p>设置动画，通过<code>ObjectAnimator</code>可以设置动画，我们只需要用它来获取中间的插值，然后后更新view的位置就可以了</p><pre><code> /**     * 执行view动画     * 在手指抬起的时候执行     *     * @param x     * @param y     * @param gravity //执行动画的侧边     */    private void animateShowSideView(float x, float y, int gravity) &#123;        float startVal = 0;        float endVal = 0;        switch (gravity) &#123;            case Gravity.LEFT: &#123;                if (mLeftViewItem == null)                    break;                startVal = mLeftViewItem.getLayout().getX();                endVal = 0;                break;            &#125;            case Gravity.TOP: &#123;                if (mTopViewItem == null)                    break;                startVal = mTopViewItem.getLayout().getY();                endVal = 0;                break;            &#125;            case Gravity.RIGHT: &#123;                if (mTopViewItem == null)                    break;                startVal = mRightViewItem.getLayout().getX();                endVal = (1 - mRightViewItem.getScale()) * mWidth;                break;            &#125;            case Gravity.BOTTOM: &#123;                if (mBottomViewItem == null)                    break;                startVal = mBottomViewItem.getLayout().getY();                endVal = (1 - mBottomViewItem.getScale()) * mHeight;                break;            &#125;        &#125;        //清除之前的动画        clearAnimation();        /**         * 主界面滑动         */        BounceInterpolator bounceInterpolator = new BounceInterpolator();  //弹簧效果        final ObjectAnimator animate = ObjectAnimator.ofFloat(this, &quot;sideslip&quot;, startVal, endVal);        animate.setInterpolator(bounceInterpolator);        animate.setDuration(mAnimateTime);        animate.start();        animate.addUpdateListener(updateListener);        //正在显示侧滑菜单        isShowingSide = true;    &#125;</code></pre><p>动画更新的监听器,对每一帧view的位置进行设置。</p><pre><code>//动画更新监听    private ValueAnimator.AnimatorUpdateListener updateListener = new ValueAnimator.AnimatorUpdateListener() &#123;        @Override        public void onAnimationUpdate(ValueAnimator animation) &#123;            float cVal = (float) animation.getAnimatedValue();            Log.i(TAG, &quot;onAnimationUpdate: &quot; + cVal);            switch (mMoveSide) &#123;                case Gravity.LEFT: &#123;                    if (mLeftViewItem != null)                        mLeftViewItem.getLayout().setX(cVal);                    break;                &#125;                case Gravity.TOP: &#123;                    if (mTopViewItem != null)                        mTopViewItem.getLayout().setY(cVal);                    break;                &#125;                case Gravity.RIGHT: &#123;                    if (mRightViewItem != null)                        mRightViewItem.getLayout().setX(cVal);                    break;                &#125;                case Gravity.BOTTOM: &#123;                    if (mBottomViewItem != null)                        mBottomViewItem.getLayout().setY(cVal);                    break;                &#125;            &#125;        &#125;    &#125;;</code></pre><p>最后的效果如下: <img src="https://file.2fun.xyz/sidesliplayout_animate_show.gif" alt="加上动画"></p>        <h3 id="添加阴影"   >          <a href="#添加阴影" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加阴影" class="headerlink" title="添加阴影"></a>添加阴影</h3>      <p>侧滑菜单弹出之后，我们可能希望大家把注意力放在侧滑菜单上面，所以我们可以给其他地方加上阴影，就像是<code>Dialog</code>弹出的感觉，对此，我的方法是在主界面上面覆盖一个<code>View</code>，当弹窗出来就调整<code>View</code>的背景颜色。<br>先加入一个阴影View,在添加了主界面之后添加阴影View，这样就可以覆盖在主界面上面了。</p><pre><code>        //加入主界面        if (mHomeView != null) &#123;            addView(mHomeView);            mHomeView.layout(0, 0, mWidth, mHeight);        &#125;                //添加阴影view        mShadeView = new View(getContext());        ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);        mShadeView.setLayoutParams(params);        addView(mShadeView);</code></pre><p>当侧滑菜单滑动的时候去改变阴影的透明度就可以实现动态的阴影效果了，这里我已左边的侧滑菜单为例：在<code>moveLeftView(float mx)</code>，在后面加如下的函数：</p><pre><code>            //计算移动的位置所占的比例            //菜单完全不可见的x坐标 减去 当前x坐标就是变化值，再求百分比就可以了            float change = Math.abs((-mWidth * mLeftViewItem.getScale()) - mLeftViewItem.getLayout().getX());            float p = change / (mWidth * mLeftViewItem.getScale());            mShadeView.setAlpha(p);</code></pre><p>最终效果: <img src="https://file.2fun.xyz/sidesliplayout_add_shade.gif" alt="带阴影的效果"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LayoutManager详解及使用（二）</title>
      <link href="2017/09/20/LayoutManager%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2017/09/20/LayoutManager%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bearever.cn/archives/284">上一篇文章</a>介绍了LayoutManager的基本知识，这一篇文章我们来进行一个实际的功能开发，制作一个滚动的Banner，没什么比写代码更加爽的事情了————吧？</p>        <h3 id="效果图"   >          <a href="#效果图" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3>      <p><img src="https://file.2fun.xyz/recycler2017-09-20-111930.gif" alt="banner预览图"><br>中间的卡片显示的更大一点，两边可以看到旁边的卡片的一角，离中心距离越近卡片越大。</p>        <h3 id="准备"   >          <a href="#准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#准备" class="headerlink" title="准备"></a>准备</h3>      <p>正式编写前，我们先新建一个<code>MyLayoutManager</code>继承至<code>RecyclerView.LayoutManager</code>并且实现一个必须实现的方法：</p><span id="more"></span><pre><code>  @Override    public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123;        return new RecyclerView.LayoutParams(RecyclerView.LayoutParams.MATCH_PARENT,         RecyclerView.LayoutParams.WRAP_CONTENT);    &#125;</code></pre>        <h3 id="简单显示"   >          <a href="#简单显示" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单显示" class="headerlink" title="简单显示"></a>简单显示</h3>      <p>首先我们先让屏幕有东西显示出来，先不考虑数据的大小，adapter的所有数据显示出来,重写<code>onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state)</code>方法，如下：</p><pre><code>  private int offsetX = 0; //水平偏移  private int mLeftX = 0; //卡片左端点的位置  @Override    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;        //没有数据就不进行处理        if (getItemCount() == 0) &#123;            removeAndRecycleAllViews(recycler);            return;        &#125;        //将所有的子view临时移除并且回收        detachAndScrapAttachedViews(recycler);        //进行布局        offsetX = 0;        for (int i = 0; i &lt; getItemCount(); i++) &#123;            View child = recycler.getViewForPosition(i);            addView(child);            measureAndLayout(child, i);        &#125;    &#125;     /**     * 计算view的大小并且设置位置     *     * @param view     目标view     * @param position 在数据里面的位置     */    private void measureAndLayout(View view, int position) &#123;        //开始计算大小        measureChildWithMargins(view, 0, 0);        //计算宽度        int width = getDecoratedMeasuredWidth(view);        //计算高度        int height = getDecoratedMeasuredHeight(view);        //将view放置在RecyclerView里面        layoutDecoratedWithMargins(view, mLeftX , 0, mLeftX + width, height);        //更新水平位移        offsetX += width;    &#125;</code></pre><p>效果如下: <img src="https://file.2fun.xyz/slim-show.png" alt="简单的显示"></p>        <h3 id="简单交互"   >          <a href="#简单交互" class="heading-link"><i class="fas fa-link"></i></a><a href="#简单交互" class="headerlink" title="简单交互"></a>简单交互</h3>      <p>接下来我们来添加简单的手指滑动交互：</p><pre><code>    /**     * 允许水平滑动     *     * @return     */    @Override    public boolean canScrollHorizontally() &#123;        return true;    &#125;    /**     * 禁止竖直滑动     *     * @return     */    @Override    public boolean canScrollVertically() &#123;        return false;    &#125;    @Override    public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;        Log.i(TAG, &quot;scrollHorizontallyBy: &quot; + dx);        //移动元素        offsetChildrenHorizontal(-dx);        offsetX -= dx;        return -dx;    &#125;</code></pre>        <h3 id="添加回收机制"   >          <a href="#添加回收机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加回收机制" class="headerlink" title="添加回收机制"></a>添加回收机制</h3>      <p><code>RecyclerView</code>的强大之处在于资源回收复用，上面的代码并没有体现，接下来我们来写一个简单的水平列表的<code>LayoutManager</code>，先看效果图：<br><img src="https://file.2fun.xyz/recycler_2017091915543.gif" alt="添加了回收机制的滑动效果"><br>实现回收的一个重要的点就是判断哪一个view需要remove，哪些只需要detach，这里我定义了几个变量用来判断，</p><pre><code>    private int maxCache = 3; //最大的缓存数量    private int mLeftIndex = 0; //缓存最左边的卡片的下标    private int mRightIndex = 0; //缓存最右边的卡片的下标    private int mCenterIndex = 0; //中间的卡片的下标</code></pre><p>如果view的位置小于<code>mLeftIndex</code>或者大于<code>mRightIndex</code>，则remove，否则只需要detach。所以重点就变成了怎么显示区域可见的view的位置下标。我们暂时假设每一个卡片的宽度是一致的，在实际的应用中，Banner卡片的宽度是一致的。我们需要记录view的偏移量，根据偏移量来计算可视范围的view的下标。下面定义几个变量：</p><pre><code>    private int mOffsetX = 0; //水平位移    private int mItemWidth = 1; //单个卡片宽度    private int mLeftX = 0; //卡片左端点的位置</code></pre>        <h4 id="我的思路"   >          <a href="#我的思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h4>      <blockquote><p>1.在view移动的时候更新<code>mOffsetX</code>和<code>mLeftX</code>，这两个变量的意义在代码里面详细解释。<br>2.通过<code>mOffsetX</code>和<code>mItemWidth</code>计算可视范围的卡片下标。 3.对布局中的view下标进行判断，移除不需要的。<br>4.重新添加view，移动view。</p></blockquote><p>代码如下：</p><pre><code>    @Override    public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;        //dx&gt;0 左滑        //实际要滑动的距离        int travel = dx;        //计算偏移量        mOffsetX += dx;        mLeftX -= travel;        //更新下标        updateIndex();        //移除显示区外的卡片        removeUnuseCard(recycler, state);        //重新添加        layoutItems(recycler, state);        //移动        offsetChildrenHorizontal(travel);        Log.i(TAG, &quot;scrollHorizontallyBy: count:&quot; + getChildCount());        return travel;    &#125;    /**     * 更新下标     */    private void updateIndex() &#123;        /**         * 计算中心卡片的下标         */        mCenterIndex = (mOffsetX) / mItemWidth;        //如果位移量除以 单个卡片的宽度的余数大于半个卡片则说明这个余下的卡片已经超过半个屏幕了        if (mOffsetX % mItemWidth &gt; mItemWidth / 2) &#123;            mCenterIndex++;        &#125;        mCenterIndex = Math.max(0, mCenterIndex);        mCenterIndex = Math.min(getItemCount() - 1, mCenterIndex);        /**         * 计算最左边卡片的下标         */        mLeftIndex = mCenterIndex - maxCache / 2;        mLeftIndex = Math.max(0, mLeftIndex);        /**         * 计算最右边卡片的下标         */        mRightIndex = mLeftIndex + maxCache - 1;        mRightIndex = Math.min(getItemCount() - 1, mRightIndex);    &#125;    /**     * 移除不需要的卡片     */    private void removeUnuseCard(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;        if (getChildCount() == 0)            return;        /**         * 将显示范围外的完全移除         */        for (int i = 0; i &lt; getChildCount(); i++) &#123;            View view = getChildAt(i);            if (getPosition(view) &lt; mLeftIndex || getPosition(view) &gt; mRightIndex) &#123;                removeAndRecycleView(view, recycler);            &#125;        &#125;    &#125;</code></pre><p>打印log，查看页面的view数量，发现稳定在3个<br><img src="https://file.2fun.xyz/logcat_child_count_3.png" alt="log信息"></p>        <h3 id="加入缩放效果"   >          <a href="#加入缩放效果" class="heading-link"><i class="fas fa-link"></i></a><a href="#加入缩放效果" class="headerlink" title="加入缩放效果"></a>加入缩放效果</h3>      <p><img src="https://file.2fun.xyz/recycler_20170920.gif" alt="卡片缩放"><br>下面我们来实现卡片的缩放效果，越靠近屏幕中心点的卡片显示越大。我们需要判断出卡片与中心点的距离，以此来计算卡片应该缩放的比例。在<code>measureAndLayout(View view, int position) </code>方法的最下面调用下面的方法：</p><pre><code>    /**     * 缩放卡片     *     * @param item 需要缩放的对象     */    private void scaleView(View item) &#123;        //偏移量 : 卡片默认的第一张卡片左边与可视范围左边的偏移量        float leftX = (getWidth() - mItemWidth) / 2;        //卡片与中心点的距离        float distance = item.getX() - leftX;        //计算绝对距离        float d = Math.abs(distance);        d = Math.min(d, getItemWidth());        /**         * 距离最大为一个卡片的宽度         */        if (d &lt; getItemWidth() / 4) &#123;            item.setScaleX(1);            item.setScaleY(1);        &#125; else &#123;            //卡片缩放值范围1 - 0.9            float scale = (float) (1.1 - (0.4 * d / getItemWidth()));            item.setScaleX(scale);            item.setScaleY(scale);        &#125;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LayoutManager详解及使用（一）</title>
      <link href="2017/09/15/LayoutManager%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2017/09/15/LayoutManager%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>RecyclerView越来越流行，曾经的ListView也逐渐被淘汰，然而RecyclerView的作用绝不仅仅是代替ListView，正如他的名字“Recycler”，只要是需要重复使用的元素都可以用RecyclerView来实现。而这些各式各样的显示效果就不得不提<code>LayoutManger</code>这个类了，<code>LayoutManager</code>的作用就是负责元素的布局和复用。</p>        <h3 id="内置的LayoutManager"   >          <a href="#内置的LayoutManager" class="heading-link"><i class="fas fa-link"></i></a><a href="#内置的LayoutManager" class="headerlink" title="内置的LayoutManager"></a>内置的LayoutManager</h3>      <p>Google提供了三个LayoutManger可以直接使用，分别是<code>LinearLayoutManager</code>、<code>GridLayoutManager</code>和<code>StaggeredGridLayoutManager</code>。只需要一段代码就可以轻松的设置RecyclerView子元素的排列方式</p><pre><code>mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL));</code></pre><span id="more"></span><ul><li><p>LinearLayoutManager<br>线性布局，效果类似ListView，按线性顺序排列,可以设置水平方向和竖直方向。<br><img src="https://file.2fun.xyz/LLayoutManager.gif" alt="LinearLayoutManager"></p></li><li><p>GridLayoutManager<br>表格布局，可以实现类似相册多列排列的效果<br><img src="https://file.2fun.xyz/device-2017-09-15-153607.png" alt="GridLayoutManager"></p></li><li><ul><li>StaggeredGridLayoutManager<br>动态表格布局，可以方便的实现瀑布流效果 ![StaggeredGridLayoutManager](<span class="exturl"><a class="exturl__link"   href="https://file.2fun.xyz/" >https://file.2fun.xyz</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ul></li></ul><p>/device-2017-09-15-154008.png)</p>        <h3 id="LayoutManager的基本知识"   >          <a href="#LayoutManager的基本知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#LayoutManager的基本知识" class="headerlink" title="LayoutManager的基本知识"></a>LayoutManager的基本知识</h3>      <p>自定义<code>LayoutManager</code>需要继承<code> RecyclerView.LayoutManager</code>，必须重写方法<code>generateDefaultLayoutParams()</code>,可参考如下方法:</p><pre><code>    @Override    public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123;        return new RecyclerView.LayoutParams(RecyclerView.LayoutParams.MATCH_PARENT, RecyclerView.LayoutParams.WRAP_CONTENT);    &#125;</code></pre><p>这个方法基本上没有什么变化，不重点介绍，接下来介绍几个比较重要的方法：</p>        <h4 id="重要方法"   >          <a href="#重要方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4>      <ul><li><p><code>onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state)</code><br>这个方法是进行子对象布局时执行的，它决定了RecyclerView的子对象放在什么位置，<code>recycler</code>是RecyclerView的回收池，<code>state</code>RecyclerView的状态信息。当LayoutManager初始化的时候，会执行这个方法进行子对象的布局工作，当界面刷新的时候也会调用这个方法，需要注意的是该方法在初始化的时候会执行两遍。</p></li><li><p><code>canScrollVertically()/canScrollHorizontally()</code><br>是否可以竖直/水平滑动，返回bool值。</p></li><li><p><code>scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) </code><br>手指竖直滑动的时候，会调用这个方法来获取RecyclerView子对象的滚动距离，返回值是int,同样也有<code>scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler, RecyclerView.State state) </code>。</p></li></ul>        <h3 id="常用API"   >          <a href="#常用API" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3>      <ul><li><p><code>recycler.getViewForPosition(position)</code><br>获取位置为position的View。</p></li><li><p><code>getPosition(View view)</code><br>获取view的位置。</p></li><li><p><code>measureChildWithMargins(View child, int widthUsed, int heightUsed)</code><br>测量view的宽高，包括外边距。</p></li><li><p><code>layoutDecoratedWithMargins(View child, int left, int top, int right,int bottom)</code><br>将child显示在RecyclerView上面，<code>left，top，right，bottom</code>规定了显示的区域。</p></li><li><p><code>detachView(View child)</code><br>临时回收view。</p></li><li><p><code>attachView(View child)</code><br>将<code>detachView(View child)</code>回收的view拿回来。</p></li><li><p><code>detachAndScrapAttachedViews(RecyclerView.Recycler recycler)</code><br>用指定的recycler临时移除所有添加的views。</p></li><li><p><code>detachAndScrapView(View child, RecyclerView.Recycler recycler)</code><br>用指定的recycler临时回收view。</p></li><li><p><code>removeAndRecycleAllViews(RecyclerView.Recycler recycler)</code><br>移除所有的view并且用给的recycler回收。</p></li><li><p><code>removeAndRecycleView(View child, RecyclerView.Recycler recycler)</code><br>移除指定的view并且用给的recycler回收。</p></li><li><p><code>offsetChildrenHorizontal(int dx)</code><br>水平移动所有的view，同样也有<code>offsetChildrenVertical(int dy)</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android WebView无法播放网络视频的问题</title>
      <link href="2017/09/14/Android%20WebView%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2017/09/14/Android%20WebView%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天运营大大在后台添加了一个腾讯视频的链接，本来想开开心心的看看手机上面显示效果吹吹牛逼的，结果在应用里面打开发现播放不了，可真是急坏了。于是乎我就被发配去该bug了，起初我以为是他嵌入的视频地址不对，于是叫他换了flash、html和通用代码试了试，发现都不行。然后我们有换了一个优酷的视频地址，发现很神奇的播放成功了？？WTF!!优酷可以，腾讯却不可以了🤔看来还是优酷视频技术更强啊😂。就在我一头雾水的时候，我突然想起来自己的网站也遇到了类似的问题，原因是在https的网页引用了http的地址，我们公司的项目用的http的地址，那腾讯视频难道用的https？？经过排查，果然腾讯视频的地址是https，而优酷用的http，下面我们就可以解决问题了。</p>        <h3 id="解决"   >          <a href="#解决" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决" class="headerlink" title="解决"></a>解决</h3>      <p>android从5.0开始默认不支持http和http地址共存，所以我们就要将5.0以上的设置为允许。在<code>WebSettings</code>里面有<code>setMixedContentMode</code>用来控制混合模式。其中有三个参数：</p><ul><li><p>MIXED_CONTENT_NEVER_ALLOW<br>不允许在https模式下加载http地址，最安全的模式，android5.以后默任是这个。</p></li><li><p>MIXED_CONTENT_ALWAYS_ALLOW</p></li></ul><span id="more"></span><p>允许在https里加载任何地址，不安全，android5.0以前默认是这个。</p><ul><li>MIXED_CONTENT_COMPATIBILITY_MODE<br>WebView将尝试与最新的WebView方法兼容。一些http内容可能被允许从https加载，其他类型的内容将被阻止。</li></ul><p>所以，我们只需要把webview设置成<code>MIXED_CONTENT_ALWAYS_ALLOW</code>模式就可以了。</p><pre><code>//kotlin 代码if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;            val setting = mMvpView?.webView?.settings            setting?.mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW        &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SlimPhp框架的使用（三）获取POST数据</title>
      <link href="2017/09/13/SlimPhp%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%E8%8E%B7%E5%8F%96POST%E6%95%B0%E6%8D%AE/"/>
      <url>2017/09/13/SlimPhp%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89%E8%8E%B7%E5%8F%96POST%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>我们在controller里面处理逻辑，很多时候都需要知道接口发送过来的数据参数，在Slim里处理数据很简单，</p>        <h3 id="定义方法"   >          <a href="#定义方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3>      <p>定义一个方法，作为接口访问调用。需要写至少两个参数<code>$request</code>和<code>$response</code>，如下：</p><pre><code>public function say(Request $request, Response $response, $params)    &#123;</code></pre><span id="more"></span><pre><code>    &#125;</code></pre><ul><li><p><code>$request</code><br>请求发送的内容，里面带有请求时发送的数据，在移动平台，多是使用json进行数据的传递。</p></li><li><p><code>$response</code><br>接口返回的内容，进行返回值的格式和值设置</p></li></ul>        <h3 id="获取POST的数据"   >          <a href="#获取POST的数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取POST的数据" class="headerlink" title="获取POST的数据"></a>获取POST的数据</h3>      <p><code>$request-&gt;getParams()</code>可以获取post的所有数据，是一个对象数组。<br><code>$request-&gt;getParam(&#39;key&#39;,&#39;default&#39;)</code>获取post的指定key对应的值，如果没有则返回default的值。</p>        <h3 id="设置返回值"   >          <a href="#设置返回值" class="heading-link"><i class="fas fa-link"></i></a><a href="#设置返回值" class="headerlink" title="设置返回值"></a>设置返回值</h3>      <p>通过<code>$response</code>我们可以很方便的设置返回数据，例如<code>json</code>格式的数据。 <code>$response-&gt;withJson($data, $status = null, $encodingOptions = 0)</code>设置json的返回值，<code>$data</code>传递一个array数组。例如在方法最后写上<code> return $response-&gt;withJson($data);</code>，返回<code>data</code>的数组的json字符串。</p>        <h3 id="注意"   >          <a href="#注意" class="heading-link"><i class="fas fa-link"></i></a><a href="#注意" class="headerlink" title="注意"></a>注意</h3>      <p>编写完controller之后访问地址如果出现<code>controller not found</code>，可能是composer的问题，可以试试执行<code>composer dump-autoload -o</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SlimPhp框架的使用（二）编写接口</title>
      <link href="2017/09/12/SlimPhp%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3/"/>
      <url>2017/09/12/SlimPhp%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>SlimPhp使用路由管理页面的访问，Slim本身并没有MVC模式，但是我们可以通过Controller来实现MVC的效果，因为我们的目标是编写接口，所以现在我们不考虑View层,只解决MC。<br>推荐查看akrabat的简单Slim项目理解Slim的运行逻辑<a href="https://github.com/akrabat/slim-bookshelf">Glihub地址:Slim-<br>Bookshelf</a></p>        <h3 id="文件结构"   >          <a href="#文件结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3>      <p>项目的文件目录推荐如下： <code>#</code>表示一级目录，<code>##</code>表示二级目录</p><span id="more"></span><pre><code>#app    ----项目主要目录##HelloWordController.php    ----测试用的controller##dependencies.php    ----添加需要使用的controller文件##routes.php    ----定义路由##setting.php    ----设置的配置文件#public    ----用户可以访问的目录##index.php    ----index页面#vendor    ----使用composer自动生成的目录##composer.json    ----composer配置文件##composer.lock    ----composer文件不需要管</code></pre>        <h3 id="创建目录"   >          <a href="#创建目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3>      <p>按照上面的目录结构创建文件的目录app和public，vendor目录使用composer命令自动生成，所以不需要我们创建。</p>        <h3 id="安装Slim"   >          <a href="#安装Slim" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装Slim" class="headerlink" title="安装Slim"></a>安装Slim</h3>      <p>Slim的安装可以看<a href="https://www.bearever.cn/slim/slimphp%e6%a1%86%e6%9e%b6%e7%9a%84%e4%bd%bf%e7%94%a8%ef%bc%88%e4%b8%80%ef%bc%89%e5%ae%89%e8%a3%85composer%e5%92%8cslim/">上一篇文章</a>。</p>        <h3 id="编辑composer-json"   >          <a href="#编辑composer-json" class="heading-link"><i class="fas fa-link"></i></a><a href="#编辑composer-json" class="headerlink" title="编辑composer.json"></a>编辑composer.json</h3>      <p>编辑<code>composer.json</code>文件，添加<code>autoload</code>地址,然后执行终端执行<code>composer update</code></p><pre><code>&#123;    &quot;require&quot;: &#123;        &quot;slim/slim&quot;: &quot;^3.0&quot;    &#125;,    &quot;autoload&quot;: &#123;        &quot;psr-4&quot;:&#123;          &quot;Sample\\&quot;:&quot;app&quot; //“Sample” 是自己定义的一个命名空间,&quot;app&quot;对应的是文件路径        &#125;    &#125;&#125;</code></pre>        <h3 id="编辑Controller文件"   >          <a href="#编辑Controller文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#编辑Controller文件" class="headerlink" title="编辑Controller文件"></a>编辑Controller文件</h3>      <p>在app文件夹里面创建<code>HelloWordController.php</code>文件，先把<code>HelloWordController</code>代码贴上来</p><pre><code>namespace Sample\Controllers; //命名空间，很重要，引用文件都需要使用这个路径use \interop\Container\ContainerInterface;final class HelloWordController&#123;    protected $app;    public function __construct(ContainerInterface $ci)    &#123;        $this-&gt;app = $ci;    &#125;    /**    * 测试的方法    **/    public function say($request, $response, $params)    &#123;        echo &#39;Welcome Slim&#39;;    &#125;&#125;</code></pre>        <h3 id="编辑index-php文件"   >          <a href="#编辑index-php文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#编辑index-php文件" class="headerlink" title="编辑index.php文件"></a>编辑index.php文件</h3>      <p>在public文件夹里面创建<code>index.php</code>文件,用来处理网络访问</p><pre><code>use \Psr\Http\Message\ServerRequestInterface as Request;use \Psr\Http\Message\ResponseInterface as Response;require &#39;../vendor/autoload.php&#39;; //自动加载的脚本$settings = require &#39;../app/setting.php&#39;; //引入设置的配置文件$app = new \Slim\App($settings);require &#39;../app/dependencies.php&#39;; //引入controller配置文件require &#39;../app/routes.php&#39;; //引入路由管理文件$app-&gt;run(); //执行</code></pre>        <h3 id="编写设置配置文件"   >          <a href="#编写设置配置文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#编写设置配置文件" class="headerlink" title="编写设置配置文件"></a>编写设置配置文件</h3>      <p>在app目录下面创建<code>setting.php</code>文件,根据自己的需求编写配置文件</p><pre><code>return [    &#39;settings&#39; =&gt; [        &#39;addContentLengthHeader&#39; =&gt; false,        &#39;displayErrorDetails&#39; =&gt; true //开启错误提示    ],];</code></pre>        <h3 id="编写Controller配置文件"   >          <a href="#编写Controller配置文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#编写Controller配置文件" class="headerlink" title="编写Controller配置文件"></a>编写Controller配置文件</h3>      <p>在app文件夹里面创建<code>dependencies.php</code><br>注意：所有的文件需要使用命名空间的路径，如“Sample\Controllers\HelloWordController”</p><pre><code>$container = $app-&gt;getContainer();//hello$container[&#39;Sample\Controllers\HelloWordController&#39;] = function ($c) &#123;    return new \Sample\Controllers\HelloWordController($c);&#125;;</code></pre>        <h3 id="添加路由管理文件"   >          <a href="#添加路由管理文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#添加路由管理文件" class="headerlink" title="添加路由管理文件"></a>添加路由管理文件</h3>      <p>在app文件夹里面创建<code>routes.php</code>文件</p><pre><code>//处理域名/hello地址的访问,跳转到HelloWordController的say方法$app-&gt;get(&#39;/hello&#39;,&#39;Sample\Controllers\HelloWordController:say&#39;);</code></pre>        <h3 id="完毕？"   >          <a href="#完毕？" class="heading-link"><i class="fas fa-link"></i></a><a href="#完毕？" class="headerlink" title="完毕？"></a>完毕？</h3>      <p>那么现在我们访问网址，是不是就会出现我们期待的东西呢？然而事实是不是的，提示<code>controller not fund</code>。这是什么bug??WTF，我们还需要执行一步，在终端输入<code>composer dump-autoload -o</code>,然后在输入网址，总算可以了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SlimPhp框架的使用（一）安装Composer和Slim</title>
      <link href="2017/09/12/SlimPhp%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85Composer%E5%92%8CSlim/"/>
      <url>2017/09/12/SlimPhp%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85Composer%E5%92%8CSlim/</url>
      
        <content type="html"><![CDATA[        <h3 id="缘由"   >          <a href="#缘由" class="heading-link"><i class="fas fa-link"></i></a><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3>      <p>由于我自己的Android应用需要使用服务器进行数据交互，之前一直使用的原生的php开发在接口不多的时候还能应付，现在软件更新接口需求增加，曾经的开发模式越来越繁琐了，于是想找一个好用的api开发框架。在知乎上面搜索这方面的问答，很多人推荐laravel,所以尝试着试了一下laravel，不过laravel对系统要求较高，而我的豆腐渣服务器看来是承受不了了。转而寻找新的替代品，于是发现了Slim-<br>php，一款php微框架，效率很高对系统要求也很低，没有用户登陆系统，这个也刚好符合我的需求。安照slim-php官网的话就是：</p><blockquote><p><em>You don’t always need a kitchen-sink solution like Symfony or Laravel.<br>These are great tools, for sure. But they are often overkill. Instead, Slim<br>provides only a minimal set of tools that do what you need and nothing<br>else.</em></p></blockquote><span id="more"></span><p>接下来，我将介绍如何安装Slim-<br>php，你可以选择下载源码安装的方式，也可以使用<code>Composer</code>安装。这里我使用的是<code>Composer</code>的安装方式，强烈推荐这种方式。关于<code>Composer</code>的介绍有间可以单独写一篇博客介绍。</p>        <h3 id="安装Composer"   >          <a href="#安装Composer" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装Composer" class="headerlink" title="安装Composer"></a>安装Composer</h3>      <ul><li><pre><code>* 下载</code></pre></li></ul><p>在终端执行<code>curl -sS https://getcomposer.org/installer | php</code>下载composer</p><ul><li><pre><code>* 设置</code></pre></li></ul><p>将Composer设置为全局运行程序方便使用,执行<code>mv composer.phar /usr/local/bin/composer</code></p><ul><li><pre><code>* 测试</code></pre></li></ul><p>执行<code>composer -v</code>,如果能查看到版本信息，则说明安装成功。</p>        <h3 id="安装Slim-php"   >          <a href="#安装Slim-php" class="heading-link"><i class="fas fa-link"></i></a><a href="#安装Slim-php" class="headerlink" title="安装Slim-php"></a>安装Slim-php</h3>      <p>使用Composer安装Slim-php很简单，只需要cd到你的项目目录，执行<code>composer require slim/slim &quot;^3.0&quot;</code>,之后就会在项目目录下面看到<code>vendor</code>文件夹和composer.json的文件，这就安装完成了。关于Slim-<br>php的使用可以查看我的<a href="https://www.bearever.cn/slim/slimphp%e6%a1%86%e6%9e%b6%e7%9a%84%e4%bd%bf%e7%94%a8%ef%bc%88%e4%ba%8c%ef%bc%89%e7%bc%96%e5%86%99%e6%8e%a5%e5%8f%a3/">下一篇文章</a>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="2017/09/12/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
      <url>2017/09/12/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
      
        <content type="html"><![CDATA[        <h3 id="啰嗦"   >          <a href="#啰嗦" class="heading-link"><i class="fas fa-link"></i></a><a href="#啰嗦" class="headerlink" title="啰嗦"></a>啰嗦</h3>      <p>“罗啰明天”这个名字来源于大学时的一个朋友的建议，我觉得很好听就保留下来了。我也没有想到曾经迷恋电影的我最后却成为了一名程序员，不过如今编程也让我觉得非常开心。我想电影与程序的一个共同点就是可以创造出无限的可能，实现幻想。我可能不是一个编程能力很强的人，但是电影的基因让我在看待问题的时候多了一些思考，有人说我是一个带有产品气息的程序员，也许是对的。希望这个微小的博客能够带给大家一点帮助，同时把我自己的成长记录下来。</p>        <h3 id="联系我"   >          <a href="#联系我" class="heading-link"><i class="fas fa-link"></i></a><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3>      <p>我的邮箱:<span class="exturl"><a class="exturl__link"   href="mailto:&#x6c;&#117;&#111;&#109;&#x69;&#x6e;&#103;&#x62;&#101;&#97;&#114;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;" >&#x6c;&#117;&#111;&#109;&#x69;&#x6e;&#103;&#x62;&#101;&#97;&#114;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程下载断点续传的实现</title>
      <link href="2017/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>2017/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>使用Kotlin编写的下载工具，实现了多线程断点续传的功能，使用简单</p>        <h3 id="下载地址"   >          <a href="#下载地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3>      <p>Github地址：<span class="exturl"><a class="exturl__link"   href="https://github.com/Luomingbear/KTDownloadManager" >https://github.com/Luomingbear/KTDownloadManager</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h3 id="配置"   >          <a href="#配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置" class="headerlink" title="配置"></a>配置</h3>      <ul><li>软件使用<code>kotlin</code>作为编程语言，所以需要配置<code>kotlin</code>环境，具体方法可自行百度/谷歌</li><li>软件内部使用的数据库是<code>greenDao</code>，依赖配置可以参考我的<code>build.gradle</code> 使用</li></ul><span id="more"></span>        <h3 id="使用"   >          <a href="#使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用" class="headerlink" title="使用"></a>使用</h3>      <p><img src="https://file.2fun.xyz/ktdownload_mulu.png" alt="目录"></p><ul><li><code>database</code>是数据库相关的类，可以自行替换成自己喜欢的数据库操作工具</li><li><code>ktdownload</code>是下载的相关逻辑的类</li><li><code>KTDownloadAsyncTask</code>是具体每一个下载线程的实现，需要注意的是多线程同时执行需要使用<code>executeOnExecutor</code>函数，否则会出现组赛现象</li><li><code>KTDownloadManager</code>是用于管理多线程下载的类，通过<code>addDownloadFile(downloadUrl: String, savePath: String)</code>加入需要下载为文件信息，暂时只能同时下载一个文件，队列下载待做。通过<code>startDownload</code>,<code>pauseDownload</code>来控制下载的开始和停止</li><li><code>OnKTDownloadListener</code>是下载状态的监听函数，在<code>KTDownloadManager</code>调用<code>setOnKTDownloadListener</code>来添加监听</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP Rewrite Nginx 规则</title>
      <link href="2017/09/11/ThinkPHP%20Rewrite%20Nginx%20%E8%A7%84%E5%88%99/"/>
      <url>2017/09/11/ThinkPHP%20Rewrite%20Nginx%20%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>在nginx的配置文件里面加上重写路径的代码，我使用的oneinstack安装的nginx所以路径为<code>/usr/local/nginx/conf/</code>，找到你的域名的配置文件，添加如下代码：</p><pre><code>location / &#123;     if (!-e $request_filename) &#123;         rewrite  ^(.*)$  /index.php?s=$1  last; </code></pre><span id="more"></span><pre><code>        break;       &#125; &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android代码混淆</title>
      <link href="2017/08/09/Android%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
      <url>2017/08/09/Android%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://file.2fun.xyz/jiami.jpg" alt="加密"><br>android发布之前，都会进行一次加密的操作，减少被破解的几率，在android<br>studio里面，我们可以非常方便的通过proguard.pro设置代码混淆实现加密的功能。</p>        <h3 id="开启代码混淆"   >          <a href="#开启代码混淆" class="heading-link"><i class="fas fa-link"></i></a><a href="#开启代码混淆" class="headerlink" title="开启代码混淆"></a>开启代码混淆</h3>      <p><img src="https://file.2fun.xyz/android_proguard.png" alt="设置app-&gt;build.gradle"></p>        <h3 id="编辑proguard-pro"   >          <a href="#编辑proguard-pro" class="heading-link"><i class="fas fa-link"></i></a><a href="#编辑proguard-pro" class="headerlink" title="编辑proguard.pro"></a>编辑proguard.pro</h3>      <span id="more"></span><p>根据实际的酵母情况对下面的文件今昔修改添加，使用第三方类库的时候，根据第三方类库提供的规则进行添加</p><pre><code>############################################### 对于一些基本指令的添加############################################### 代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5# 混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames# 指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses# 这句话能够使我们的项目混淆后产生映射文件# 包含有类名-&gt;混淆后类名的映射关系-verbose# 指定不去忽略非公共库的类成员-dontskipnonpubliclibraryclassmembers# 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify# 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses# 避免混淆泛型-keepattributes Signature# 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable# 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/*############################################### Android开发中一些需要保留的公共部分############################################### 保留我们使用的四大组件，自定义的Application等等这些类不被混淆# 因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService# 保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125;# 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.**# 保留R下面的资源-keep class **.R$* &#123;*;&#125;# 保留本地native方法不被混淆-keepclasseswithmembernames class * &#123;    native ;&#125;# 保留在Activity中的方法参数是view的方法，# 这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123;    public void *(android.view.View);&#125;# 保留枚举类不被混淆-keepclassmembers enum * &#123;    public static **[] values();    public static ** valueOf(java.lang.String);&#125;# 保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123;    *** get*();    void set*(***);    public (android.content.Context);    public (android.content.Context, android.util.AttributeSet);    public (android.content.Context, android.util.AttributeSet, int);&#125;# 保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123;    public static final android.os.Parcelable$Creator *;&#125;# 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123;    static final long serialVersionUID;    private static final java.io.ObjectStreamField[] serialPersistentFields;    !static !transient ;    !private ;    !private ;    private void writeObject(java.io.ObjectOutputStream);    private void readObject(java.io.ObjectInputStream);    java.lang.Object writeReplace();    java.lang.Object readResolve();&#125;# 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆-keepclassmembers class * &#123;    void *(**On*Event);    void *(**On*Listener);&#125;# webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123;    public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123;    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);    public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123;    public void *(android.webkit.webView, jav.lang.String);&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>带圆角的背景的TextView</title>
      <link href="2017/08/01/%E5%B8%A6%E5%9C%86%E8%A7%92%E7%9A%84%E8%83%8C%E6%99%AF%E7%9A%84TextView/"/>
      <url>2017/08/01/%E5%B8%A6%E5%9C%86%E8%A7%92%E7%9A%84%E8%83%8C%E6%99%AF%E7%9A%84TextView/</url>
      
        <content type="html"><![CDATA[        <h3 id="效果图"   >          <a href="#效果图" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3>      <p>应用中经常会遇到使用圆角TextView的情况，这是一个自定义的圆角TextView<br><img src="https://file.2fun.xyz/roundText.png" alt="圆角背景TextView"></p>        <h3 id="类文件"   >          <a href="#类文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#类文件" class="headerlink" title="类文件"></a>类文件</h3>      <pre><code>/**</code></pre><span id="more"></span><pre><code> * 带圆角的文本显示控件textview * Created by Bear on 2017/6/23. */class RoundTextView @JvmOverloads constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int = 0) :        AppCompatTextView(context, attrs, defStyleAttr) &#123;    private var mPaint: Paint = Paint()    private var mBgColor: Int = 0 //背景颜色    private var mRoundSize: Float = 0.toFloat() //圆角的值    private var mRoundType = RoundType.ROUND_RECT //圆角的类型    private var rectF: RectF? = null    enum class RoundType &#123;        ROUND_RECT,        ROUND_TOP,        ROUND_BOTTOM,        LEFT_BOTTOM,        RIGHT_BOTTOM    &#125;    init &#123;        if (attrs != null)            init(attrs)    &#125;    /**     * 设置textView的背景色     * @param bgColor     */    var bgColor: Int        get() = mBgColor        set(bgColor) &#123;            this.mBgColor = bgColor            invalidate()        &#125;    var roundSize: Float        get() = mRoundSize        set(roundSize) &#123;            this.mRoundSize = roundSize            invalidate()        &#125;    var roundType: RoundType        get() = mRoundType        set(mRoundType) &#123;            this.mRoundType = mRoundType            invalidate()        &#125;    /**     * 初始化     */    private fun init(attributeSet: AttributeSet) &#123;        val typedArray = context.obtainStyledAttributes(attributeSet, R.styleable.RoundTextView)        mRoundSize = typedArray.getDimension(R.styleable.RoundTextView_roundSize, resources.getDimension(R.dimen.border_radius_normal))        mBgColor = typedArray.getColor(R.styleable.RoundTextView_bgColor, 0)        mRoundType = RoundType.values()[typedArray.getInt(R.styleable.RoundTextView_roundType, 0)]        typedArray.recycle()        gravity = Gravity.CENTER    &#125;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123;        super.onSizeChanged(w, h, oldw, oldh)        rectF = RectF(0f, 0f, w.toFloat(), h.toFloat())    &#125;    override fun onDraw(canvas: Canvas) &#123;        if (mBgColor == 0) &#123;            super.onDraw(canvas)            return        &#125;        mPaint.color = mBgColor        mPaint.isAntiAlias = true        canvas.drawRoundRect(rectF!!, mRoundSize, mRoundSize, mPaint)        when (mRoundType) &#123;            RoundTextView.RoundType.ROUND_RECT -&gt; &#123;            &#125;            RoundTextView.RoundType.ROUND_TOP -&gt; &#123;                canvas.drawRect(0f, height - mRoundSize, mRoundSize, height.toFloat(), mPaint)                canvas.drawRect(width - mRoundSize, height - mRoundSize, width.toFloat(), height.toFloat(), mPaint)            &#125;            RoundTextView.RoundType.ROUND_BOTTOM -&gt; &#123;                canvas.drawRect(0f, 0f, mRoundSize, mRoundSize, mPaint)                canvas.drawRect(width - mRoundSize, 0f, width.toFloat(), mRoundSize, mPaint)            &#125;            RoundTextView.RoundType.LEFT_BOTTOM -&gt; &#123;                canvas.drawRect(0f, 0f, mRoundSize, mRoundSize, mPaint)                canvas.drawRect(0f, 0f, width.toFloat(), mRoundSize, mPaint)                canvas.drawRect(width - mRoundSize, height - mRoundSize, width.toFloat(), height.toFloat(), mPaint)            &#125;            RoundTextView.RoundType.RIGHT_BOTTOM -&gt; &#123;                canvas.drawRect(width - mRoundSize, 0f, width.toFloat(), mRoundSize, mPaint)                canvas.drawRect(0f, 0f, width.toFloat(), mRoundSize, mPaint)                canvas.drawRect(0f, height - mRoundSize, mRoundSize, height.toFloat(), mPaint)            &#125;        &#125;        super.onDraw(canvas)    &#125;    /**     * 用于代码生成     */    class Builder(private val mContext: Context) &#123;        private var bgColor: Int = 0 //背景颜色        private var roundSize: Float = 0.toFloat() //圆角的值        private var textColor: Int = 0 //文本颜色        private var textSize: Float = 0.toFloat() //文字大小        private var textString: String? = null//文本        private var roundType = RoundType.ROUND_RECT //圆角的类型        fun setRoundSize(roundSize: Float): Builder &#123;            this.roundSize = roundSize            return this        &#125;        fun setRoundType(roundType: RoundType): Builder &#123;            this.roundType = roundType            return this        &#125;        fun setTextColor(textColor: Int): Builder &#123;            this.textColor = textColor            return this        &#125;        fun setTextString(text: String): Builder &#123;            this.textString = text            return this        &#125;        fun setBgColor(bgColor: Int): Builder &#123;            this.bgColor = bgColor            return this        &#125;        fun setTextSize(textSize: Float): Builder &#123;            this.textSize = textSize            return this        &#125;        fun build(): RoundTextView &#123;            val roundTextView = RoundTextView(mContext, null, 0)            roundTextView.mRoundType = roundType            roundTextView.mBgColor = bgColor            roundTextView.mRoundSize = roundSize            roundTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize)            roundTextView.setTextColor(textColor)            roundTextView.text = textString            roundTextView.requestLayout()            return roundTextView        &#125;    &#125;&#125;</code></pre>        <h3 id="属性"   >          <a href="#属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#属性" class="headerlink" title="属性"></a>属性</h3>      <pre><code>&lt;declare-styleable name=&quot;RoundTextView&quot;&gt;    &lt;attr name=&quot;roundSize&quot; format=&quot;dimension|reference&quot; /&gt;    &lt;!--背景色--&gt;    &lt;attr name=&quot;bgColor&quot; format=&quot;color&quot; /&gt;    &lt;attr name=&quot;roundType&quot; format=&quot;enum&quot;&gt;        &lt;enum name=&quot;roundRect&quot; value=&quot;0&quot; /&gt;        &lt;enum name=&quot;roundTop&quot; value=&quot;1&quot; /&gt;        &lt;enum name=&quot;roundBottom&quot; value=&quot;2&quot; /&gt;        &lt;enum name=&quot;leftBottom&quot; value=&quot;3&quot; /&gt;        &lt;enum name=&quot;rightBottom&quot; value=&quot;4&quot; /&gt;    &lt;/attr&gt;&lt;/declare-styleable&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>android自定义dialog</title>
      <link href="2017/07/31/android%E8%87%AA%E5%AE%9A%E4%B9%89dialog/"/>
      <url>2017/07/31/android%E8%87%AA%E5%AE%9A%E4%B9%89dialog/</url>
      
        <content type="html"><![CDATA[        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h3>      <p>在Android开发的过程中经常会遇到自定义Dialog的需求，Android原生的Dialog在很多情况下面并不能满足我们的使用,例如下图钉钉的更新弹窗，所以今天我们就来尝试下自定义Dialog。<br><img src="https://file.2fun.xyz/dingding_update_dialog.png" alt="钉钉的更新弹窗dialog"></p>        <h3 id="自定义Dialog基类"   >          <a href="#自定义Dialog基类" class="heading-link"><i class="fas fa-link"></i></a><a href="#自定义Dialog基类" class="headerlink" title="自定义Dialog基类"></a>自定义Dialog基类</h3>      <p>自定义Dialog需要首先继承Dialog，重写<code>onCreate(Bundle savedInstanceState)</code>方法，由于在项目中我们可能不止一次的使用自定义Dialog，所以我创建了一个简单的基类<code>BaseDialog</code>,主要代码如下如下:</p><span id="more"></span><pre><code>@Override  protected void onCreate(Bundle savedInstanceState) &#123;      super.onCreate(savedInstanceState);      //添加布局文件      setContentView(getLayoutRes());      //执行初始化view，设置弹窗大小绑定view等      initView();      //初始化事件，例如添加点击事件      initEvent();  &#125;     public abstract int getLayoutRes();  public abstract void initView();  public abstract void initEvent();</code></pre>        <h3 id="继承Dialog基类"   >          <a href="#继承Dialog基类" class="heading-link"><i class="fas fa-link"></i></a><a href="#继承Dialog基类" class="headerlink" title="继承Dialog基类"></a>继承Dialog基类</h3>      <p>在具体的使用的时候，需要继承<code>BaseDialog</code>,在<code>initView</code>里面记得添加设置dialog大小的熟悉！！</p><pre><code>    override fun initView() &#123;        //点击空白可以隐藏弹窗        window?.setBackgroundDrawable(BitmapDrawable())        setCanceledOnTouchOutside(true)        //弹窗位置        window?.setGravity(Gravity.CENTER)        //设置大小        val params = window?.attributes // 获取对话框当前的参数值        params?.height = SysUtils.getScreenDisplay(context).height / 3        params?.width = SysUtils.getScreenDisplay(context).width        //设置背景的颜色        //params.dimAmount = 0.5f;        //设置属性        window?.attributes = params    &#125;</code></pre>        <h3 id="最后"   >          <a href="#最后" class="heading-link"><i class="fas fa-link"></i></a><a href="#最后" class="headerlink" title="最后"></a>最后</h3>      <p>附上完整的BaseDialog的代码</p><pre><code>public abstract class BaseDialog extends AppCompatDialog &#123;    public BaseDialog(@NonNull Context context) &#123;        super(context);    &#125;    public BaseDialog(@NonNull Context context, @StyleRes int themeResId) &#123;        super(context, themeResId);    &#125;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(getLayoutRes());        initView();        initEvent();    &#125;    public abstract int getLayoutRes();    public abstract void initView();    public abstract void initEvent();&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AS移植FFmpeg（Ubuntu平台）</title>
      <link href="2017/07/26/AS%E7%A7%BB%E6%A4%8DFFmpeg%EF%BC%88Ubuntu%E5%B9%B3%E5%8F%B0%EF%BC%89/"/>
      <url>2017/07/26/AS%E7%A7%BB%E6%A4%8DFFmpeg%EF%BC%88Ubuntu%E5%B9%B3%E5%8F%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>如今随着视频应用的流行，我们也有必要学习下这方面的知识了。现在市场上绝大多数的视频应用都是使用的FFmpeg进行视频处理，今天我们就来尝试将FFmpeg移植到Android平台。</p>        <h3 id="下载FFmpeg编译好的-so文件"   >          <a href="#下载FFmpeg编译好的-so文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#下载FFmpeg编译好的-so文件" class="headerlink" title="下载FFmpeg编译好的.so文件"></a><span class="exturl"><a class="exturl__link"   href="http://ffmpeg.org/download.html" >下载FFmpeg编译好的.so文件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></h3>      <p>点击标题下载我已经编译好的so文件，将下载的文件解压复制到Android工程目录<code>app/src/main/jni</code>里面,如果没有文件夹则创建文件夹。关于如何编译FFmpeg的so文件，我将在下一篇文章里面分享，因为编译会麻烦很多，所以先让大家能够轻易的使用FFmpeg才是最佳的打开方式。</p>        <h3 id="编写native方法。"   >          <a href="#编写native方法。" class="heading-link"><i class="fas fa-link"></i></a><a href="#编写native方法。" class="headerlink" title="编写native方法。"></a>编写native方法。</h3>      <span id="more"></span><pre><code>public class FFmpegNative &#123;    static &#123;        System.loadLibrary(&quot;avutil-55&quot;);        System.loadLibrary(&quot;swresample-2&quot;);        System.loadLibrary(&quot;avcodec-57&quot;);        System.loadLibrary(&quot;avformat-57&quot;);        System.loadLibrary(&quot;swscale-4&quot;);        System.loadLibrary(&quot;avfilter-6&quot;);        System.loadLibrary(&quot;avdevice-57&quot;);        System.loadLibrary(&quot;ffmpeg_codec&quot;);／／自己编写的c文件的so    &#125;    public  native String getStringFromNative();&#125;</code></pre>        <h3 id="执行build-gt-make-project"   >          <a href="#执行build-gt-make-project" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行build-gt-make-project" class="headerlink" title="执行build-&gt;make project"></a>执行<code>build-&gt;make project</code></h3>      <p>在AS里面执行<code>build-&gt;make project</code>命令，生成classes文件，最终的classes文件会在debug目录下<br><img src="https://file.2fun.xyz/imagesadsadasd.png" alt="build-&gt;make project"></p>        <h3 id="生成-h文件"   >          <a href="#生成-h文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成-h文件" class="headerlink" title="生成.h文件"></a>生成.h文件</h3>      <p><img src="https://file.2fun.xyz/29721810.png" alt="cd目录"> 在终端输入<code>java -jni com.you_name._your_package.FFmpegNative</code>,<code>FFmpegNative</code>是Java文件的名字，此命令会生成一个.h文件<br><img src="https://file.2fun.xyz/5575212s41.png" alt=".h文件"></p>        <h3 id="编写-c文件"   >          <a href="#编写-c文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#编写-c文件" class="headerlink" title="编写.c文件"></a>编写.c文件</h3>      <p>将.h拷贝到jni目录下，编写c文件命名与头文件相同 <img src="https://file.2fun.xyz/1932708292.png" alt=".c文件"><br>将头文件的方法规范拷贝到c文件，实现方法，注意的是，这里的返回值的编写，java的字符编码是utf16，而安卓是utf8，如：</p><pre><code>JNIEXPORT jstring JNICALL Java_com_bear_ffmpeg_FFmpegNative_getStringFromNative        (JNIEnv *env , jobject obj)&#123;      av_register_all();      char wd[512];      sprintf(wd, &quot;AVCODEC VERSION %u\n&quot;        , avcodec_version()        );      return (*env)-&gt;NewStringUTF(env, wd);  &#125;</code></pre>        <h3 id="Android-mk"   >          <a href="#Android-mk" class="heading-link"><i class="fas fa-link"></i></a><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h3>      <p>在jni目录下编写Android.mk文件</p><pre><code>LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE    := avcodec-57LOCAL_SRC_FILES := prebuilt/libavcodec-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE    := avdevice-57LOCAL_SRC_FILES := prebuilt/libavdevice-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE    := avfilter-6LOCAL_SRC_FILES := prebuilt/libavfilter-6.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE    := avformat-57LOCAL_SRC_FILES := prebuilt/libavformat-57.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE    := avutil-55LOCAL_SRC_FILES := prebuilt/libavutil-55.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE    := swresample-2LOCAL_SRC_FILES := prebuilt/libswresample-2.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE    := swscale-4LOCAL_SRC_FILES := prebuilt/libswscale-4.soinclude $(PREBUILT_SHARED_LIBRARY)include $(CLEAR_VARS)LOCAL_MODULE    := ffmpeg_codecLOCAL_SRC_FILES := com_bear_ffmpeg_FFmpegNative.cLOCAL_LDLIBS := -llog -ljnigraphics -lz -landroidLOCAL_SHARED_LIBRARIES := libavformat-57 libavcodec-57 libswscale-4 libavutil-55 libswresample-2 libavdevice-57 libavfilter-6include $(BUILD_SHARED_LIBRARY)</code></pre>        <h3 id="Application-mk"   >          <a href="#Application-mk" class="heading-link"><i class="fas fa-link"></i></a><a href="#Application-mk" class="headerlink" title="Application.mk"></a>Application.mk</h3>      <p>在jni目录下编写Application.mk（这里的暂时只能够用于arm处理器）</p><pre><code>APP_ABI :=armeabi,armeabi-v7aAPP_PLATFORM := android-21APP_OPTIM := releaseAPP_STL := gnustl_static</code></pre>        <h3 id="执行ndk-build"   >          <a href="#执行ndk-build" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行ndk-build" class="headerlink" title="执行ndk-build"></a>执行<code>ndk-build</code></h3>      <p>使用终端cd到app/src/main目录，执行“ndk-build”，编译so库。<br><em>注意：有时候会出现错误：找不到编译的规则，可以在jni目录下创建一个空的util.c文件解决</em><br>将生成的so库从<code>app/src/main/libs</code>拷贝一份到<code>app/Libs</code></p>        <h3 id="修改buld-gradle"   >          <a href="#修改buld-gradle" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改buld-gradle" class="headerlink" title="修改buld.gradle"></a>修改<code>buld.gradle</code></h3>      <pre><code>android &#123;    compileSdkVersion 23    buildToolsVersion &#39;23.0.1&#39;    defaultConfig &#123;        applicationId &quot;com.bear.ffmpeg&quot;        minSdkVersion 15        targetSdkVersion 23        versionCode 1        versionName &quot;1.0&quot;        ndk &#123;            moduleName &quot;ffmpeg_codec&quot;//c库的名字            ldLibs &quot;log&quot;, &quot;z&quot;, &quot;m&quot;,&quot;android&quot;,&quot;jnigraphics&quot;            abiFilters &quot;arm64-v8a&quot;,&quot;armeabi&quot;,&quot;armeabi-v7a&quot;        &#125;        sourceSets.main&#123;            jni.srcDirs=[]//禁用自动ndk，在编写c代码的时候建议注释掉，因为这句话会停用c的语法提示功能            jniLibs.srcDir &quot;src/main/libs&quot;        &#125;    &#125;    buildTypes &#123;        release &#123;            minifyEnabled false            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        &#125;    &#125;&#125;</code></pre>        <h3 id="完成"   >          <a href="#完成" class="heading-link"><i class="fas fa-link"></i></a><a href="#完成" class="headerlink" title="完成!"></a>完成!</h3>      <p>现在就可以在调用jni的方法了！ 一些注意事项：</p><blockquote><p>*so库的文件名不要写错了 *最后运行时请禁用ndk自动运行 *运行时提示找不到so库，可以再生成一次头文件，并且ndk-build，然后运行</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android（Kotlin）类似微博的九宫格图片显示控件</title>
      <link href="2017/07/25/Android%EF%BC%88Kotlin%EF%BC%89%E7%B1%BB%E4%BC%BC%E5%BE%AE%E5%8D%9A%E7%9A%84%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E6%8E%A7%E4%BB%B6/"/>
      <url>2017/07/25/Android%EF%BC%88Kotlin%EF%BC%89%E7%B1%BB%E4%BC%BC%E5%BE%AE%E5%8D%9A%E7%9A%84%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[        <h3 id="前言"   >          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h3>      <p>在微博浏览的时候，我们可以看到一个类似下图的九宫格图片显示控件，类似的效果在微信朋友圈里面也有遇到。当只有一张图片的时候就显示一张图片占满布局宽度；如果有2-4张图片，则显示两列；如果有5-9张图片泽显示三列。<br><img src="https://file.2fun.xyz/weibosdsasdasd1654531a32ds.png" alt="微博九宫格截图"><br>由于工作项目的原因，我也需要实现一个类似这样的图片显示控件，通过百度发现，现在有两种方式进行制作，一个是自定义View的方式，另一个是通过ViewGroup。在这里，我采用的是ViewGroup的方式实现(<span class="exturl"><a class="exturl__link"   href="https://github.com/w4lle/NineGridView" >参考w4lle大神的源码</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>)。<br>现在Android的官方语言已经变为了Kotlin，所以这里我使用的是Kotlin编写，直接上代码吧！</p>        <h3 id="NineGridlayout"   >          <a href="#NineGridlayout" class="heading-link"><i class="fas fa-link"></i></a><a href="#NineGridlayout" class="headerlink" title="NineGridlayout"></a>NineGridlayout</h3>      <p><code>NineGridlayout</code>是图片显示的自定义ViewGroup，在layout布局文件里面直接使用就可以了</p><span id="more"></span><pre><code>class NineGridlayout : ViewGroup &#123;    private val TAG = &quot;NineGridlayout&quot;    private var adapter: NineGridAdapter? = null    private var onItemClickListerner: OnItemClickListener? = null    /**     * 默认图片间隔     */    private val ITEM_GAP = 3    private val DEFAULT_WIDTH = 140    /**     * 图片之间的间隔     */    var gap: Int = 0    private var columns: Int = 0//    private var rows: Int = 0//    private var totalWidth: Int = 0    internal var singleWidth = 0    internal var singleHeight = 0    private var defaultWidth: Int = 0    private var defaultHeight: Int = 0    private var oldCount: Int = 0    private var isFirstLayout = true    constructor(context: Context) : this(context, null)    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) &#123;        gap = dip2px(context, ITEM_GAP.toFloat())        defaultHeight = dip2px(context, DEFAULT_WIDTH.toFloat())        defaultWidth = defaultHeight    &#125;    fun setDefaultWidth(defaultWidth: Int) &#123;        this.defaultWidth = defaultWidth    &#125;    fun setDefaultHeight(defaultHeight: Int) &#123;        this.defaultHeight = defaultHeight    &#125;    fun setAdapter(adapter: NineGridAdapter?) &#123;        this.adapter = adapter        if (adapter == null) &#123;            return        &#125;        //初始化布局形状        generateChildrenLayout(adapter.getCount())        removeAllViews()        for (i in 0..adapter.getCount() - 1) &#123;            val itemView = adapter.getView(i)            addView(itemView, generateDefaultLayoutParams())        &#125;        oldCount = adapter.getCount()    &#125;    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;        Log.e(TAG, &quot;onMeasure&quot;)        super.onMeasure(widthMeasureSpec, heightMeasureSpec)        val widthMode = View.MeasureSpec.getMode(widthMeasureSpec)        val heightMode = View.MeasureSpec.getMode(heightMeasureSpec)        val sizeWidth = View.MeasureSpec.getSize(widthMeasureSpec)        val sizeHeight = View.MeasureSpec.getSize(heightMeasureSpec)        totalWidth = sizeWidth - paddingLeft - paddingRight        if (adapter != null &amp;&amp; adapter!!.getCount() &gt; 0) &#123;            val measureHeight: Int            //计算单个图片的大小            singleWidth = (totalWidth - gap * (columns - 1)) / columns            singleHeight = singleWidth            measureChildren(View.MeasureSpec.makeMeasureSpec(singleWidth, View.MeasureSpec.EXACTLY),                    View.MeasureSpec.makeMeasureSpec(singleHeight, View.MeasureSpec.EXACTLY))            measureHeight = singleHeight * rows + gap * (rows - 1) + paddingTop + paddingBottom            setMeasuredDimension(sizeWidth, measureHeight)        &#125;    &#125;    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123;        if (!isFirstLayout)            layoutChildrenView()        isFirstLayout = false    &#125;    private fun layoutChildrenView() &#123;        Log.e(TAG, &quot;layoutChildrenView&quot;)        if (adapter == null || adapter!!.getCount() == 0) &#123;            return        &#125;        val childrenCount = adapter!!.getCount()        for (i in 0..childrenCount - 1) &#123;            val position = findPosition(i)            val left = (singleWidth + gap) * position[1] + paddingLeft            val top = (singleHeight + gap) * position[0] + paddingTop            val right = left + singleWidth            val bottom = top + singleHeight            val childrenView = getChildAt(i) as ImageView            if (childrenCount == 1) &#123;                //只有一张图片                childrenView.scaleType = ImageView.ScaleType.FIT_CENTER            &#125; else &#123;                childrenView.scaleType = ImageView.ScaleType.CENTER_CROP            &#125;            val itemPosition = i            childrenView.setOnClickListener &#123;                if (onItemClickListerner != null) &#123;                    onItemClickListerner!!.onClick(itemPosition)                &#125;            &#125;            childrenView.layout(left, top, right, bottom)        &#125;    &#125;    private fun findPosition(childNum: Int): IntArray &#123;        val position = IntArray(2)        for (i in 0..rows - 1) &#123;            for (j in 0..columns - 1) &#123;                if (i * columns + j == childNum) &#123;                    position[0] = i//行                    position[1] = j//列                    break                &#125;            &#125;        &#125;        return position    &#125;    /**     * 根据图片个数确定行列数量     * 对应关系如下     * num  row column     * 1       1    1     * 2       1    2     * 3-4     2    2     * 5-6     2    3     * 7-9     3    3     * @param length     */    private fun generateChildrenLayout(length: Int) &#123;        if (length == 1) &#123;            rows = 1            columns = 1        &#125; else if (length &lt;= 4) &#123;            rows = 2            columns = 2        &#125; else if (length &lt;= 6) &#123;            rows = 2            columns = 3        &#125; else &#123;            rows = 3            columns = 3        &#125;        singleWidth = (totalWidth - gap * (columns - 1)) / columns        singleHeight = singleWidth    &#125;    fun setOnItemClickListener(onItemClickListerner: OnItemClickListener) &#123;        this.onItemClickListerner = onItemClickListerner    &#125;    companion object &#123;        /**         * dp to px         */        fun dip2px(context: Context, dpValue: Float): Int &#123;            val scale = context.resources.displayMetrics.density            return (dpValue * scale + 0.5f).toInt()        &#125;    &#125;&#125;</code></pre>        <h3 id="NineGridAdapter"   >          <a href="#NineGridAdapter" class="heading-link"><i class="fas fa-link"></i></a><a href="#NineGridAdapter" class="headerlink" title="NineGridAdapter"></a>NineGridAdapter</h3>      <p><code>NineGridAdapter</code>图片的数据适配器</p><pre><code>abstract class NineGridAdapter(protected var context: Context, protected var list: List) &#123;    abstract fun getCount(): Int    abstract fun getUrl(positopn: Int): String    abstract fun getItemId(position: Int): Long    abstract fun getView(i: Int): View&#125;</code></pre>        <h3 id="使用方法"   >          <a href="#使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3>      <ul><li><p>首先继承<code>NineGridAdapter</code></p><pre><code>class NineGridsAdapter(context: Context, list: MutableList&lt;String&gt;) :    NineGridAdapter(context, list) &#123;override fun getCount(): Int &#123;    return if (list == null) 0 else list.size&#125;override fun getUrl(positopn: Int): String &#123;    return list?.get(positopn)&#125;override fun getItemId(position: Int): Long &#123;    return position.toLong()&#125;override fun getView(i: Int): View &#123;    val iv = ImageView(context)    iv.setScaleType(ImageView.ScaleType.CENTER_CROP)    iv.setBackgroundColor(context.resources.getColor(R.color.color_gray_light))    Glide.with(context).load(getUrl(i)).into(iv)    return iv&#125;</code></pre><p>}</p></li><li><p>设置Adapter显示数据,添加点击响应事件</p><pre><code>val imageAdapter = NineGridsAdapter(mContext!!, imageList)        mMvpView?.picLayout?.setAdapter(imageAdapter)        mMvpView?.picLayout?.setOnItemClickListener(object : OnItemClickListener &#123;            override fun onClick(vararg args: Int) &#123;                clickImage(args[0])            &#125;        &#125;)</code></pre></li></ul><p>在此，我们的九宫格图片显示控件就制作完毕了，Enjoy It！ 最后我们的实际显示效果图如下：<br><img src="https://file.2fun.xyz/imageasd53a1sd31a.png" alt="最终效果图"></p><pre><code>&lt;h3&gt;附：点击回掉接口&lt;/h3&gt;</code></pre><p>文中使用的<code>OnItemClickListener</code>是一个自定义的点击回掉接口，附上代码</p><pre><code>interface OnItemClickListener &#123;    fun onClick(vararg args: Int)&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>获取apk的sha1值</title>
      <link href="2017/07/16/%E8%8E%B7%E5%8F%96apk%E7%9A%84sha1%E5%80%BC/"/>
      <url>2017/07/16/%E8%8E%B7%E5%8F%96apk%E7%9A%84sha1%E5%80%BC/</url>
      
        <content type="html"><![CDATA[        <h6 id="1-方式一：terminal-输入"   >          <a href="#1-方式一：terminal-输入" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-方式一：terminal-输入" class="headerlink" title="1. 方式一：terminal 输入"></a>1. 方式一：terminal 输入</h6>      <pre><code> keytool -list -v -keystore/Users/editor/AndroidStudioProjects/PocketAsk/pocketask.jks</code></pre>        <h6 id="2-方式二：Java代码"   >          <a href="#2-方式二：Java代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-方式二：Java代码" class="headerlink" title="2. 方式二：Java代码"></a>2. 方式二：Java代码</h6>      <span id="more"></span><pre><code>public static String sHA1(Context context) &#123;    try &#123;        PackageInfo info = context.getPackageManager().getPackageInfo(                context.getPackageName(), PackageManager.GET_SIGNATURES);        byte[] cert = info.signatures[0].toByteArray();        MessageDigest md = MessageDigest.getInstance(&quot;SHA1&quot;);        byte[] publicKey = md.digest(cert);        StringBuffer hexString = new StringBuffer();        for (int i = 0; i &lt; publicKey.length; i++) &#123;            String appendString = Integer.toHexString(0xFF &amp; publicKey[i])                    .toUpperCase(Locale.US);            if (appendString.length() == 1)                hexString.append(&quot;0&quot;);            hexString.append(appendString);            hexString.append(&quot;:&quot;);        &#125;        String result = hexString.toString();        return result.substring(0, result.length() - 1);    &#125; catch (PackageManager.NameNotFoundException e) &#123;        e.printStackTrace();    &#125; catch (NoSuchAlgorithmException e) &#123;        e.printStackTrace();    &#125;    return null;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java单例模式</title>
      <link href="2017/07/13/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2017/07/13/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>java单例模式 编写</p><pre><code>public static ImageLoader getInstance() &#123;    if(instance == null) &#123;        Class var0 = ImageLoader.class;        synchronized(ImageLoader.class) &#123;            if(instance == null) &#123;                instance = new ImageLoader();</code></pre><span id="more"></span><pre><code>            &#125;        &#125;    &#125;    return instance;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
