<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="不只是技术">
<meta property="og:type" content="website">
<meta property="og:title" content="罗啰明天">
<meta property="og:url" content="https://luomingbear.github.io/page/11/index.html">
<meta property="og:site_name" content="罗啰明天">
<meta property="og:description" content="不只是技术">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Bearever">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary"><title>罗啰明天</title><link ref="canonical" href="https://luomingbear.github.io/page/11/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罗啰明天</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/07/31/%E4%B8%8D%E8%A6%81%E5%9C%A8foreach%E5%BE%AA%E7%8E%AF%E9%87%8C%E8%BF%9B%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9A%84remove,add%E6%93%8D%E4%BD%9C/">不要在foreach循环里进行元素的remove,add操作</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-07-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。</p>
<ul>
<li>正确方法：</li>
</ul>

<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add("1");
list.add("2");
Iterator&lt;String&gt; iterator = list.iterator();
while (iterator.hasNext()) &#123;
    String item = iterator.next();
    if (删除元素的条件) &#123;
        iterator.remove();
    &#125;
&#125;
</code></pre>

<ul>
<li>错误方法</li>
</ul>

<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">for (String item : list) &#123;
    if ("1".equals(item)) &#123;
        list.remove(item);
    &#125;
&#125;
</code></pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/07/30/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/">重构-改善既有代码的设计（一）</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-07-30</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
  这篇文章是我对于《重构-改善既有代码的设计》一书的记录。
</blockquote>

<h3>缘由</h3>

<p>我们经常会遇到需要对之前的功能进行修改的局面，当我们重新阅读之前的代码的时候，可能会有这样的感受：“我当时到底是怎么想的啊，我根本看不懂了啊，要怎么加功能呢？写的和*一样”。如果你有这种想法的话，就说明你需要对之前的代码进行重构了。</p>
<h3>概念</h3>

<blockquote>
  <strong>重构</strong>是在不影响业务的外在表现的时候对代码进行修改和优化的行为。
</blockquote>

<p>重构应该是一种编码的思维方式，当你有空的时候就应该对之前的代码进行整理，因为你总会觉得之前的代码写的很烂的，就和你永远觉得兜里的钱很少一样。</p>
<h3>方法</h3>

<p>请不要把下面的方法当做唯一，因为这只是我脑袋还记得的东西：</p>
<ul>
<li>提炼函数</li>
<li>移动函数</li>
<li>数据封装</li>
<li>...</li>
</ul>

<h3>提炼函数</h3>

<p><em>提炼函数</em>是一个非常常用的重构方式，当我们看到了一个代码行数很多的方法的时候就可以思考一样是不是可以对这个函数进行提炼了。</p>
<p>例如，我们有如下的一段代码：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">void printOrder(double amount)&#123;
  printBanner();

  //print detail
  System.out.println("name:"+name);
  System.out.println("amount:"+amount);
&#125;
</code></pre>

<p>对于这个方法我们可以对它进行提炼，有一个很好的入口就是，当我们看到了一段代码上面有一个注释的时候，我们就可以试着把这段代码单独作为一个方法提炼起来。重构之后就变成了了下面这样：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">void printOrder(double amount)&#123;
  printBanner();
  printDetail(amount);
&#125;

void printDetail(double amount)&#123;
  System.out.println("name:"+name);
  System.out.println("amount:"+amount);
&#125;
</code></pre>

<p>提炼方法对于代码的理解是会有帮助的，通常我们阅读一个命名优美的方法名的时候就可以知道它的功能了，看详细的代码未必能够很快理解。</p>
<h3>移动函数</h3>

<p>如果一函数对于另外一个类的依赖大于本身的类，那么我们就可以尝试把这个方法转移到依赖的那个类了。</p>
<p>例如：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">class Acount&#123;
  ...
  long computeFee()&#123;
    if(type == Premium)&#123;
      long result = 10;
      if(dayOverdrawn&gt;7) result +=(dayOverdrawn -7)*0.85;
      return result;
    &#125;else &#123;
      return dayOverdrawn *1.75;
    &#125;
  &#125;

  long bankCharge()&#123;
    long result = 4.5;
    if(dayOverdrawn &gt;0) result +=computeFee();
    return result; 
  &#125;
&#125;
</code></pre>

<p>上面的方法对于<code>type</code>的依赖很高，对于不同的类型有不同的费用计算，这里我们可以把计算服务费的部分放入<code>AccountType</code>的类里面，如下：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">class AccountType&#123;
  long computeFee(int dayOverdrawn)&#123;
    if(type == Premium)&#123;
      long result = 10;
      if(dayOverdrawn&gt;7) result +=(dayOverdrawn -7)*0.85;
      return result;
    &#125;else &#123;
      return dayOverdrawn *1.75;
    &#125;
  &#125;
&#125;
</code></pre>

<p>然后在<code>Account</code>类里面替换一下引用就可以了:</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">class Acount&#123;
  ...
  long bankCharge()&#123;
    long result = 4.5;
    if(dayOverdrawn &gt;0) result +=type.computeFee(dayOverdrawn);
    return result; 
  &#125;
&#125;
</code></pre>

<h3>数据封装</h3>

<p>如果我们有一个列表项，但是必须要和其他的数据结合起来才有意义，那么我们可以使用数据封装的方式，使用对象替换数据值。</p>
<p>例如，我们有一个订单的类，里面有购买者的基本信息（这只是一个小例子）：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">class Order&#123;
  String orderId;
  String customName;
  String customPhone;
  public String getCustomName()&#123;
    return customName;
  &#125;

  public String getCustomPhone()&#123;
    return customPhone;
  &#125;
&#125;
</code></pre>

<p>对于上面的订单类，我们可以把购买者单独作为一个类存在：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">class Custom&#123;
  String customName;
  String customPhone;
  public String getCustomName()&#123;
    return customName;
  &#125;

  public String getCustomPhone()&#123;
    return customPhone;
  &#125;
&#125;
</code></pre>

<p>然后在<code>Order</code>类里面使用<code>Custom</code>来替换之前的购买者信息。</p>
<p><em>未完待续…</em></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/07/24/Android8%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97/">Android8适配指南</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-07-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1>Android 8.0适配指南</h1>

<blockquote>
  转载自“鸿洋公众号”
</blockquote>

<p>适配是个循序渐进的事情，不要想着一步到位。所以如果你还没有适配6.0或7.0可以先看看我之前的两篇了解一下。</p>
<h3><strong>准备工作</strong></h3>

<p>将我们项目中的targetSdkVersion改为 26（8.0） 或者 27（8.1），记住不要超过27，毕竟我还没有告诉你Android P怎么适配（滑稽）。</p>
<h3>运行时权限</h3>

<blockquote>
  在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。
  
  对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。
  
  例如，假设某个应用在其清单中列出 <code>READ_EXTERNAL_STORAGE</code> 和<code>WRITE_EXTERNAL_STORAGE</code>。应用请求 <code>READ_EXTERNAL_STORAGE</code>，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予 <code>WRITE_EXTERNAL_STORAGE</code>，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 <code>READ_EXTERNAL_STORAGE</code>；不过，如果该应用后来又请求<code>WRITE_EXTERNAL_STORAGE</code>，则系统会立即授予该权限，而不会提示用户。
</blockquote>

<p>所谓权限组如下：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TL2SZ4e9KjEy2W0pN7uanqFVhFmGNcra216ItNdvvbm72LAGMfs4ukMg/640" alt="" />

<p>所以总结下来，如果你之前是用什么权限就去申请什么权限，那么恭喜你，这个变化不会影响到你。如果你只申请了权限组中的某些权限，却用了同组的其他权限，那么你就需要去适配一下了。</p>
<p>那么怎么适配呢，如果你去检查之前每个申请权限的地方，未免太过麻烦。那么你可以根据你项目中的Manifest文件中需要的权限与权限组去对比，整理出你需要申请的各个权限组。比如你需要<code>android.permission.CALL_PHONE</code>(打电话)与<code>android.permission.READ_PHONE_STATE</code>(读取手机状态) 这两个权限。那么你就整理出了类似下面的类。</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">public class PermissionGroup &#123;

     //Phone权限
     public static String[] PHONE = new String[] &#123;
          Manifest.permission.READ_PHONE_STATE, 
          Manifest.permission.CALL_PHONE
     &#125;;

     ...
&#125;
</code></pre>

<p>到时在申请权限时就可以直接获取它，一次将它们都申请了。这样就防止了遗漏某个权限，导致的异常。</p>
<h3>通知适配</h3>

<p>其实8.0在通知这里变化还挺多的，比如<strong>通知渠道、通知标志、通知超时、背景颜色</strong>的等，详细的说明可以去看官方的Android 8.0 功能和 API。</p>
<p>虽然变化很多，但是国内的机子貌似支持的不多。。。我在小米的文档中了解到，Android 已将通知渠道的逻辑纳入 Android Compatibility Definition Document (CDD) 中，意味着所有 Android 厂商都必须支持。所以我们可以放心的去适配。</p>
<blockquote>
  通知渠道：Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。
</blockquote>

<p>我个人很喜欢这个新特性。也就是说，我们可以将我们给用户的通知进行分类，我用高德地图app来举例，从左到右分别是小米(MIUI10)、华为(EMUI 8.1.0)、一加(氢OS 5.1)：</p>
<div class="table-container"><table>
<thead>
<tr>
  <th>小米(MIUI10)</th>
  <th>华为(EMUI 8.1.0)</th>
  <th>一加(氢OS 5.1)</th>
</tr>
</thead>
<tbody>
<tr>
  <td><img   src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLcuWLrWJrDukcUCtLPa7YibFrPxibSQbxqibM4WlGv2JYwSmUbvrslehvg/640?wx_fmt=png" style=""  alt="" /></td>
  <td><img   src="https://mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLDPzaice3qkGXWtAdCiaibLMucDrOg4Jm2nWo80ZP6dPk3TUwkfXwtHPzw/640?wx_fmt=jpeg" style=""  alt="" /></td>
  <td><img   src="https://mmbiz.qpic.cn/mmbiz_jpg/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLlDFLsWHZBMn0Afkjn1ibhWzfdApOPfSB7dQ7prjG8qgib1aLh3GiaicJ5Q/640?wx_fmt=jpeg&amp;tp=webp" style=""  alt="" /></td>
</tr>
</tbody>
</table></div>

<p>可以看到高德地图分的很细致，分为四个组共13个类别(华为貌似对组不生效)。这样有个好处，我们可以控制我们想收到的通知，比如我不喜欢运营活动通知，那我就可以把它关闭。</p>
<p>这样避免大量的不必要通知，否则使得用户觉得烦，一棒子打死。直接关闭你的允许通知。当然了，大量app都还没有适配，适配的也都分的不是很细致，比如下图的QQ。(没有对比就没有伤害)</p>
<img   src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLL0Pvibric8ez96WGo0WSzkR68LjARC4qiaOqgJyMhkHiau4AZ2PUiaurFuw/640?wx_fmt=png" style=""  alt="" />

<p>当然更重要的问题是，如果不去适配，可能通知都不会弹出来。那么适配的方法如下：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">private void createNotificationChannel() &#123;
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;

        NotificationManager notificationManager = (NotificationManager)
                getSystemService(Context.NOTIFICATION_SERVICE);

        //分组（可选）
        //groupId要唯一
        String groupId = "group_001";
        NotificationChannelGroup group = new NotificationChannelGroup(groupId, "广告");

        //创建group
        notificationManager.createNotificationChannelGroup(group);

        //channelId要唯一
        String channelId = "channel_001";

        NotificationChannel adChannel = new NotificationChannel(channelId,
                "推广信息", NotificationManager.IMPORTANCE_DEFAULT);
        //补充channel的含义（可选）
        adChannel.setDescription("推广信息");
        //将渠道添加进组（先创建组才能添加）
        adChannel.setGroup(groupId);
        //创建channel
        notificationManager.createNotificationChannel(adChannel);

        //创建通知时，标记你的渠道id
        Notification notification = new Notification.Builder(MainActivity.this, channelId)
                .setSmallIcon(R.mipmap.ic_launcher)
                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
                .setContentTitle("一条新通知")
                .setContentText("这是一条测试消息")
                .setAutoCancel(true)
                .build();
        notificationManager.notify(1, notification);

    &#125;
&#125;
</code></pre>

<p>效果如下：</p>
<img   src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwObVghrTU2MxbmdgAAvv7TLD0miaWuolxicPtTOOiakVtV1ksTjticQbABn4RxkVbo9zWUbLBy2dZHBJg/640?wx_fmt=png" style=""  alt="" />

<p>华为手机当只有一个渠道时，不会显示，会当做默认通知处理，除非一个以上。</p>
<blockquote>
  注意：当Channel已经存在时，后面的createNotificationChannel方法仅能更新其name/description，以及对importance进行降级，其余配置均无法更新。所以如果有必要的修改只能创建新的渠道，删除旧渠道。
</blockquote>

<p>删除渠道代码如下：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">private void deleteNotificationChannel(String channelId)&#123;
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;
        NotificationManager mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
        mNotificationManager.deleteNotificationChannel(channelId);
    &#125;

&#125;
</code></pre>

<h3>悬浮窗适配</h3>

<p>使用 <code>SYSTEM_ALERT_WINDOW</code> 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口：</p>
<ul>
<li>TYPE_PHONE</li>
<li>TYPE_PRIORITY_PHONE</li>
<li>TYPE_SYSTEM_ALERT</li>
<li>TYPE_SYSTEM_OVERLAY</li>
<li>TYPE_SYSTEM_ERROR</li>
</ul>

<p>相反，应用必须使用名为 TYPE_APPLICATION_OVERLAY 的新窗口类型。也就是说需要在之前的基础上判断一下：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;
    mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
&#125;else &#123;
    mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT
&#125;
</code></pre>

<p>当然记得需要有权限</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-xml">&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt;
&lt;uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW" /&gt;
</code></pre>

<h3>安装APK</h3>

<p>Android 8.0去除了“允许未知来源”选项，所以如果我们的App有安装App的功能（检查更新之类的），那么会无法正常安装。</p>
<p>首先在AndroidManifest文件中添加安装未知来源应用的权限:</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-xml">&lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/&gt;
</code></pre>

<p>这样系统会自动询问用户完成授权。当然你也可以先使用 canRequestPackageInstalls()查询是否有此权限，如果没有的话使用<code>Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES</code>这个action将用户引导至安装未知应用权限界面去授权。</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">private static final int REQUEST_CODE_UNKNOWN_APP = 100;

private void installAPK()&#123;

    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;
        boolean hasInstallPermission = getPackageManager().canRequestPackageInstalls();
        if (hasInstallPermission) &#123;
            //安装应用
        &#125; else &#123;
            //跳转至“安装未知应用”权限界面，引导用户开启权限
            Uri selfPackageUri = Uri.parse("package:" + this.getPackageName());
            Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri);
            startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP);
        &#125;
    &#125;else &#123;
        //安装应用
    &#125;

&#125;

//接收“安装未知应用”权限的开启结果
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;
    super.onActivityResult(requestCode, resultCode, data);
    if (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123;
        installAPK();
    &#125;
&#125;
</code></pre>

<h3>集合的处理</h3>

<p>现在，AbstractCollection.removeAll(null) 和 AbstractCollection.retainAll(null)始终引发 NullPointerException；之前，当集合为空时不会引发 NullPointerException。所以我们需要做判空处理。</p>
<h3>后台执行限制</h3>

<p>应用在两个方面受到限制：</p>
<ul>
<li><strong>后台服务限制：</strong>处于空闲状态时，应用可以使用的后台服务存在限制。 这些限制不适用于前台服务，因为前台服务更容易引起用户注意。</li>
<li><strong>广播限制：</strong>除了有限的例外情况，应用无法使用清单注册隐式广播。 它们仍然可以在运行时注册这些广播，并且可以使用清单注册专门针对它们的显式广播。</li>
</ul>

<p>在大多数情况下，应用都可以使用 JobScheduler 克服这些限制。 这种方式让应用安排为在未活跃运行时执行工作，不过仍能够使系统可以在不影响用户体验的情况下安排这些作业。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/07/14/lover/">lover</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-07-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>/*<br>您可以在此处加入您的CSS。</p>
<p>点击上方的帮助图标来了解更多。<br>*/</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/07/12/TabLayout%20%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/">TabLayout 使用入门</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-07-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>介绍</h3>

<p>TabLayout是Google官方设计的一个分类UI，效果类似如下：<br><img src="https://file.2fun.xyz/wx20180712162109.png" alt="TabLayout" title="TabLayout" /><br>通常，我们会和ViewPager一起配合使用，实现滑动ViewPager，上面的分类也会跟着切换的效果。</p>
<h3>ViewPager设置</h3>

<p>使用ViewPager之前，需要设置Adapter，推荐使用<code>FragmentStatePagerAdapter</code>或者<code>FragmentPagerAdapter</code>。TabLayout会根据ViewPager的页数显示Tab,默认的Tab是一个文本view，里面的文字需要通过实现Adapter的<code>getPageTitle(int position)</code>方法来自动生成。</p>
<p>TabLayout绑定ViewPager，只需要调用一个方法即可：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">mTabLayout.setupWithViewPager(mViewPager);
</code></pre>

<h3>TabLayout 文本颜色</h3>

<p>设置TabLayout的文本的颜色十分简单，有两种方式，一个是xml文件的形式，另一个是java代码的形式。</p>
<ul>
<li>xml方法：</li>
</ul>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-xml">&lt;android.support.design.widget.TabLayout
    android:id="@+id/tab_layout"
    android:layout_width="match_parent"
    android:layout_height="44dp"
    app:tabSelectedTextColor="@color/ls_color_red"
    app:tabTextColor="@color/ls_color_blue"&gt;
</code></pre>

<ul>
<li>java代码形式：</li>
</ul>

<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">mTabLayout.setTabTextColors(int normalColor, int selectedColor);
</code></pre>

<h3>Tablayout 文字大小</h3>

<p>如果是要设置统一的文本大小，也很简单，只需要在<code>values\style</code>里面添加一个风格代码就可以：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-xml">&lt;style name="MyTabLayoutTextStyle" parent="TextAppearance.AppCompat.Title"&gt;
    &lt;item name="android:textSize"&gt;@字体大小&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>然后布局文件里面设置<code>tabTextAppearance</code>参数</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-xml">&lt;android.support.design.widget.TabLayout
    android:id="@+id/tab_layout"
    android:layout_width="match_parent"
    android:layout_height="44dp"
    app:tabTextAppearance="@style/OrderTabLayoutTextStyle"&gt;
</code></pre>

<p><strong>但是，如果你想要动态改变文字的大小，例如选中的文字比未选中的大</strong>，那就不能用这个方法了。</p>
<h3>TabLayout 动态改变文字的大小</h3>

<p>由于TabLayout官方没有设置文本大小的方法，所以，我们只能寻找其他的办法，所以我们可以使用自定义View的形式；<code>TabLayout.Tab</code>有一个方法叫<code>setCustomView(@Nullable View view)</code>,通过customView,我们就可以实现对文本大小的控制了。<br>通过遍历TabLayout的tabs,然后添加自定义的view：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">for (int i = 0; i &lt; mTabLayout.getTabCount(); i++) &#123;
    TabLayout.Tab tab = mTabLayout.getTabAt(i);
    TextView tv = new TextView(getContext());
    LinearLayout.LayoutParams p = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
             ViewGroup.LayoutParams.WRAP_CONTENT);
    tv.setLayoutParams(p);
    tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
    tv.setText(tab.getText());
    tab.setCustomView(tv);
&#125;
</code></pre>

<p>监听tab的切换，然后当tab被选中就把文字大小改变：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123;
    @Override
    public void onTabSelected(TabLayout.Tab tab) &#123;
        if(tab.getCustomView() == null)&#123;
            return;
        &#125;

        //todo-*******对文本大小进行修改*******
    &#125;
&#125;
</code></pre>

<h3>改变横线的长度和高度</h3>

<ul>
<li><p>高度
控制横线的高度可以在xml文件里面写上<code>tabIndicatorHeight</code>参数。</p></li>
<li><p>长度
虽然不能直接通过TabLayout的方法对长度进行控制，但是查看源码知道，横线的长度和tab的宽度有关，可以通过反射得到tabview然后设置长度：</p></li>
</ul>

<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">try &#123;
    LinearLayout mTabStrip = (LinearLayout) mTabLayout.getChildAt(0);
    int dp10 = DeviceUtils.dp2px(10);
    for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123;
        View tabView = mTabStrip.getChildAt(i);
        tabView.setPadding(0, 0, 0, 0);

        //设置tab左右间距为10dp  注意这里不能使用Padding 因为源码中线的宽度是根据 tabView的宽度来设置的
        LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams();
        params.width = DeviceUtils.dp2px(42);
        params.leftMargin = dp10;
        params.rightMargin = dp10;
        tabView.setLayoutParams(params);
        tabView.invalidate();
        &#125;
&#125; catch (Exception e) &#123;
    e.printStackTrace();
&#125;
</code></pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/06/23/Lets%20Encrypt%20%E4%BD%BF%E7%94%A8/">Lets Encrypt 使用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-06-23</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>Lets Encrypt</h3>

<p>Lets Encrypt是一个免费的Https签发服务。</p>
<h3>acme.sh</h3>

<p>acme.sh是一个方便Lets Encrypt生成签证的脚本，可以非常方便的使用。</p>
<h3>安装acme.sh</h3>

<p>安装很简单, 一个命令:</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-shell">curl  https://get.acme.sh | sh
</code></pre>

<p>普通用户和 root 用户都可以安装使用. 安装过程进行了以下几步:</p>
<p>把 acme.sh 安装到你的 home 目录下:</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-shell">~/.acme.sh/
</code></pre>

<p>并创建 一个 bash 的 alias, 方便你的使用:</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-shell">alias acme.sh=~/.acme.sh/acme.sh
</code></pre>

<h3>获取证书</h3>

<p>lets encrypt需要使用dns来验证身份，acme可以帮助你自动设置dns，但是你需要配置dns。<br>如果使用的是阿里云的话，需要通过<strong><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ak-console.aliyun.com/#/accesskey"  title="阿里云链接">阿里云链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong>设置accessKey,然后将获取到的保存到环境里面。</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-shell">export Ali_Key="sdfsdfsdfljlbjkljlkjssaddfoiwje"
export Ali_Secret="jlsdflanljkljlfdsassklkjflsa"
</code></pre>

<p>现在你就可以生成https证书了</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-shell">acme.sh --issue --dns dns_ali -d example.com -d www.example.com
</code></pre>

<p>生成的证书会保存在<code>~/.acme.sh/account.conf</code>目录里面。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/05/06/Eloquent%20in%20SlimPHP/">Eloquent in SlimPHP</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>环境安装</h3>

<p>在项目目录里面执行<br><code>composer require illuminate/database "~5.1"</code></p>
<h3>配置数据库</h3>

<p>在settings的文件里面添加数据库的配置信息，主要是“db=&gt;”对应的内容。</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-php">&lt;?php
return [
    'settings' =&gt; [
        // Slim Settings
        'determineRouteBeforeAppMiddleware' =&gt; false,
        'displayErrorDetails' =&gt; true,
        'db' =&gt; [
            'driver' =&gt; 'mysql',
            'host' =&gt; 'localhost',
            'database' =&gt; 'database',
            'username' =&gt; 'user',
            'password' =&gt; 'password',
            'charset'   =&gt; 'utf8',
            'collation' =&gt; 'utf8_unicode_ci',
            'prefix'    =&gt; '',
        ]
    ],
];
</code></pre>

<h3>使用数据库</h3>

<p>在controller的代码里面使用数据库：<br><code>$table = $c-&gt;get('db')-&gt;table('table_name');</code><br>例如：</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-php">$container[App\WidgetController::class] = function ($c) &#123;
    $view = $c-&gt;get('view');
    $logger = $c-&gt;get('logger');
    $table = $c-&gt;get('db')-&gt;table('table_name');
    return new \App\WidgetController($view, $logger, $table);
&#125;;
</code></pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/03/22/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">备忘录模式</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-03-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>缘由</h3>

<p>今天在看关于设计模式的文章的时候，偶然看到一个叫做“<strong>备忘录模式</strong>”的设计模式，感觉名字甚是有趣，便研究了一番。</p>
<h3>开始学习</h3>

<p>备忘录模式，顾名思义就是可以向备忘录一样支持记录过程并且可以查看到每一步的状态的一种设计模式。最常见的使用是一些美图软件里面，需要对图片处理的过程进行记录，用户可以回退到上一步，也可以前进到最新的一步。下面是类图：<br><img src="http://my.csdn.net/uploads/201205/02/1335891550_5966.jpg" alt="类图" title="类图" /></p>
<ul>
<li><strong>Originator</strong>
原发器：动作的发起者，负责创建一个备忘录来记录当前对象的内部状态，并可使用备忘录恢复内部状态。</p></li>
<li><p><strong>Memento</strong>
备忘录：负责存储发起者对象的内部状态，<strong>只有原发器可以创建备忘录并修改备忘录</strong>。</p></li>
<li><p><strong>Caretaker</strong>
负责人：用于管理备忘录，但是不能修改备忘录，只负责存储备忘录。</p></li>
</ul>

<h3>举个例子</h3>

<p>我们在编写文章的时候，经常会有撤销和回退的需求，这里可以使用备忘录模式设计。为了满足多次撤销的功能，我们可以再负责人类里面持有一个备忘录的列表，这样就可以记录一条过程了。demo的效果图如下：
<img src="https://file.2fun.xyz/android_memento_parttern_demo_show.gif" alt="输入的撤销会回退demo" title="输入的撤销会回退demo" />
具体的类图如下：
<img src="https://file.2fun.xyz/article_memento_parttern_uml" alt="文字输入的demo类图" title="文字输入的demo类图" />

<ul>
<li><strong>ArticleMemento</strong>
文章备忘录类：用于对文章的状态进行保存。下面的代码省略了get、set方法。</li>
</ul>

<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">public class ArticleMemento &#123;
            private String title = ""; //标题
            private String content = ""; //内容
            private int selection = 0; //指针的位置

            public ArticleMemento(ArticleOriginator originator) &#123;
                this.title = originator.getTitle();
                this.content = originator.getContent();
                this.selection = originator.getSelection();
            &#125;
     &#125;
</code></pre>

<ul>
<li><strong>ArticleOriginator</strong>
文章的原发器，用于创建和修改文章备忘录。</li>
</ul>

<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">public class ArticleOriginator &#123;
    private String title = ""; //标题
    private String content = ""; //内容
    private int selection = 0; //指针的位置

    public ArticleMemento createMemento() &#123;
        return new ArticleMemento(this);
    &#125;

    public ArticleOriginator setArticleMemento(ArticleMemento memento) &#123;
        this.title = memento.getTitle();
        this.content = memento.getContent();
        this.selection = memento.getSelection();
        return this;
    &#125;
&#125;
</code></pre>

<ul>
<li><strong>ArticleCaretaker</strong>
文章备忘录的负责人,管理备忘录历史记录。</li>
</ul>

<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">public class ArticleCaretaker &#123;
    private List&lt;ArticleMemento&gt; mMementoList; //备忘录列表
    private int mMaxLength = 20; //记录的步数 ，限制记录的次数有助于减少内存使用
    private int index = 0; //记录当前的步数

    public ArticleCaretaker() &#123;
        mMementoList = new ArrayList&lt;&gt;();
    &#125;

    /**
     * 记录一次备忘
     *
     * @param memento
     */
    public void saveMemento(ArticleMemento memento) &#123;
        //将index后面的删除掉
        List&lt;ArticleMemento&gt; removes = new ArrayList&lt;&gt;();
        for (int i = index + 1; i &lt; mMementoList.size(); i++) &#123;
            removes.add(mMementoList.get(i));
        &#125;
        mMementoList.removeAll(removes);
        if (memento != null) &#123;
            mMementoList.add(memento);
            //长度超过了最大值就需要将第一个备忘删除掉
            if (mMementoList.size() &gt; mMaxLength) &#123;
                mMementoList.remove(0);
            &#125;
        &#125;

        index = Math.max(0, mMementoList.size() - 1);
    &#125;

    /**
     * 获取最后一步的备忘
     *
     * @return
     */
    public ArticleMemento undo() &#123;
        index = Math.max(0, index - 1);
        if (mMementoList.size() &gt; 1) &#123;
            return mMementoList.get(index);
        &#125; else return null;
    &#125;

    /**
     * 恢复一个步骤
     *
     * @return
     */
    public ArticleMemento redo() &#123;
        //没有记录返回空
        if (mMementoList.size() == 0) &#123;
            return null;
        &#125;

        index = Math.min(mMementoList.size() - 1, index + 1);
        return mMementoList.get(index);
    &#125;
&#125;
</code></pre>

<p><strong>使用</strong></p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-java">//在需要的地方创建ArticleCaretaker 和ArticleOriginator的对象，然后通过ArticleOriginator获取ArticleMemento对象保存在ArticleCaretaker。通过ArticleCaretaker来进行文章的撤销会回退功能
mArticleOriginator = new ArticleOriginator();
mArticleCaretaker = new ArticleCaretaker();
//修改文章的内容
mArticleOriginator
      .setContent(s.toString())
      .setSelection(s.length());
//保存记录
mArticleCaretaker.saveMemento(mArticleOriginator.createMemento());
//undo和redo
ArticleMemento memento = mArticleCaretaker.undo();
ArticleMemento memento = mArticleCaretaker.redo();
</code></pre>

<h3>总结</h3>

<p>备忘录模式适用于需要保存操作记录的地方，需要注意的地方是：<strong>备忘录类只能在原发器类里面创建和修改，对其他的类保持封闭，负责人类只负责保存管理备忘录类，不需要知道备忘录类的具体内容和实现</strong>。</p>
<ul>
<li><p><strong>优点</strong>
(1)它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。
(2)备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</p></li>
<li><p><strong>缺点</strong>
资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</p></li>
</ul></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2/">设计模式初探</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-03-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><img src="https://file.2fun.xyz/designPatternBearever.jpg" alt="设计模式" title="设计模式" />

<h3>面向对象的设计原则</h3>

<p>在看设计模式的时候都会多少提到面向对象的设计原则，明白了这些设计原则对于理解设计模式是很有帮助的，所以我就先介绍下面向对象的设计原则。<br>设计原则是为了服务于软件开发，<strong>提高一个软件的可维护性和复用性</strong>。常见的设计原则如下：</p>
<div class="table-container"><table>
<thead>
<tr>
  <th>设计原则</th>
  <th>说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>单一原则</td>
  <td>一个类只负责一个具体领域的职责</td>
</tr>
<tr>
  <td>开闭原则</td>
  <td>软件实体应对拓展开放，对修改关闭</td>
</tr>
<tr>
  <td>里氏代换原则</td>
  <td>所有引用基类对象的地方可以透明地使用它子类的对象</td>
</tr>
<tr>
  <td>依赖倒转原则</td>
  <td>抽象不应该依赖于具体细节，细节应该依赖于抽象</td>
</tr>
<tr>
  <td>合成复用原则</td>
  <td>尽量使用对象组合而不是继承达到复用的目的</td>
</tr>
<tr>
  <td>迪卡特法则</td>
  <td>一个软件实体应该尽可能少的于其他实体发生关系</td>
</tr>
</tbody>
</table></div>

<h3>设计模式</h3>

<p>知道了常用的设计原则之后，我们可以看看常见的设计模式，本篇文章不对设计模式进行具体的讨论，具体的请看详细分析的文章。</p>
<div class="table-container"><table>
<thead>
<tr>
  <th>设计模式</th>
  <th>说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td>单例模式</td>
  <td>一个类在全局只有一个实例，并且提供全局访问的方法</td>
</tr>
<tr>
  <td>工厂模式</td>
  <td>定义一个创建对象的接口，让子类决定具体生成什么</td>
</tr>
<tr>
  <td>外观模式</td>
  <td>为一个复杂的业务提供一个统一的入口，使得外部使用更加方便</td>
</tr>
<tr>
  <td>迭代器模式</td>
  <td>提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示</td>
</tr>
<tr>
  <td>观察者模式</td>
  <td>一对多的依赖关系，被观察对象的状态改变，所有的观察者都会受到通知</td>
</tr>
<tr>
  <td>组合模式</td>
  <td>组合多个对象形成树形结构，组合对象和单个对象的使用具有一致性</td>
</tr>
<tr>
  <td>适配器模式</td>
  <td>将一个接口转化为客户端希望的另外的接口，使得不兼容的接口可以正常工作</td>
</tr>
<tr>
  <td>命令模式</td>
  <td>使用抽象命令类将请求参数化，客户端只需要知道使用命令即可</td>
</tr>
<tr>
  <td>策略模式</td>
  <td>将算法的使用和定义分开，让算法可以随客户而变化</td>
</tr>
</tbody>
</table></div></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/03/15/%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6Android/">安装软件Android</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-03-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>缘由</h3>

<p>很多时候我们都需要给应用添加更新的功能，当我们下载完了安装包了，肯定是希望能够自动安装新版本的。但是由于安卓系统的限制，我们没法做到无感知的安装，所以就需要使用系统的软件安装器让用户去安装了。</p>
<h3>代码</h3>

<pre>
/**
 * 安装apk文件
 *
 * @param apkFile 安装包所在目录
 */
public static void installApk(Context context, File apkFile) {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    try {
        String[] command = {"chmod", "777", apkFile.toString()};
        ProcessBuilder builder = new ProcessBuilder(command);
        builder.start();
    } catch (IOException ignored) {
    }

    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
        intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        Uri contentUri = FileProvider.getUriForFile(context,
                context.getApplicationContext().getPackageName() + ".provider", apkFile);
        intent.setDataAndType(contentUri, context.getContentResolver().getType(contentUri));
    } else {
        intent.setDataAndType(Uri.fromFile(apkFile), "application/vnd.android.package-archive");
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    }

    context.startActivity(intent);
    //关闭旧版本的应用程序的进程
    android.os.Process.killProcess(android.os.Process.myPid());
}
</pre></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/10/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/12/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">162</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Bearever</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>