<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="不只是技术">
<meta property="og:type" content="website">
<meta property="og:title" content="罗啰明天">
<meta property="og:url" content="https://luomingbear.github.io/page/12/index.html">
<meta property="og:site_name" content="罗啰明天">
<meta property="og:description" content="不只是技术">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Bearever">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary"><title>罗啰明天</title><link ref="canonical" href="https://luomingbear.github.io/page/12/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">罗啰明天</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2018/01/03/%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88%E5%BE%97%E5%88%B024/">数字组合得到24</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2018-01-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><img width="100%" src="https://file.2fun.xyz/python_computer24.jpg" alt="寻找24的组合" />
<h3>缘由</h3>
今天同事给我出了一道题：

<blockquote>有四个数字：8、8、3、3，通过加减乘除还有括号，使得结果为24</blockquote>

<p>我一看这么简单的数学题，我弟弟都会，简直就是毫无挑战，于是就拿出笔开始算。“3x8=24”这么简单啊，但是还有两个“3、8”啊！，就这样算了一个小时，还是没算出来，内心很受打击。但是，没关系，我是程序员怎么可能解不出来啊，我非得写个算法算出来。于是有了下面的故事…</p>
<h3>思路</h3>
要求出值为24的排列方式，我想到了暴力解法，将每一种可能性算一遍，如果结果刚好是24，那就是我需要的答案了呗。
所以题目就被分解了三个步骤：
<ul>
        <li>遍历获取数字的排列方式</li>
    <li>对于每一种数字的排列方式，获取符号的排列方式</li>
    <li>计算每一种排列情况的值是否等于目标值</li>
</ul>

<h3>遍历数字的排列可能</h3>
<strong>思路：</strong>4个数字有顺序的排列，其实就是一个排列组合问题，共有4*3*2*1 = 24种可能。我的想法是通过循环的方式遍历每一个可能，则对于第一个数字可以有四个数字可以选择，对于第二个数字则有剩余三个数字可以选择，对于第三个数字则有剩余两个数字可选，最后的一个数字则只剩一种可以选择。

<h3>遍历得到符号的排列组合</h3>
思路：对于可以使用的符号有“加减乘除”，另外还有括号，其实括号只是改变了计算的顺序，而我们已经将每一个可能的计算顺序排列了出来，所以只需要一步一步的从左往右计算就可以了。在四个数字之间加入符号一共有四个位置：
<img src="https://file.2fun.xyz/computer24shuzihefuhao.png" alt="符号的位置" />
只需要对每一个位置进行一次循环求得所有的符号排列情况就好，需要注意的是：第一个符号位只能有“加减号”。

<h3>计算</h3>
对于每一个数字和符号的排列进行组合的情况，需要进行计算是否与目标值24相等，如果相等就打印出来。因为我们通过前面的组合得到了一个带有计算符号的字符串，这里我们可以使用<code>eval()</code>函数将值计算出来。
<strong>注意情况：</strong>由于我们的所有操作都是从左到右一步一步的计算，如图：
<img src="https://file.2fun.xyz/computer24jisaunss.png" alt="计算步骤" />
所以会导致无法匹配出<code>8/（1/3）=24</code>的情况，所以，<strong>当我们计算出来值为目标值的倒数的时候，就需要将除数与被除数交换位置，这个时候得到的表达式也是对的</strong>。

<h3>完整代码</h3>
<pre>


        <h1 id="coding-UTF-8"   >
          <a href="#coding-UTF-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#coding-UTF-8" class="headerlink" title="-- coding: UTF-8 --"></a>-<em>- coding: UTF-8 -</em>-</h1>
      <p>from fractions import Fraction</p>

        <h1 id="目标值"   >
          <a href="#目标值" class="heading-link"><i class="fas fa-link"></i></a><a href="#目标值" class="headerlink" title="目标值"></a>目标值</h1>
      <p>targetNum = 24</p>

        <h1 id="已经输出的结果"   >
          <a href="#已经输出的结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#已经输出的结果" class="headerlink" title="已经输出的结果"></a>已经输出的结果</h1>
      <p>printList = []</p>

        <h1 id="获取对应的符号"   >
          <a href="#获取对应的符号" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取对应的符号" class="headerlink" title="获取对应的符号"></a>获取对应的符号</h1>
      
        <h1 id="运算"   >
          <a href="#运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算" class="headerlink" title="运算"></a>运算</h1>
      <p>def getNum(num1, num2, fu):<br>    if fu == ‘/‘:<br>        return “Fraction(“ + num1 + “,” + num2 + “)”<br>    else:<br>        return str(num1) + fu + str(num2)</p>

        <h1 id="计算结果-数字有4位，符号有3位"   >
          <a href="#计算结果-数字有4位，符号有3位" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算结果-数字有4位，符号有3位" class="headerlink" title="计算结果 ,数字有4位，符号有3位"></a>计算结果 ,数字有4位，符号有3位</h1>
      <p>def computer(numlist, fulist):<br>    global printList<br>    global targetNum</p>
<pre><code># 前面两个数字计算的结果
v = &quot;0&quot;
# 计算表达式
pp = &quot;&quot;
# 遍历符号
# 从左到右依次计算，不需要按照乘除法先算的规则，因为要考虑括号的情况
for x in range(0, len(fulist)):
    if x == 0:
        v = getNum(&#39;&#39;, numlist[x], fulist[x])
        pp = &quot;&quot; + fulist[x] + numlist[x]
    else:
        v = &quot;(&quot; + getNum(v, numlist[x], fulist[x]) + &quot;)&quot;
        pp = &quot;(&quot; + pp + fulist[x] + numlist[x] + &quot;)&quot;

try:
    # 判断是否已经输出了这个表达式，如果没有会报错
    if printList.index(pp):
        return

except Exception as e:
    # 拦截错误，计算是否匹配结果
    dif = eval(v) - targetNum
    if abs(dif) == 0:
        printList.append(pp)
        print(&#39;----------------------&#39;)
        print(pp, &quot;=&quot;, eval(v))
        print(&#39;----------------------&#39;)
    elif eval(v) == Fraction(1, targetNum):
        v = &quot;&quot;
        pp = &quot;&quot;
        # 除法倒置，将最后的一个除法的除数和被除数交换
        for x in range(0, len(fulist)):
            if x == 0:
                v = getNum(&#39;&#39;, numlist[x], fulist[x])
                pp = &quot;&quot; + fulist[x] + numlist[x]
            else:
                # 如果最后一个符号是“/”，则倒置
                if x == len(fulist) - 1 and fulist[x] == &#39;/&#39;:
                    v = &quot;(&quot; + getNum(numlist[x], v, fulist[x]) + &quot;)&quot;
                    pp = &quot;(&quot; + numlist[x] + fulist[x] + pp + &quot;)&quot;
                else:
                    v = &quot;(&quot; + getNum(v, numlist[x], fulist[x]) + &quot;)&quot;
                    pp = &quot;(&quot; + pp + fulist[x] + numlist[x] + &quot;)&quot;

        # 同样的计算方式，只打印一次
        try:
            printList.index(pp)
        except Exception as e:
            printList.append(pp)
            print(&#39;----------------------&#39;)
            print(pp, &quot;=&quot;, eval(v))
            print(&#39;----------------------&#39;)
</code></pre>

        <h1 id="计算排列组合答案"   >
          <a href="#计算排列组合答案" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算排列组合答案" class="headerlink" title="计算排列组合答案"></a>计算排列组合答案</h1>
      <p>def computer24(numList):<br>    global num</p>
<pre><code># 循环遍历出数字排列组合
for x in range(0, len(numList)):
    # 得到第一个数字
    a = numList[x]
    # 获得剩下的三个数字的列表
    restListA = []
    for x1 in range(0, len(numList)):
        if x1 != x:
            restListA.append(numList[x1])

    for y in range(0, len(restListA)):
        # 第二个数字
        b = restListA[y]
        restListB = []
        for y1 in range(0, len(restListA)):
            if y1 != y:
                restListB.append(restListA[y1])

            #
            for z in range(0, len(restListB)):
                # 第三个数字
                c = restListB[z]
                for z1 in range(0, len(restListB)):
                    if z1 != z:
                        d = restListB[z1]

                        numArray = [a, b, c, d]
                        # 得到了数字组合，需要对数字间隔进行填符号

                        # 第一个符号
                        fulist = [&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]
                        for q in range(0, 2):
                            # 第二位
                            for w in range(0, 4):
                                # 第三位
                                for e in range(0, 4):
                                    # 第四位
                                    for r in range(0, 4):
                                        f = [fulist[q], fulist[w],
                                             fulist[e], fulist[r]]
                                        # print(numArray, f)
                                        computer(numArray, f)
</code></pre>
<p>computer24([‘8’,’8’,’3’,’3’])<br>print(“计算完成！”)</p>
<p></pre></p>
<h3>运行实例</h3>
<ul>
    <li>计算<code>8、8、3、3</code>组合成<code>24</code></li>
<code>>>>(8/((-8/3)+3)) = 24</code>
    <li>计算<code>1、5、5、5</code>组合为<code>24</code></li>
<code>>>>(((-1/5)+5)*5) = 24</code>
        <li>计算<code>4、4、10、10</code>组合为<code>24</code></li>
<code>>>>(((+10*10)-4)/4)= 24</code>
        <li>计算<code>2、2、11、11</code>组合为<code>24</code></li>
<code>>>>(((+2/11)+2)*11) = 24</code>

</ul>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/12/28/%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E5%BA%93%20IBleLib%E7%9A%84%E4%BD%BF%E7%94%A8/">蓝牙连接库 IBleLib的使用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-12-28</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>蓝牙连接库 IBleLib</h3>
<strong>IBLeLib</strong>是一个安卓平台的蓝牙库，可以方便的实现蓝牙的搜索、连接、数据读取的操作。
<img src="https://file.2fun.xyz/ible_show_logo.jpg" alt="IBleLib" />
<h4>Github链接</h4>
所有的代码和Demo都已经上传到了Github，喜欢可以star。
<a href="https://github.com/Luomingbear/IBleLib" target="_blank" rel="noopener noreferrer"><strong>点击跳转到Github</strong></a>


<h4>效果图</h4>
Demo实现了蓝牙的搜索和链接配对，到数据获取，链接的对象是一个蓝牙电子秤，当电子秤获得质量之后会发送一个数据返回给应用。

<img src="https://file.2fun.xyz/BleDemo_sample20171228.gif" alt="效果图" height="400" width="300"/>

<h3>使用方法</h3>
所有的操作都简化到了一个类里面<code>IBleManager</code>，通过调用<code>IBleManager.getInstance()</code>来获取单例对象。

<h4>打开关闭</h4>
<ul>
    <li>打开蓝牙</li>
<pre>IBleManager.getInstance().openBle()</pre>

<pre><code>&lt;li&gt;关闭蓝牙&lt;/li&gt;
</code></pre>
<pre>IBleManager.getInstance().closeBle()</pre>

<pre><code>&lt;li&gt;判断蓝牙是否打开&lt;/li&gt;
</code></pre>
<pre>IBleManager.getInstance().isOpen()</pre>
<p>返回值是布尔值,<code>true</code>:打开，<code>false</code>:关闭</p>
</ul>

<h4>搜索</h4>
<ul>
    <li>开始搜索</li>
<pre>
IBleManager.getInstance().startSearch(Context activity, IBleSearchManager.OnIBleSearchListener listener)
</pre>
    <li>结束搜索</li>
<pre>IBleManager.getInstance().stopSearch() </pre>
</ul>

<h4>连接</h4>
<ul>
        <li>配对</li>
<pre>IBleManager.getInstance().bond(String mac, OnBleBondListener listener)</pre>

<pre><code>&lt;li&gt;开始连接&lt;/li&gt;
</code></pre>
<pre>
IBleManager.getInstance().connect(Context context, String mac, UUID uuid, OnBleConnectListener listener)
</pre>
<p><strong>UUID</strong>:UUID是通用唯一识别码（Universally Unique Identifier）的缩写，蓝牙的每一个服务通过特定的UUID来标识，可以通过查看蓝牙服务于UUID的对应关系来找到自己需要的UUID。</p>
<pre><code>&lt;li&gt;断开连接&lt;/li&gt;
</code></pre>
<pre>IBleManager.getInstance().disConnect(String mac) </pre>

<pre><code>    &lt;li&gt;是否连接成功&lt;/li&gt;
</code></pre>
<pre>IBleManager.getInstance().isConnect(String mac)</pre>
</ul>

<h4>读取数据</h4>
<pre>IBleManager.getInstance().read(Context context, String mac, UUID uuid, OnIBleReadListener listener)</pre>

<h3>注意事项</h3>
蓝牙的搜索需要使用到定位权限，需要动态申请权限的时候请务必先获取权限然后在搜索蓝牙。</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/12/20/WebView%20%EF%BC%88Android%EF%BC%89%E4%BD%BF%E7%94%A8/">WebView （Android）使用</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-12-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>WebView 介绍</h3>

<p>WebView是安卓平台用来显示网控件，可以实现App的混合开发需求。我们可能会有这样的需求，系统后台发送一个活动给用户，但是这个活动是会变化的，所以不能使用安卓的原生界面直接显示，那样会约束掉UI界面，使用网页来介绍活动就很有用了。<br><img src="https://file.2fun.xyz/webview_sample_gcross.png" alt="机核网的WebView显示文章" /></p>
<h3>设置</h3>

<p>当我们在布局文件里面添加了WebView控件之后，我们就可以对他进行操作了，首先需要对他进行设置，以满足你的需求。</p>
<h4>获取WebSettings</h4>

<pre>
WebSettings webSettings = webView.getSettings();
</pre>

<h4>设置</h4>

<pre>
//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript
webSettings.setJavaScriptEnabled(true);

// 若加载的 html 里有JS 在执行动画等操作，会造成资源浪费（CPU、电量）
// 在 onStop 和 onResume 里分别把 setJavaScriptEnabled() 给设置成 false 和 true 即可

//设置自适应屏幕，两者合用
webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小
webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小

//缩放操作
webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。
webSettings.setBuiltInZoomControls(false); //设置内置的缩放控件。若为false，则该WebView不可缩放
webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件

//其他细节操作
webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存
webSettings.setAllowFileAccess(true); //设置可以访问文件
webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口
webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片
webSettings.setDefaultTextEncodingName("utf-8");//设置编码格式
</pre>

<h3>加载网页</h3>

<pre>
//方式1. 加载一个网页：
webView.loadUrl("http://www.google.com/");

//方式2：加载apk包中的html页面
webView.loadUrl("file:///android_asset/test.html");

//方式3：加载手机本地的html页面
webView.loadUrl("content://com.android.htmlfileprovider/sdcard/test.html");

//方式4：加载html字符串
mWebView.loadData(htmlString,"text/html", "utf-8");
</pre>

<h3>WebViewClient</h3>

<p>用来处理各种通知和请求事件<br>常用的方法</p>
<ul>
    <li>shouldOverrideUrlLoading()</li>
当网页跳转到新的地址的时候执行，可以用来拦截跳转等，获取用来进行HTML和app的数据交互。

<pre><code>&lt;li&gt;onPageStarted&lt;/li&gt;
</code></pre>
<p>网页开始载入的时候调用。</p>
<pre><code>&lt;li&gt;onPageFinished&lt;/li&gt;
</code></pre>
<p>网页加载结束的时候调用。</p>
<pre><code>&lt;li&gt;onReceivedError&lt;/li&gt;
</code></pre>
<p>网页加载错误的时候调用，如404。</p>
</ul>

<h3>WebChromeClient</h3>

<p>辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。</p>
<ul>
    <li>onProgressChanged</li>
网页加载进度变化的时候调用。

<pre><code>&lt;li&gt;onReceivedTitle&lt;/li&gt;
</code></pre>
<p>获取网页的标题。</p>
<pre><code>&lt;li&gt;onJsAlert&lt;/li&gt;
</code></pre>
<p>当网页弹窗显示的时候调用。</p>
<pre><code>&lt;li&gt;onJsConfirm&lt;/li&gt;
</code></pre>
<p>当网页点击了确认按钮时候调用。</p>
</ul>

<h3>注意事项：如何避免WebView内存泄露</h3>

<ul>
    <li>不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext()</li>

<pre><code>&lt;li&gt;在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。&lt;/li&gt;
</code></pre>
<pre>
@Override
    protected void onDestroy() {
        if (mWebView != null) {
            mWebView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null);
            mWebView.clearHistory();

            ((ViewGroup) mWebView.getParent()).removeView(mWebView);
            mWebView.destroy();
            mWebView = null;
        }
        super.onDestroy();
    }
</pre>
</ul></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/12/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%20Java/">线程池 Java</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-12-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>线程池 介绍</h3>
在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：

<blockquote>如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</blockquote>

<p>那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？<br>这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p>
<h3>Java自带的线程池</h3>
JDK自带了几种线程池，在<code>Executors</code>里面可以直接new出来，下面主要介绍常用的四种：
<ul>
    <li><code><strong>newFixedThreadPool</strong></code>
创建一个指定线程数量的线程池，如果线程数量超过指定数量，则会在线程队列里面等待，直到线程池有空余。
</li>

<pre><code>&lt;li&gt;&lt;code&gt;&lt;strong&gt;newCachedThreadPool&lt;/strong&gt;&lt;/code&gt;
</code></pre>
<p>创建一个可缓存的线程池，这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p>
</li>

<pre><code>&lt;li&gt;&lt;code&gt;&lt;strong&gt;newSingleThreadExecutor&lt;/strong&gt;&lt;/code&gt;
</code></pre>
<p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。</p>
</li>

<pre><code>&lt;li&gt;&lt;code&gt;&lt;strong&gt;newScheduleThreadPool&lt;/strong&gt;&lt;/code&gt;
</code></pre>
<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。</p>
</li>

</ul>

<h3>线程池的使用</h3>
以单线程的线程池为例：
<pre>
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 10; i++) {
            final int index = i;
            singleThreadExecutor.execute(new Runnable() {
                public void run() {
                    try {
                        System.out.println(index);
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</pre>
最后的输出结果就是从0打印到9，每次打印间隔2s，并且是有序的。</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/11/15/Android%20%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D/">Android 拨打电话</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-11-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h2>拨打电话</h2>

<p>Android拨打电话有两种方式，一个是<strong>调用拨号盘</strong>，然后用户点击拨号按钮，代码如下</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-null">/** 
 * 调用拨号界面 
 * @param phone 电话号码 
 */  
private void call(String phone) &#123;  
    Intent intent = new Intent(Intent.ACTION_DIAL,Uri.parse("tel:"+phone));  
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);  
    startActivity(intent);  
&#125;  
</code></pre>

<p>另外的一种方式是<strong>直接拨号</strong>，代码如下:</p>
<pre class="line-numbers prism-highlight" data-start="1"><code class="language-null">/** 
 * 调用拨号功能 
 * @param phone 电话号码 
 */  
private void call(String phone) &#123;  
    Intent intent=new Intent(Intent.ACTION_CALL,Uri.parse("tel:"+phone));  
    startActivity(intent);  
&#125;  
</code></pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/10/19/Html%20Canvas%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%9B%BE/">Html Canvas 自定义绘图</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-10-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>Html Canvas 自定义绘图</h3>
制作 Html 的时候我们总是不可避免的会遇到需要自定义 Canvas 绘图的情况，最近我在做网页的时候就遇到了需要需要自定义的绘图控件，效果图如下，框起来的地方就是我遇到的难点：
<img src="https://file.2fun.xyz/card_canvas_show.png" alt="canvas效果" />
这是一个可以变化的进度条，上面有一个标签指向进度的位置。直接用html标签组合不实用，于是我想到了使用canvas的方式来绘制。

<h3>需求分析</h3>
<ul>
    <li>只需要简单引用一个js文件</li>
    <li>实现一个类，所有操作可以通过该类方法直接设置</li>
    <li>可以复用</li>
</ul>

<h3>实现类</h3>
<code>js</code>是脚本语言，没有类的概念，但是我们可以使用方法来实现类似类的效果，具体方法是:
<pre>
//类
function ClassName(){
    this.a = 0; //假设定义变量 a = 0
    // ....变量定义 //


<pre><code>//方法
function functionName()&#123;
    //具体交互
    this.a = 1 //改变变量的值
&#125;
</code></pre>
<p>}<br></pre></p>
<h3>Canvas绘图</h3>
接下来我们来实现效果图的进度条效果，通过观察可以发现进度条控件可以分为两个部分，一个是底下的长条，另一部分就是上面的标签了。所以我们可以分为两个步骤来实现这个效果。

<h4>实现长条</h4>
我们可以将进度条拆分为上下两层，底下的灰色圆角矩形和表示进度的橘色圆角矩形，因为两个圆角矩形的区别只有长度和颜色，所以我们可以定义一个方法，用来绘制指定长度和颜色的圆角矩形：
<pre>
/**画圆角矩形
 * progress :进度1 -100
 * color ：颜色
*/
this.drawRectLine = function(progress, color) {
    progress = Math.min(progress, 100);
    progress = Math.max(progress, 0);

<pre><code>var height = this.canvas.getBoundingClientRect().height;
    //进度条的高度
var lineHeight = height / 5;
var width = this.canvas.width - lineHeight / 2;
    
    //设置填充颜色
this.ctx.fillStyle = color;
    //开始绘制路径
this.ctx.beginPath();
    //设置起点
this.ctx.moveTo(lineHeight / 2, height - lineHeight);

//终点的x坐标
var endX = progress / 100.0 * width;
endX = Math.max(endX, lineHeight / 2);

    //绘制直线
this.ctx.lineTo(width - lineHeight / 2, height - lineHeight);
    //绘制圆弧
this.ctx.arc(endX, height - lineHeight / 2, lineHeight / 2, -Math.PI / 2, Math.PI / 2);
this.ctx.lineTo(lineHeight / 2, height);
this.ctx.arc(lineHeight / 2, height - lineHeight / 2, lineHeight / 2, Math.PI / 2, -Math.PI / 2);
    //填充路径
this.ctx.fill();
</code></pre>
<p>}<br></pre></p>
<h4>绘制进度标签</h4>
进度标签分为地步的气泡和上面的文字，可以分为两步完成。首先实现气泡背景，方法与绘制圆角矩形类似，只需要根据形状绘制路径填充即可。接下来是绘制文字：
<pre>
//画文字
this.drawText = function() {
    //设置文字的颜色
    this.ctx.fillStyle = "white";
    //设置文字的字体
    this.ctx.font = "" + this.canvas.height / 4 + "px OpenSans";

<pre><code>//设置显示的文本
var s = &quot;筹款中&quot;
if(this.progress &gt;= 100)
    s = &quot;完成&quot;

//根据进度计算文字的x坐标
var x = this.progress / 100.0 * (this.canvas.width) - this.ctx.measureText(s).width / 2;
if(x &lt; this.tagWidth / 2)
    x = this.tagWidth / 2 - this.ctx.measureText(s).width / 2;
else if(x &gt; this.canvas.width - this.tagWidth)
    x = this.canvas.width - this.tagWidth / 2 - this.ctx.measureText(s).width / 2;

var y = this.canvas.height / 5 * 1.5;

//绘制文字
this.ctx.fillText(s, x, y);
</code></pre>
<p>}<br></pre></p>
<h3>定义外部调用方法</h3>
实现了绘制的逻辑之后，我们还需要定义一个方法，来实现进度的显示和改变。
<pre>
// 设置进度
this.setProgress = function(progress) {
    this.progress = progress;
    this.showProgress();
}

<p>//显示进度<br>this.showProgress = function() {<br>    this.drawRectLine(100.0, this.bgColor);</p>
<pre><code>this.drawRectLine(this.progress, this.hiColor);

this.drawTag();

this.drawText();
</code></pre>
<p>}<br></pre></p>
<h3>注意事项</h3>
这里有一个很大的坑，就是canvas默认是<code>300x150</code>的大小，就算你在html里面设置了宽高，它也只会根据这个大小进行拉伸，所以显示会有拉伸现象。
<strong>解决办法：</strong>根据canvas的大小对画布进行重新设置大小：
<pre>
//重新设置画布的大小，解决画布拉伸的问题
this.canvas.width = this.canvas.offsetWidth;
this.canvas.height = this.canvas.offsetHeight;
</pre>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/10/12/%E5%89%91%E6%8C%87Offer%20%EF%BC%88Python%EF%BC%89%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/">剑指Offer （Python）变态跳台阶</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-10-12</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>推荐在线编程平台</h3>

<p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com"  target="_blank" rel="noopener noreferrer">牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
<h3>题目描述</h3>

<blockquote>
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
</blockquote>

<h3>分析</h3>

<p>这是“<span class="exturl"><a class="exturl__link"   href="https://www.bearever.cn/archives/473"  target="_blank" rel="noopener noreferrer">跳台阶</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>”的一个变形，我们可以用相同的思路来计算：</p>
<ol>
    <li>令<code>f(n)</code>表示跳n级台阶的跳法</li>
    <li>假设青蛙第一次跳了一级台阶，那么剩下n-1级台阶有<code>f(n-1)</code>种跳法；
如果第一次跳了两级台阶，则剩下n-2级台阶有<code>f(n-2)</code>种跳法。
</li>
    <li>以此类推，可以得到：
<code>f(n) = f(0) + f(1) + f(2) + ... + f(n-2) + f(n-1)</code>
通过这个公式，我们可以知道:
<code>f(n-1) = f(0) + f(1) + f(2) + ... + f(n-2)</code>
</li>
    <li>所以<code>f(n) = 2 * f(n-1)</code>
说明跳n级台阶的跳法就是跳上前一级跳法的两倍，所以我们可以通过递归来计算。
</li>

</ol>

<h3>代码</h3>

<pre>
# -*- coding:utf-8 -*-
class Solution:

    def jumpFloorII(self, number):

        if number == 0:
            return 0
        elif number == 1:
            return 1
        else:
            a = 1
            for i in xrange(number - 1):
                b = 2 * a
                a = b
            return a

</pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E8%B7%B3%E5%8F%B0%E9%98%B6/">剑指Offer（Python） 跳台阶</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-10-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>推荐在线编程平台</h3>
<strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com"  target="_blank" rel="noopener noreferrer">牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong>

<h3>题目描述</h3>
<blockquote>
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
</blockquote>

<h3>分析</h3>
对于本题,前提只有一次 1阶或者2阶的跳法。 
a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1); 
b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2) 
c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)  
d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2 
e.可以发现最终得出的是一个斐波那契数列： 
<img src="https://file.2fun.xyz/fibonacci_jump_function.png" alt="斐波那契数列" />

<h3>代码</h3>
<pre>
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloor(self, number):
        a = 1
        b = 2
        if number == 1:
            return a
        elif number == 2:
            return b

<pre><code>    # 循环计算
    for i in range(number - 2):
        # 设置临时变量记录加上之后的值
        c = a + b
        # 更新值
        a = b
        b = c
    return b
</code></pre>
<p></pre></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">剑指Offer（Python） 斐波那契数列</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-10-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>推荐在线编程平台</h3>

<p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com"  target="_blank" rel="noopener noreferrer">牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
<h3>题目描述</h3>

<blockquote>
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。
n<=39
</blockquote>

<h3>分析</h3>

<p>题目要求求出斐波那契数列的第n项，我们需要先弄明白什么是斐波那契数列，然后后就可以轻松的求解了。</p>
<h3>概念</h3>

<blockquote>
<strong>斐波那契数列：</strong>指的是这样一个数列：0、1、1、2、3、5、8、13、21、……在数学上，斐波纳契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=F(n-1)+F(n-2)（n>=2，n∈N*），用文字来说，就是斐波那契数列列由 0 和 1 开始，之后的斐波那契数列系数就由之前的两数相加。
</blockquote>

<h3>思路</h3>

<p>根据斐波那契数列的概念，我们可以通过递归的方式求得第n项，但是这样计算量会很大，编程平台是不能通过的，提示时间超时。那么我们就优化一下算法，用递推的方式，将前面两个值的数据记录下来，循环添加前面两个数的值就可以了。</p>
<h3>代码</h3>

<pre>
# -*- coding:utf-8 -*-
class Solution:

    def Fibonacci(self, n):
        a = 0
        b = 1
        if n == 0:
            return a
        elif n == 1:
            return b
        elif n == 2:
            return 1

        # 循环计算
        for i in range(n - 1):
            # 设置临时变量记录加上之后的值
            c = a + b
            # 更新值
            a = b
            b = c
        return b
</pre></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2017/10/11/%E5%89%91%E6%8C%87Offer%EF%BC%88Python%EF%BC%89%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/">剑指Offer（Python）旋转数组的最小数字</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2017-10-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-03-18</span></span></div></header><div class="post-body"><div class="post-excerpt"><h3>推荐在线编程平台</h3>

<p><strong><span class="exturl"><a class="exturl__link"   href="https://www.nowcoder.com"  target="_blank" rel="noopener noreferrer">牛客网在线编程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
<h3>题目描述</h3>

<blockquote>
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
</blockquote>

<h3>分析</h3>

<p>由题目可以知道，原数组的右边大于左边，旋转之后的数组的最小值就是他们的分界，所以我们只需要找到这个分界就可以了。通过循环，一旦有一个值小于列表第一个值那么他就一定在分界处。</p>
<h3>代码</h3>

<pre>
# -*- coding:utf-8 -*-
class Solution:

    def minNumberInRotateArray(self, rotateArray):
        if len(rotateArray) == 0:
            return 0

        min = rotateArray[0]

        for x in rotateArray:
            if x < min:
                min = x
                break
        return min
</pre></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/11/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/13/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">162</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Bearever</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>